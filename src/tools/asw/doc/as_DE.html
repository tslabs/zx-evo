<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META NAME="Author" CONTENT="automatically generated by tex2html from as.tex">
<META NAME="Last-modified" CONTENT="Mon Jun 14 20:20:33 2010">
<TITLE>Bedienungsanleitung Makroassembler AS</TITLE>
</HEAD>
<BODY>
<P>
<P>





















<P>
<P>
<DIV ALIGN=LEFT>
<BIG> Alfred Arnold</BIG><BR>



<P>
<BIG><BIG> Makroassembler AS V1.42</BIG></BIG><BR>
<HR WIDTH="62%" ALIGN=LEFT><BR>
<P>
<BIG><BIG> Benutzeranleitung</BIG></BIG>



<P>
<BIG> Stand Janua 2010</BIG>
</DIV>
<P>
<P>












<P>
<EM> IBM, PPC403Gx, OS/2</EM> und<EM> PowerPC</EM> sind eingetragene
Warenzeichen der IBM Corporation.
<P>
<EM> Intel, MCS-48, MCS-51, MCS-251, MCS-96, MCS-196</EM> und<EM>
MCS-296</EM> sind eingetragene Warenzeichen der Intel Corp. .
<P>
<EM> Motorola</EM> und<EM> ColdFire</EM> sind eingetragene
Warenzeichen von Motorola Inc. .
<P>
<EM> PicoBlaze</EM> ist ein eingetragenes Warenzeichen der Xilinx
Inc.
<P>
<EM> UNIX</EM> ist ein eingetragenes Warenzeichen der Open Group.
<P>
<EM> Linux</EM> ist ein eingetragenes Warenzeichen von Linus
Thorvalds.
<P>
<EM> Microsoft, Windows</EM> und<EM> MS-DOS</EM> sind eingetragene
Warenzeichen der Microsoft Corporation.
<P>
Alle anderen Warenzeichen, die nicht ausdr&uuml;cklich in diesem
Abschnitt genannt wurden und in diesem Handbuch verwendet werden,
sind Eigentum der entsprechenden Eigent&uuml;mer.
<P>


















<P>
Dieses Dokument wurde mit dem LaTeX-Satzsystem unter dem
Betriebssystem Linux angefertigt und formatiert.
<P>
<P>
<P>
<P>
<H1>Inhalt</H1><P>
<P><H2><A HREF="#sect_1_">1. Allgemeines</A></H2>
<P><H3><A HREF="#sect_1_1_">1.1. Lizenzbedingungen</A></H3>
<P><H3><A HREF="#sect_1_2_">1.2. allgemeine F&auml;higkeiten des Assemblers</A></H3>
<P><H3><A HREF="#sect_1_3_">1.3. Unterst&uuml;tzte Plattformen</A></H3>
<P><H2><A HREF="#sect_2_">2. Benutzung des Assemblers</A></H2>
<P><H3><A HREF="#sect_2_1_">2.1. Hardware-Anforderungen</A></H3>
<P><H3><A HREF="#sect_2_2_">2.2. Lieferumfang</A></H3>
<P><H3><A HREF="#sect_2_3_">2.3. Installation</A></H3>
<P><H3><A HREF="#sect_2_4_">2.4. Aufruf, Parameter</A></H3>
<P><H3><A HREF="#sect_2_5_">2.5. Format der Eingabedateien</A></H3>
<P><H3><A HREF="#sect_2_6_">2.6. Format des Listings</A></H3>
<P><H3><A HREF="#sect_2_7_">2.7. Symbolkonventionen</A></H3>
<P><H3><A HREF="#sect_2_8_">2.8. Tempor&auml;re Symbole</A></H3>
<P><H4><A HREF="#sect_2_8_1_">2.8.1. Tempor&auml;re Symbole mit Namen</A></H4>
<P><H4><A HREF="#sect_2_8_2_">2.8.2. Zusammengesetzte tempor&auml;re Symbole</A></H4>
<P><H3><A HREF="#sect_2_9_">2.9. Formelausdr&uuml;cke</A></H3>
<P><H4><A HREF="#sect_2_9_1_">2.9.1. Integerkonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_2_">2.9.2. Gleitkommakonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_3_">2.9.3. Stringkonstanten</A></H4>
<P><H4><A HREF="#sect_2_9_4_">2.9.4. Evaluierung</A></H4>
<P><H4><A HREF="#sect_2_9_5_">2.9.5. Operatoren</A></H4>
<P><H4><A HREF="#sect_2_9_6_">2.9.6. Funktionen</A></H4>
<P><H3><A HREF="#sect_2_10_">2.10. Vorw&auml;rtsreferenzen und andere Desaster</A></H3>
<P><H3><A HREF="#sect_2_11_">2.11. Registersymbole</A></H3>
<P><H3><A HREF="#sect_2_12_">2.12. Sharefile</A></H3>
<P><H3><A HREF="#sect_2_13_">2.13. Prozessor-Aliasse</A></H3>
<P><H2><A HREF="#sect_3_">3. Pseudobefehle</A></H2>
<P><H3><A HREF="#sect_3_1_">3.1. Definitionen</A></H3>
<P><H4><A HREF="#sect_3_1_1_">3.1.1. SET, EQU und CONSTANT</A></H4>
<P><H4><A HREF="#sect_3_1_2_">3.1.2. SFR und SFRB</A></H4>
<P><H4><A HREF="#sect_3_1_3_">3.1.3. XSFR und YSFR</A></H4>
<P><H4><A HREF="#sect_3_1_4_">3.1.4. LABEL</A></H4>
<P><H4><A HREF="#sect_3_1_5_">3.1.5. BIT</A></H4>
<P><H4><A HREF="#sect_3_1_6_">3.1.6. DBIT</A></H4>
<P><H4><A HREF="#sect_3_1_7_">3.1.7. PORT</A></H4>
<P><H4><A HREF="#sect_3_1_8_">3.1.8. REG und NAMEREG</A></H4>
<P><H4><A HREF="#sect_3_1_9_">3.1.9. LIV und RIV</A></H4>
<P><H4><A HREF="#sect_3_1_10_">3.1.10. CHARSET</A></H4>
<P><H4><A HREF="#sect_3_1_11_">3.1.11. CODEPAGE</A></H4>
<P><H4><A HREF="#sect_3_1_12_">3.1.12. ENUM</A></H4>
<P><H4><A HREF="#sect_3_1_13_">3.1.13. PUSHV und POPV</A></H4>
<P><H3><A HREF="#sect_3_2_">3.2. Codebeeinflussung</A></H3>
<P><H4><A HREF="#sect_3_2_1_">3.2.1. ORG</A></H4>
<P><H4><A HREF="#sect_3_2_2_">3.2.2. CPU</A></H4>
<P><H4><A HREF="#sect_3_2_3_">3.2.3. SUPMODE, FPU, PMMU</A></H4>
<P><H4><A HREF="#sect_3_2_4_">3.2.4. FULLPMMU</A></H4>
<P><H4><A HREF="#sect_3_2_5_">3.2.5. PADDING</A></H4>
<P><H4><A HREF="#sect_3_2_6_">3.2.6. PACKING</A></H4>
<P><H4><A HREF="#sect_3_2_7_">3.2.7. MAXMODE</A></H4>
<P><H4><A HREF="#sect_3_2_8_">3.2.8. EXTMODE und LWORDMODE</A></H4>
<P><H4><A HREF="#sect_3_2_9_">3.2.9. SRCMODE</A></H4>
<P><H4><A HREF="#sect_3_2_10_">3.2.10. BIGENDIAN</A></H4>
<P><H4><A HREF="#sect_3_2_11_">3.2.11. WRAPMODE</A></H4>
<P><H4><A HREF="#sect_3_2_12_">3.2.12. SEGMENT</A></H4>
<P><H4><A HREF="#sect_3_2_13_">3.2.13. PHASE und DEPHASE</A></H4>
<P><H4><A HREF="#sect_3_2_14_">3.2.14. SAVE und RESTORE</A></H4>
<P><H4><A HREF="#sect_3_2_15_">3.2.15. ASSUME</A></H4>
<P><H4><A HREF="#sect_3_2_16_">3.2.16. EMULATED</A></H4>
<P><H4><A HREF="#sect_3_2_17_">3.2.17. BRANCHEXT</A></H4>
<P><H3><A HREF="#sect_3_3_">3.3. Datendefinitionen</A></H3>
<P><H4><A HREF="#sect_3_3_1_">3.3.1. DC[.size]</A></H4>
<P><H4><A HREF="#sect_3_3_2_">3.3.2. DS[.size]</A></H4>
<P><H4><A HREF="#sect_3_3_3_">3.3.3. DB,DW,DD,DQ &amp; DT</A></H4>
<P><H4><A HREF="#sect_3_3_4_">3.3.4. DS, DS8</A></H4>
<P><H4><A HREF="#sect_3_3_5_">3.3.5. BYT oder FCB</A></H4>
<P><H4><A HREF="#sect_3_3_6_">3.3.6. BYTE</A></H4>
<P><H4><A HREF="#sect_3_3_7_">3.3.7. DC8</A></H4>
<P><H4><A HREF="#sect_3_3_8_">3.3.8. ADR oder FDB</A></H4>
<P><H4><A HREF="#sect_3_3_9_">3.3.9. WORD</A></H4>
<P><H4><A HREF="#sect_3_3_10_">3.3.10. DW16</A></H4>
<P><H4><A HREF="#sect_3_3_11_">3.3.11. LONG</A></H4>
<P><H4><A HREF="#sect_3_3_12_">3.3.12. SINGLE, DOUBLE und EXTENDED</A></H4>
<P><H4><A HREF="#sect_3_3_13_">3.3.13. FLOAT und DOUBLE</A></H4>
<P><H4><A HREF="#sect_3_3_14_">3.3.14. EFLOAT, BFLOAT, TFLOAT</A></H4>
<P><H4><A HREF="#sect_3_3_15_">3.3.15. Qxx und LQxx</A></H4>
<P><H4><A HREF="#sect_3_3_16_">3.3.16. DATA</A></H4>
<P><H4><A HREF="#sect_3_3_17_">3.3.17. ZERO</A></H4>
<P><H4><A HREF="#sect_3_3_18_">3.3.18. FB und FW</A></H4>
<P><H4><A HREF="#sect_3_3_19_">3.3.19. ASCII und ASCIZ</A></H4>
<P><H4><A HREF="#sect_3_3_20_">3.3.20. STRING und RSTRING</A></H4>
<P><H4><A HREF="#sect_3_3_21_">3.3.21. FCC</A></H4>
<P><H4><A HREF="#sect_3_3_22_">3.3.22. DFS oder RMB</A></H4>
<P><H4><A HREF="#sect_3_3_23_">3.3.23. BLOCK</A></H4>
<P><H4><A HREF="#sect_3_3_24_">3.3.24. SPACE</A></H4>
<P><H4><A HREF="#sect_3_3_25_">3.3.25. RES</A></H4>
<P><H4><A HREF="#sect_3_3_26_">3.3.26. BSS</A></H4>
<P><H4><A HREF="#sect_3_3_27_">3.3.27. DSB und DSW</A></H4>
<P><H4><A HREF="#sect_3_3_28_">3.3.28. DS16</A></H4>
<P><H4><A HREF="#sect_3_3_29_">3.3.29. ALIGN</A></H4>
<P><H4><A HREF="#sect_3_3_30_">3.3.30. LTORG</A></H4>
<P><H3><A HREF="#sect_3_4_">3.4. Makrobefehle</A></H3>
<P><H4><A HREF="#sect_3_4_1_">3.4.1. MACRO</A></H4>
<P><H4><A HREF="#sect_3_4_2_">3.4.2. IRP</A></H4>
<P><H4><A HREF="#sect_3_4_3_">3.4.3. IRPC</A></H4>
<P><H4><A HREF="#sect_3_4_4_">3.4.4. REPT</A></H4>
<P><H4><A HREF="#sect_3_4_5_">3.4.5. WHILE</A></H4>
<P><H4><A HREF="#sect_3_4_6_">3.4.6. EXITM</A></H4>
<P><H4><A HREF="#sect_3_4_7_">3.4.7. SHIFT</A></H4>
<P><H4><A HREF="#sect_3_4_8_">3.4.8. MAXNEST</A></H4>
<P><H4><A HREF="#sect_3_4_9_">3.4.9. FUNCTION</A></H4>
<P><H3><A HREF="#sect_3_5_">3.5. Strukturen</A></H3>
<P><H4><A HREF="#sect_3_5_1_">3.5.1. Definition</A></H4>
<P><H4><A HREF="#sect_3_5_2_">3.5.2. Nutzung</A></H4>
<P><H4><A HREF="#sect_3_5_3_">3.5.3. geschachtelte Strukturen</A></H4>
<P><H4><A HREF="#sect_3_5_4_">3.5.4. Unions</A></H4>
<P><H4><A HREF="#sect_3_5_5_">3.5.5. Strukturen und Sektionen</A></H4>
<P><H3><A HREF="#sect_3_6_">3.6. bedingte Assemblierung</A></H3>
<P><H4><A HREF="#sect_3_6_1_">3.6.1. IF / ELSEIF / ENDIF</A></H4>
<P><H4><A HREF="#sect_3_6_2_">3.6.2. SWITCH / CASE / ELSECASE / ENDCASE</A></H4>
<P><H3><A HREF="#sect_3_7_">3.7. Listing-Steuerung</A></H3>
<P><H4><A HREF="#sect_3_7_1_">3.7.1. PAGE</A></H4>
<P><H4><A HREF="#sect_3_7_2_">3.7.2. NEWPAGE</A></H4>
<P><H4><A HREF="#sect_3_7_3_">3.7.3. MACEXP</A></H4>
<P><H4><A HREF="#sect_3_7_4_">3.7.4. LISTING</A></H4>
<P><H4><A HREF="#sect_3_7_5_">3.7.5. PRTINIT und PRTEXIT</A></H4>
<P><H4><A HREF="#sect_3_7_6_">3.7.6. TITLE</A></H4>
<P><H4><A HREF="#sect_3_7_7_">3.7.7. RADIX</A></H4>
<P><H4><A HREF="#sect_3_7_8_">3.7.8. OUTRADIX</A></H4>
<P><H3><A HREF="#sect_3_8_">3.8. lokale Symbole</A></H3>
<P><H4><A HREF="#sect_3_8_1_">3.8.1. Grunddefinition (SECTION/ENDSECTION)</A></H4>
<P><H4><A HREF="#sect_3_8_2_">3.8.2. Verschachtelung und Sichtbarkeitsregeln</A></H4>
<P><H4><A HREF="#sect_3_8_3_">3.8.3. PUBLIC und GLOBAL</A></H4>
<P><H4><A HREF="#sect_3_8_4_">3.8.4. FORWARD</A></H4>
<P><H4><A HREF="#sect_3_8_5_">3.8.5. Geschwindigkeitsaspekte</A></H4>
<P><H3><A HREF="#sect_3_9_">3.9. Diverses</A></H3>
<P><H4><A HREF="#sect_3_9_1_">3.9.1. SHARED</A></H4>
<P><H4><A HREF="#sect_3_9_2_">3.9.2. INCLUDE</A></H4>
<P><H4><A HREF="#sect_3_9_3_">3.9.3. BINCLUDE</A></H4>
<P><H4><A HREF="#sect_3_9_4_">3.9.4. MESSAGE, WARNING, ERROR und FATAL</A></H4>
<P><H4><A HREF="#sect_3_9_5_">3.9.5. READ</A></H4>
<P><H4><A HREF="#sect_3_9_6_">3.9.6. RELAXED</A></H4>
<P><H4><A HREF="#sect_3_9_7_">3.9.7. END</A></H4>
<P><H2><A HREF="#sect_4_">4. Prozessorspezifische Hinweise</A></H2>
<P><H3><A HREF="#sect_4_1_">4.1. 6811</A></H3>
<P><H3><A HREF="#sect_4_2_">4.2. PowerPC</A></H3>
<P><H3><A HREF="#sect_4_3_">4.3. DSP56xxx</A></H3>
<P><H3><A HREF="#sect_4_4_">4.4. H8/300</A></H3>
<P><H3><A HREF="#sect_4_5_">4.5. SH7000/7600/7700</A></H3>
<P><H3><A HREF="#sect_4_6_">4.6. MELPS-4500</A></H3>
<P><H3><A HREF="#sect_4_7_">4.7. 6502UNDOC</A></H3>
<P><H3><A HREF="#sect_4_8_">4.8. MELPS-740</A></H3>
<P><H3><A HREF="#sect_4_9_">4.9. MELPS-7700/65816</A></H3>
<P><H3><A HREF="#sect_4_10_">4.10. M16</A></H3>
<P><H3><A HREF="#sect_4_11_">4.11. 4004/4040</A></H3>
<P><H3><A HREF="#sect_4_12_">4.12. MCS-48</A></H3>
<P><H3><A HREF="#sect_4_13_">4.13. MCS-51</A></H3>
<P><H3><A HREF="#sect_4_14_">4.14. MCS-251</A></H3>
<P><H3><A HREF="#sect_4_15_">4.15. 8085UNDOC</A></H3>
<P><H3><A HREF="#sect_4_16_">4.16. 8086..V35</A></H3>
<P><H3><A HREF="#sect_4_17_">4.17. 8X30x</A></H3>
<P><H3><A HREF="#sect_4_18_">4.18. XA</A></H3>
<P><H3><A HREF="#sect_4_19_">4.19. AVR</A></H3>
<P><H3><A HREF="#sect_4_20_">4.20. Z80UNDOC</A></H3>
<P><H3><A HREF="#sect_4_21_">4.21. Z380</A></H3>
<P><H3><A HREF="#sect_4_22_">4.22. TLCS-900(L)</A></H3>
<P><H3><A HREF="#sect_4_23_">4.23. TLCS-90</A></H3>
<P><H3><A HREF="#sect_4_24_">4.24. TLCS-870</A></H3>
<P><H3><A HREF="#sect_4_25_">4.25. TLCS-47</A></H3>
<P><H3><A HREF="#sect_4_26_">4.26. TLCS-9000</A></H3>
<P><H3><A HREF="#sect_4_27_">4.27. 29xxx</A></H3>
<P><H3><A HREF="#sect_4_28_">4.28. 80C16x</A></H3>
<P><H3><A HREF="#sect_4_29_">4.29. PIC16C5x/16C8x</A></H3>
<P><H3><A HREF="#sect_4_30_">4.30. PIC17C4x</A></H3>
<P><H3><A HREF="#sect_4_31_">4.31. ST6</A></H3>
<P><H3><A HREF="#sect_4_32_">4.32. ST7</A></H3>
<P><H3><A HREF="#sect_4_33_">4.33. ST9</A></H3>
<P><H3><A HREF="#sect_4_34_">4.34. 6804</A></H3>
<P><H3><A HREF="#sect_4_35_">4.35. TMS3201x</A></H3>
<P><H3><A HREF="#sect_4_36_">4.36. TMS320C2x</A></H3>
<P><H3><A HREF="#sect_4_37_">4.37. TMS320C3x</A></H3>
<P><H3><A HREF="#sect_4_38_">4.38. TMS9900</A></H3>
<P><H3><A HREF="#sect_4_39_">4.39. TMS70Cxx</A></H3>
<P><H3><A HREF="#sect_4_40_">4.40. TMS370xxx</A></H3>
<P><H3><A HREF="#sect_4_41_">4.41. MSP430</A></H3>
<P><H3><A HREF="#sect_4_42_">4.42. COP8 &amp; SC/MP</A></H3>
<P><H3><A HREF="#sect_4_43_">4.43. SC144xxx</A></H3>
<P><H3><A HREF="#sect_4_44_">4.44. 75K0</A></H3>
<P><H3><A HREF="#sect_4_45_">4.45. 78K0</A></H3>
<P><H3><A HREF="#sect_4_46_">4.46. 78K2</A></H3>
<P><H3><A HREF="#sect_4_47_">4.47. uPD772x</A></H3>
<P><H3><A HREF="#sect_4_48_">4.48. F2MC16L</A></H3>
<P><H2><A HREF="#sect_5_">5. Dateiformate</A></H2>
<P><H3><A HREF="#sect_5_1_">5.1. Code-Dateien</A></H3>
<P><H3><A HREF="#sect_5_2_">5.2. Debug-Dateien</A></H3>
<P><H2><A HREF="#sect_6_">6. Hilfsprogramme</A></H2>
<P><H3><A HREF="#sect_6_1_">6.1. PLIST</A></H3>
<P><H3><A HREF="#sect_6_2_">6.2. BIND</A></H3>
<P><H3><A HREF="#sect_6_3_">6.3. P2HEX</A></H3>
<P><H3><A HREF="#sect_6_4_">6.4. P2BIN</A></H3>
<P><H3><A HREF="#sect_6_5_">6.5. AS2MSG</A></H3>
<P><H2><A HREF="#sect_A_">A. Fehlermeldungen von AS</A></H2>
<P><H2><A HREF="#sect_B_">B. E/A-Fehlermeldungen</A></H2>
<P><H2><A HREF="#sect_C_">C. H&auml;ufig gestellte Fragen</A></H2>
<P><H2><A HREF="#sect_D_">D. Pseudobefehle gesammelt</A></H2>
<P><H2><A HREF="#sect_E_">E. Vordefinierte Symbole</A></H2>
<P><H2><A HREF="#sect_F_">F. Mitgelieferte Includes</A></H2>
<P><H3><A HREF="#sect_F_1_">F.1. BITFUNCS.INC</A></H3>
<P><H3><A HREF="#sect_F_2_">F.2. CTYPE.INC</A></H3>
<P><H2><A HREF="#sect_G_">G. Danksagungen</A></H2>
<P><H2><A HREF="#sect_H_">H. &Auml;nderungen seit Version 1.3</A></H2>
<P><H2><A HREF="#sect_I_">I. Hinweise zum Quellcode von AS</A></H2>
<P><H3><A HREF="#sect_I_1_">I.1. Verwendete Sprache</A></H3>
<P><H3><A HREF="#sect_I_2_">I.2. Abfangen von Systemabh&auml;ngigkeiten</A></H3>
<P><H3><A HREF="#sect_I_3_">I.3. Systemunabh&auml;ngige Dateien</A></H3>
<P><H4><A HREF="#sect_I_3_1_">I.3.1. Von AS genutzte Module</A></H4>
<P><H4><A HREF="#sect_I_3_2_">I.3.2. Zus&auml;tzliche Module f&uuml;r die Hilfsprogramme</A></H4>
<P><H3><A HREF="#sect_I_4_">I.4. W&auml;hrend der Erzeugung von AS gebrauchte Module</A></H3>
<P><H3><A HREF="#sect_I_5_">I.5. Generierung der Nachrichtendateien</A></H3>
<P><H4><A HREF="#sect_I_5_1_">I.5.1. Format der Quelldateien</A></H4>
<P><H3><A HREF="#sect_I_6_">I.6. Dokumentationserzeugung</A></H3>
<P><H3><A HREF="#sect_I_7_">I.7. Testsuite</A></H3>
<P><H3><A HREF="#sect_I_8_">I.8. Einh&auml;ngen eines neuen Zielprozessors</A></H3>
<P><H3><A HREF="#sect_I_9_">I.9. Lokalisierung auf eine neue Sprache</A></H3>
<P><H1><A HREF="#sect_bib">Literaturverzeichnis
</A></H1>
<P><H1><A HREF="#sect_index">Index
</A></H1>
<P>

<H1><A NAME="sect_1_">1. Allgemeines</A></H1>
<P>
Diese Anleitung wendet sich an Leute, die bereits in Assembler
programmiert haben und sich dar&uuml;ber informieren m&ouml;chten,
wie man mit AS umgeht. Sie hat eher die Form eines Referenz- und
nicht Benutzerhandbuches. Als solches macht sie weder den Versuch,
die Sprache Assembler an sich zu erkl&auml;ren, noch erl&auml;utert
sie die Architektur bestimmter Prozessoren. Im Literaturverzeichnis
habe ich weiterf&uuml;hrende Literatur aufgelistet, die bei der
Implementation der einzelnen Codegeneratoren ma&szlig;gebend war. Um
Assembler von Grund auf zu lernen, kenne ich kein Buch; ich habe es
im wesentlichen im ,,Trial and error''-Verfahren gelernt.
<P>

<H2><A NAME="sect_1_1_">1.1. Lizenzbedingungen</A></H2>
<A NAME="ref_SectLicense"></A>
<P>
Bevor es in medias res geht, erst einmal der unvermeidliche Prolog:
<P>
AS in der vorliegenden Version untersteht der Gnu General Public
License (GPL); die Details dieser Lizenz k&ouml;nnen Sie in der
beiliegenden Datei COPYING nachlesen. Falls Sie diese nicht mit AS
erhalten haben, beschweren Sie sich bei demjenigen, von dem Sie AS
erhalten haben!
<P>
Kurz gesagt, beinhaltet die GPL folgende Punkte:
<UL>
<LI> Auf AS aufbauende Programme m&uuml;ssen ebenfalls der GPL
    unterstehen;</LI>
<LI> Weiterverbreitung ausdr&uuml;cklich erlaubt;</LI>
<LI> expliziter Haftungsausschlu&szlig; f&uuml;r durch die Anwendung
    dieses Programmes entstehende Sch&auml;den.</LI>
</UL>
...aber f&uuml;r die Details bitte ich wirklich, in den Originaltext
der GPL zu schauen!
<P>
Um eine m&ouml;glichst schnelle Fehlerdiagnose und -korrektur zu
erm&ouml;glichen, bitte ich, Fehlerberichten folgende Angaben
beizuf&uuml;gen:
<UL>
<LI> Hardware:
<UL>
<LI>     Prozessortyp (mit/ohne Koprozessor)</LI>
<LI>     Speicherausbau</LI>
<LI>     Grafikkarte</LI>
<LI>     Festplatte und Typ deren Interfaces</LI>
</UL>
 </LI>
<LI> Software:
<UL>
<LI>     Betriebssystem (MS/DR/Novell-DOS, OS/2, Windows) und
        Version</LI>
<LI>     installierte speicherresidente Programme</LI>
<LI>     benutzte Version von AS + Datum des EXE-Files</LI>
</UL>
 </LI>
<LI> m&ouml;glicht die Quelldatei, bei der der Fehler auftritt</LI>
</UL>
Zu erreichen bin ich folgenderma&szlig;en:
<UL>
<LI> per Post:
<DL COMPACT>
<DD>        Alfred Arnold</DD>
<DD>        Hirschgraben 29</DD>
<DD>        52062 Aachen</DD>
</DL>
 </LI>
<LI> per E-Mail:<TT> alfred@ccac.rwth-aachen.de</TT></LI>
</UL>
Wer mir pers&ouml;nlich Fragen stellen will (und in der N&auml;he von
Aachen wohnt), kann dies mit hoher Wahrscheinlichkeit donnerstags von
20.00 bis 21.00 Uhr im Computerclub an der RWTH Aachen
(Eilfschornsteinstra&szlig;e 16, Keller Philosophengeb&auml;ude
R&uuml;ckseite).
<P>
Von Telefonanrufen bitte ich abzusehen. Erstens, weil sich die
komplizierten Zusammenh&auml;nge am Telefon nur &auml;u&szlig;erst
schwer er&ouml;rten lassen, und zweitens ist die Telekom schon reich
genug...
<P>
Die neueste Version von AS (DOS, DPMI, OS/2, C) findet sich auf
folgendem Server:
<PRE>

 http://john.ccac.rwth-aachen.de:8000/as

</PRE>
oder auch kurz
<PRE>

 http://www.alfsembler.de

</PRE>
Die Quellen der C-Version k&ouml;nnen weiterhin von folgendem Server
geholt werden:
<PRE>

 sunsite.unc.edu
   Verzeichnis pub/Linux/devel/lang/assemblers/asl-&lt;version&gt;.tar.gz

</PRE>
...und damit nat&uuml;rlich von jedem Sunsite-Spiegel der Welt!
<P>
Wer &uuml;ber keinen FTP-Zugang verf&uuml;gt, kann den Assembler auch
von mir anfordern. Ich werde aber nur Anfragen beantworten, die einen
CD-Rohling und einen passenden, frankierten R&uuml;ckumschlag
enthalten.<B> KEIN</B> Geld schicken!!!
<P>
So. Nach diesem unvermeidlichen Vorwort k&ouml;nnen wir wohl beruhigt
zur eigentlichen Anleitung schreiten:
<P>

<H2><A NAME="sect_1_2_">1.2. allgemeine F&auml;higkeiten des Assemblers</A></H2>
<P>
AS bietet im Gegensatz zu normalen Assemblern die M&ouml;glichkeit,
Code f&uuml;r v&ouml;llig verschiedene Prozessoren zu erzeugen.
Momentan sind folgende Prozessorfamilien implementiert:
<UL>
<LI> Motorola 68000..68040,683xx inkl. Koprozessor und MMU</LI>
<LI> Motorola ColdFire</LI>
<LI> Motorola DSP5600x,DSP56300</LI>
<LI> Motorola/IBM MPC601/MPC505/PPC403</LI>
<LI> Motorola M-Core</LI>
<LI> Motorola 6800, 68(HC)11(K4) sowie Hitachi 6301</LI>
<LI> Motorola/Freescale 6805, 68HC(S)08</LI>
<LI> Motorola 6809 / Hitachi 6309</LI>
<LI> Motorola/Freescale 68HC12(X) inklusive XGATE</LI>
<LI> Freescale 68RS08</LI>
<LI> Motorola 68HC16</LI>
<LI> Hitachi H8/300(H)</LI>
<LI> Hitachi H8/500</LI>
<LI> Hitachi SH7000/7600/7700</LI>
<LI> Rockwell 6502 und 65(S)C02</LI>
<LI> CMD 65816</LI>
<LI> Mitsubishi MELPS-740</LI>
<LI> Mitsubishi MELPS-7700</LI>
<LI> Mitsubishi MELPS-4500</LI>
<LI> Mitsubishi M16</LI>
<LI> Mitsubishi M16C</LI>
<LI> Intel 4004/4040</LI>
<LI> Intel MCS-48/41</LI>
<LI> Intel MCS-51/251, Dallas DS80C390</LI>
<LI> Intel MCS-96/196(Nx)/296</LI>
<LI> Intel 8080/8085</LI>
<LI> Intel i960</LI>
<LI> Signetics 8X30x</LI>
<LI> Signetics 2650</LI>
<LI> Philips XA</LI>
<LI> Atmel (Mega-)AVR</LI>
<LI> AMD 29K</LI>
<LI> Siemens 80C166/167</LI>
<LI> Zilog Z80, Z180, Z380</LI>
<LI> Zilog Z8, eZ8</LI>
<LI> Xilinx KCPSM/KCPSM3 ('PicoBlaze')</LI>
<LI> LatticeMico8</LI>
<LI> Toshiba TLCS-900(L)</LI>
<LI> Toshiba TLCS-90</LI>
<LI> Toshiba TLCS-870</LI>
<LI> Toshiba TLCS-47</LI>
<LI> Toshiba TLCS-9000</LI>
<LI> Microchip PIC16C54..16C57</LI>
<LI> Microchip PIC16C84/PIC16C64</LI>
<LI> Microchip PIC17C42</LI>
<LI> SGS-Thomson ST6</LI>
<LI> SGS-Thomson ST7</LI>
<LI> SGS-Thomson ST9</LI>
<LI> SGS-Thomson 6804</LI>
<LI> Texas Instruments TMS32010/32015</LI>
<LI> Texas Instruments TMS3202x</LI>
<LI> Texas Instruments TMS320C3x</LI>
<LI> Texas Instruments TMS320C20x/TMS320C5x</LI>
<LI> Texas Instruments TMS320C54x</LI>
<LI> Texas Instruments TMS320C6x</LI>
<LI> Texas Instruments TMS9900</LI>
<LI> Texas Instruments TMS7000</LI>
<LI> Texas Instruments TMS370xxx</LI>
<LI> Texas Instruments MSP430</LI>
<LI> National Semiconductor SC/MP</LI>
<LI> National Semiconductor INS807x</LI>
<LI> National Semiconductor COP4</LI>
<LI> National Semiconductor COP8</LI>
<LI> National Semiconductor SC144xx</LI>
<LI> Fairchild ACE</LI>
<LI> NEC &micro;PD78(C)1x</LI>
<LI> NEC &micro;PD75xxx (alias 75K0)</LI>
<LI> NEC 78K0</LI>
<LI> NEC 78K2</LI>
<LI> NEC &micro;PD7720/7725</LI>
<LI> NEC &micro;PD77230</LI>
<LI> Fujitsu F&sup2;MC8L</LI>
<LI> Fujitsu F&sup2;MC16L</LI>
<LI> Symbios Logic SYM53C8xx (ja, die kann man programmieren!)</LI>
<LI> Intersil CDP1802/1805</LI>
</UL>
in Arbeit / Planung / &Uuml;berlegung :
<UL>
<LI> NEC 78K4</LI>
<LI> Intel 8008</LI>
<LI> Analog Devices ADSP21xx</LI>
<LI> SGS-Thomson ST20</LI>
<LI> Texas Instruments TMS320C4x</LI>
<LI> Texas Instruments TMS320C8x</LI>
<LI> Toshiba TC9331</LI>
</UL>
Noch gesucht werden Unterlagen f&uuml;r:
<UL>
<LI> die ganze Palette der OKI-Controller</LI>
</UL>
ungeliebt, aber<I> doch</I> vorhanden :
<UL>
<LI> Intel 8086, 80186, NEC V30&amp;V35 inkl. Koprozessor 8087</LI>
</UL>
Die Umschaltung des Codegenerators darf dabei auch mitten in der
Datei erfolgen, und das beliebig oft!
<P>
Der Grund f&uuml;r diese Flexibilit&auml;t ist, da&szlig; AS eine
Vorgeschichte hat, die auch in der Versionsnummer deutlich wird: AS
ist als Erweiterung eines Makroassemblers f&uuml;r die
68000er-Familie entstanden. Auf besonderen Wunsch habe ich den
urspr&uuml;nglichen Assembler um die F&auml;higkeit zur
&Uuml;bersetzung von 8051-Mnemonics erweitert, und auf dem Weg
(Abstieg?!) vom 68000 zum 8051 sind eine Reihe anderer fast nebenbei
abgefallen...die restlichen Prozessoren wurden allesamt auf
Benutzeranfrage hin integriert. Zumindest beim
prozessorunabh&auml;ngigen Kern kann man also getrost davon ausgehen,
da&szlig; er gut ausgetestet und von offensichtlichen Bugs frei ist.
Leider habe ich aber h&auml;ufig mangels passender Hardware nicht die
M&ouml;glichkeit, einen neuen Codegenerator praktisch zu testen, so
da&szlig; bei Neuerungen &Uuml;berraschungen nie ganz
auszuschlie&szlig;en sind. Das in Abschnitt <A
HREF="#ref_SectLicense">1.1</A> gesagte hat also schon seinen
Grund...
<P>
Diese Flexibilit&auml;t bedingt ein etwas exotisches Codeformat,
f&uuml;r dessen Bearbeitung ich einige Tools beigelegt habe. Deren
Beschreibung findet sich in Abschnitt <A HREF="#ref_ChapTools">6</A>.
<P>
AS ist ein Makroassembler, d.h. dem Programmierer ist die
M&ouml;glichkeit gegeben, sich mittels Makros neue ,,Befehle'' zu
definieren. Zus&auml;tzlich beherrscht er die bedingte Assemblierung.
Labels in Makror&uuml;mpfen werden automatisch als lokal betrachtet.
<P>
Symbole k&ouml;nnen f&uuml;r den Assembler sowohl Integer-, String-
als auch Gleitkommawerte haben. Diese werden --- wie Zwischergebnisse
bei Formeln --- mit einer Breite von 32 Bit f&uuml;r Integerwerte,
80/64 Bit f&uuml;r Gleitkommawerte und 255 Zeichen f&uuml;r Strings
gespeichert. F&uuml;r eine Reihe von Mikrokontrollern besteht die
M&ouml;glichkeit, durch Segmentbildung die Symbole bestimmten Klassen
zuzuordnen. Dem Assembler kann man auf diese Weise die --- begrenzte
--- M&ouml;glichkeit geben, Zugriffe in falsche Adre&szlig;r&auml;ume
zu erkennen.
<P>
Der Assembler kennt keine expliziten Beschr&auml;nkungen bzgl.
Verschachtelungstiefe von Includefiles oder Makros, eine Grenze
bildet lediglich die durch den Hauptspeicher beschr&auml;nkte
Rekursionstiefe. Ebenso gibt es keine Grenze f&uuml;r die
Symboll&auml;nge, diese wird nur durch die maximale Zeilenl&auml;nge
begrenzt.
<P>
Ab Version 1.38 ist AS ein Mehrpass-Assembler. Dieser hochtrabende
Begriff bedeutet nicht mehr, als das die Anzahl der Durchg&auml;nge
durch die Quelltexte nicht mehr zwei sein mu&szlig;. Sind keine
Vorw&auml;rtsreferenzen im Quellcode enthalten, so kommt AS mit einem
Durchgang aus. Stellt sich dagegen im zweiten Durchgang heraus,
da&szlig; ein Befehl mit einer k&uuml;rzeren oder l&auml;ngeren
Kodierung benutzt werden mu&szlig;, so wird ein dritter (vierter,
f&uuml;nfter...) Durchgang eingelegt, um alle Symbolreferenzen
richtig zu stellen. Mehr steckt hinter dem Begriff ,,Multipass''
nicht...er wird im weiteren Verlauf dieser Anleitung deswegen auch
nicht mehr auftauchen.
<P>
Nach soviel Lobhudelei ein dicker Wermutstropfen: AS erzeugt keinen
linkf&auml;higen Code. Eine Erweiterung um einen Linker w&auml;re mit
erheblichem Aufwand verbunden und ist momentan nicht in Planung.
<P>
Wer einen Blick in die Quellen von AS werfen will, besorge sich
einfach die Unix-Version von AS, die als Quelltext zum
Selber&uuml;bersetzen kommt. Die Quellen sind mit Sicherheit nicht in
einem Format, da&szlig; das Verst&auml;ndnis m&ouml;glichst leicht
macht - an vielen Stellen schaut noch der originale Pascal-Quellcode
heraus, und ich teile einige h&auml;ufig vertretene Ansichten
&uuml;ber 'guten' C-Stil nicht...
<P>

<H2><A NAME="sect_1_3_">1.3. Unterst&uuml;tzte Plattformen</A></H2>
<P>
Obwohl AS als ein reines DOS-Programm angefangen hat, stehen auch        
eine Reihe von Versionen zur Verf&uuml;gung, die etwas mehr als den
Real-Mode eines Intel-Prozessors ausnutzen k&ouml;nnen. Diese sind in
ihrer Benutzung soweit als m&ouml;glich kompatibel gehalten zur
DOS-Version, es ergeben sich nat&uuml;rlich bisweilen Unterschiede in
der Installation und der Einbindung in die jeweilige
Betriebssystemumgebung. Abschnitte in dieser Anleitung, die nur
f&uuml;r eine bestimmte Version von AS gelten, sind mit einer
entsprechenden Randbemerkung (an diesem Absatz f&uuml;r die
DOS-Version) gekennzeichnet. Im einzelnen existieren die folgenden,
weiteren Versionen (die als getrennte Pakete distributiert werden):
<P>
F&uuml;r den Fall, da&szlig; man bei der &Uuml;bersetzung                
gro&szlig;er, komplexer Programme unter DOS Speicherplatzprobleme
bekommt, existiert eine DOS-Version, die mittels eines DOS-Extenders
im Protected Mode abl&auml;uft und so das komplette Extended Memory
eines ATs nutzen kann. Die &Uuml;bersetzung wird durch den Extender
merklich langsamer, aber immerhin l&auml;uft es dann noch...
<P>
F&uuml;r Freunde von IBM's Betriebssystem OS/2 gibt es eine native       
OS/2-Version von AS. Seit 1.41r8 ist diese nur eine volle 32-bittige
OS/2-Anwendung, was nat&uuml;rlich zur Folge hat, da&szlig; OS/2 2.x
und ein 80386-Prozessor jetzt zwingend erforderlich sind.
<P>
Den reinen PC-Bereich verl&auml;&szlig;t man mit der C-Version von       
AS, die so gehalten wurde, da&szlig; sie auf einer m&ouml;glichst
gro&szlig;en Zahl von UNIX-artigen Systemen (dazu z&auml;hlt aber
auch OS/2 mit dem emx-Compiler) ohne gro&szlig;artige Verrenkungen
&uuml;bersetzbar ist. Im Gegensatz zu den vorherigen Versionen (die
auf den auf Anfrage erh&auml;ltlichen Pascal-Sourcen basieren) wird
die C-Version im Quellcode ausgeliefert, d.h. man mu&szlig; sich
mittels eines Compilers selbst die Binaries erzeugen. Dies ist aber
(f&uuml;r mich) der eindeutig einfachere Weg, als ein Dutzend
Binaries f&uuml;r Maschinen vorzukompilieren, auf die ich auch nicht
immer Zugriff habe...
<P>
Wer die bisherige Aufz&auml;hlung liest, wird feststellen, da&szlig;     
das meistverkaufte Betriebssystem der Welt aus Redmont in dieser
Aufz&auml;hlung fehlt. Wer mich pers&ouml;nlich kennt, wei&szlig;,
da&szlig; ich Windows (egal, ob 3.X, 95 oder NT)<EM> nicht</EM>
f&uuml;r das Ei des Kolumbus halte. Kurzgesagt, ich bin ein
,,Windows-Hasser''. Auch wenn eine gro&szlig;e Zahl an Leuten diese
Einstellung f&uuml;r &uuml;berholt bis l&auml;cherlich erachten und
mir jetzt vorhalten, ich w&uuml;rde hier einem gro&szlig;en Teil
potentieller Anwender AS vorenthalten, so werden sie sich doch damit
abfinden m&uuml;ssen: Ich treibe die Entwicklung an AS prim&auml;r
weiter, weil sie mir<EM> Spa&szlig;</EM> macht; AS ist ein
nicht-kommerzielles Projekt und ich nehme mir deswegen die Freiheit,
nicht auf potentielle Marktanteile zu schielen. Ich suche mir die
Plattformen aus, auf denen das Programmieren<EM> mir</EM> Spa&szlig;
macht, und Programmieren unter Windows macht mir definitiv keinen
Spa&szlig;! Ich habe &uuml;brigens durchaus schon einmal
Windows-Programme schreiben m&uuml;ssen, es ist also nicht so,
da&szlig; ich hier ohne Erfahrung etwas daherreden w&uuml;rde. Sofern
irgendjemand AS in diese Richtung portieren will, werde ich mich ihm
nicht in den Weg stellen, &uuml;ber die Sourcen hinaus hat er aber
nicht viel Hilfe von mir zu erwarten (und mu&szlig; sich selber mit
den Anfragen der Qualit&auml;t herumschlagen, warum AS denn jetzt
nicht mehr l&auml;uft, nachdem man den Brummi-CAD 18.53-Eintrag in
der Registry von Gro&szlig;- in Kleinbuchstaben ge&auml;ndert
hat...).
<P>

<H1><A NAME="sect_2_">2. Benutzung des Assemblers</A></H1>
<P>
<BLOCKQUOTE>
<DIV ALIGN=LEFT>
    <I> Scotty: Captain, we din' can reference it!<BR>
    Kirk: Analysis, Mr. Spock?<BR>
    Spock: Captain, it doesn't appear in the symbol table.<BR>
    Kirk: Then it's of external origin?<BR>
    Spock: Affirmative.<BR>
    Kirk: Mr. Sulu, go to pass two.<BR>
    Sulu: Aye aye, sir, going to pass two.<BR>
    </I>
</DIV>
</BLOCKQUOTE>
<P>

<H2><A NAME="sect_2_1_">2.1. Hardware-Anforderungen</A></H2>
<P>
Je nach Version von AS variieren die Hardware-Anforderungen deutlich:
<P>
Die DOS-Version l&auml;uft prinzipiell auf allen IBM-kompatiblen PCs,    
angefangen vom PC/XT mit vierkommawenig Megaherz bis hin zum Pentium.
Wie bei vielen anderen Programmen aber auch, steigt der Lustgewinn
mit der Hardware-Ausstattung. So d&uuml;rfte ein XT-Benutzer ohne
Festplatte erhebliche Probleme haben, die &uuml;ber 500 Kbyte
gro&szlig;e Overlay-Datei von AS auf einer Diskette
unterzubringen...eine Festplatte sollte der PC also schon haben,
allein um vern&uuml;nftige Ladezeiten zu erreichen. Im
Hauptspeicherbedarf ist AS recht gen&uuml;gsam: Das Programm selber
belegt knapp 300 Kbyte Hauptspeicher, AS sollte also ab einer
Hauptspeichergr&ouml;&szlig;e von 512 Kbyte ausf&uuml;hrbar sein.
<P>
Die Version von AS f&uuml;r das DOS-Protected-Mode-Interface (DPMI)      
ben&ouml;tigt zum Ablaufen mindestens einen 80286-Prozessor und 1
Mbyte freies extended memory. Daher stellen 2 Mbyte Hauptspeicher das
absolute Minimum dar, wenn man im XMS sonst keine anderen Spielereien
(Platten-Cache, RAM-Disk, hochgeladenes DOS) installiert hat, sonst
entsprechend mehr. Falls man die DPMI-Version in einer DOS-Box von
OS/2 laufen l&auml;&szlig;t, so sollte DPMI auch in den
DOS-Einstellungen der Box erlaubt sein (Einstellung<TT> An</TT>
oder<TT> Auto</TT>) und der Box eine entsprechende Menge von
XMS-Speicher zugeordnet sein. Die virtuelle Speicherverwaltung von
OS/2 sorgt hier &uuml;brigens daf&uuml;r, da&szlig; man sich keine
Gedanken machen mu&szlig;, ob der eingestellte Speicher auch real
verf&uuml;gbar ist.
<P>
Die Hardware-Anforderungen der OS/2-Version ergeben sich                 
weitestgehend durch die des darunterliegenden Betriebssytemes, d.h.
mindestens ein 80386SX-Prozessor, 8 Mbyte RAM (bzw. 4 ohne grafische
Benutzeroberfl&auml;che) sowie ca 100..150 Mbyte Platz auf der
Festplatte. Da AS2 nur eine 16-Bit-Applikation ist, sollte er
theoretisch auch auf &auml;lteren OS/2-Versionen (und damit
80286-Prozessoren) lauff&auml;hig sein; ausprobieren konnte ich dies
aber nicht.
<P>
Die C-Version von AS wird im Quellcode ausgeliefert und erfordert        
damit ein Unix- oder OS/2-System mit einem C-Compiler. Der Compiler
mu&szlig; dem ANSI-Standard gen&uuml;gen (GNU-C erf&uuml;llt diese
Bedingung zum Beispiel). Ob Ihr UNIX-System bereits getestet und die
n&ouml;tigen Definitionen vorgenommen wurden, k&ouml;nnen Sie der<TT>
README</TT>-Datei entnehmen. Als zur Kompilation ben&ouml;tigten
Plattenplatz sollten Sie ca. 15 Mbyte veranschlagen; dieser Wert (und
der nach der &Uuml;bersetzung noch ben&ouml;tigte Platz f&uuml;r die
&uuml;bersetzten Programme) variiert allerdings stark von System zu
System, so da&szlig; man diesen Wert nur als Richtschnur betrachten
sollte.
<P>

<H2><A NAME="sect_2_2_">2.2. Lieferumfang</A></H2>
<P>
Prinzipiell erh&auml;lt man AS in einer von zwei Formen: Als<EM>
Bin&auml;rdistribution</EM> oder<EM> Quellcodedistribution</EM>. Im
Falle einer Bin&auml;rdistribution bekommt man AS mit den
zugeh&ouml;rigen Dienstprogrammen und Hilfsdateien fertig
&uuml;bersetzt, so da&szlig; man nach dem Auspacken des Archivs an
die gew&uuml;nschte Stelle direkt loslegen kann.
Bin&auml;rdistributionen werden f&uuml;r verbreitete Plattformen
gemacht, bei denen die Mehrzahl der Benutzer keinen Compiler hat oder
die &Uuml;bersetzung trickreich ist (im Moment sind dies DOS und
OS/2). Eine Quellcodedistribution enth&auml;lt im Gegensatz den
kompletten Satz an C-Quellen, um AS zu generieren; es ist letzten
Endes ein Schnappschu&szlig; des Quellenbaumes, an dem ich AS
weiterentwickele. Die Generierung von AS aus dem Quellcode und dessen
Struktur ist n&auml;her in Anhang <A HREF="#ref_ChapSource">I</A>
beschrieben, weshalb an dieser Stelle nur auf den Umfang und die
Installation einer Bin&auml;rdistribution beschrieben wird:
<P>
Das Archiv des Lieferumfangs gliedert sich in einige
Unterverzeichnisse, so da&szlig; man nach dem Auspacken sofort einen
Verzeichnisbaum erh&auml;lt. Die Verzeichnisse enthalten im
einzelnen:
<UL>
<LI> <TT> BIN</TT>: ausf&uuml;hrbare Programme, Text-Resourcen;</LI>
<LI> <TT> INCLUDE</TT>: Include-Dateien f&uuml;r Assemblerprogramme, z.B.
    Registerdefinitionen oder Standardmakros;</LI>
<LI> <TT> MAN</TT>: Kurzreferenzen f&uuml;r die Programme im
    Unix-Man-Format;</LI>
<LI> <TT> DOC</TT>: diese Dokumentation in verschiedenen Formaten;</LI>
<LI> <TT> LIB</TT>: vorgesehen f&uuml;r Initialisierungsdateien.</LI>
</UL>
Eine Auflistung der Dateien, die in jeder Bin&auml;rdistribution
enthalten sind, findet sich in den Tabellen <A
HREF="#ref_TabCommonPackageList1">2.1</A> bis <A
HREF="#ref_TabCommonPackageList3">2.3</A>. Falls eine der in diesen
(oder den folgenden) Tabellen aufgef&uuml;hrten Dateien fehlt, hat
jemand (im Zweifelsfalle ich) beim Kopieren geschlafen...
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS.EXE<BR>
PLIST.EXE<BR>
PBIND.EXE<BR>
P2HEX.EXE<BR>
P2BIN.EXE<BR>
AS.MSG<BR>
PLIST.MSG<BR>
PBIND.MSG<BR>
P2HEX.MSG<BR>
P2BIN.MSG<BR>
TOOLS.MSG<BR>
CMDARG.MSG<BR>
IOERRS.MSG</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Programmdatei Assembler<BR>
listet Inhalt von Codedateien auf<BR>
kopiert Codedateien zusammen<BR>
wandelt Code- in Hexdateien um<BR>
wandelt Code- in Bin&auml;rdateien um<BR>
Textresourcen zu AS<BR>
Textresourcen zu PLIST<BR>
Textresourcen zu PBIND<BR>
Textresourcen zu P2HEX<BR>
Textresourcen zu P2BIN<BR>
gemeinsame Textresourcen zu den Tools<BR>
gemeinsame Textresourcen zu allen Programmen<BR>
</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis DOC</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS_DE.DOC<BR>
AS_DE.HTML<BR>
AS_DE.TEX<BR>
AS_EN.DOC<BR>
AS_EN.HTML<BR>
AS_EN.TEX</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>deutsche Dokumentation, ASCII-Format<BR>
deutsche Dokumentation, HTML-Format<BR>
deutsche Dokumentation, LaTeX-Format<BR>
englische Dokumentation, ASCII-Format<BR>
englische Dokumentation, HTML-Format<BR>
englische Dokumentation, LaTeX-Format</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis INCLUDE</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>BITFUNCS.INC<BR>
CTYPE.INC<BR>
<BR>
80C50X.INC<BR>
80C552.INC<BR>
H8_3048.INC<BR>
REG166.INC<BR>
REG251.INC<BR>
REG29K.INC<BR>
REG53X.INC<BR>
REG683XX.INC<BR>
REG7000.INC<BR>
REG78K0.INC<BR>
REG96.INC<BR>
REGACE.INC</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Funktionen zur Bitmanipulation<BR>
Funktionen zur Klassifizierung von<BR>
Zeichen<BR>
Registeradressen SAB C50x<BR>
Registeradressen 80C552<BR>
Registeradressen H8/3048<BR>
Adressen &amp; Befehlsmakros 80C166/167<BR>
Adressen &amp; Bits 80C251<BR>
Peripherieadressen AMD 2924x<BR>
Registeradressen H8/53x<BR>
Registeradressen 68332/68340/68360<BR>
Registeradressen TMS70Cxx<BR>
Registeradressen 78K0<BR>
Registeradressen MCS-96<BR>
Registeradressen ACE</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.1: Standardumfang einer Bin&auml;rdistribution - Teil 1<A
             NAME="ref_TabCommonPackageList1"></A>
</CENTER><P>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis INCLUDE</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>REGAVR.INC<BR>
REGCOP8.INC<BR>
REGGP32.INC<BR>
REGHC12.INC<BR>
REGM16C.INC<BR>
REGMSP.INC<BR>
REGST9.INC<BR>
REGZ380.INC<BR>
STDDEF04.INC<BR>
STDDEF16.INC<BR>
<BR>
STDDEF17.INC<BR>
STDDEF18.INC<BR>
STDDEF2X.INC<BR>
STDDEF37.INC<BR>
STDDEF3X.INC<BR>
STDDEF47.INC<BR>
STDDEF51.INC<BR>
<BR>
STDDEF56K.INC<BR>
STDDEF5X.INC<BR>
STDDEF60.INC<BR>
<BR>
STDDEF62.INC<BR>
STDDEF75.INC<BR>
STDDEF87.INC<BR>
STDDEF90.INC<BR>
STDDEF96.INC<BR>
STDDEFXA.INC<BR>
STDDEFZ8.INC</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Register- &amp; Bitadressen AVR-Familie<BR>
Registeradressen COP8<BR>
Registeradressen 68HC908GP32<BR>
Registeradressen 68HC12<BR>
Registeradressen Mitsubishi M16C<BR>
Registeradressen TI MSP430<BR>
Register- &amp; Makrodefinitionen ST9<BR>
Registeradressen Z380<BR>
Registeradressen 6804<BR>
Befehlsmakros und Registeradressen<BR>
PIC16C5x<BR>
Registeradressen PIC17C4x<BR>
Registeradressen PIC16C8x<BR>
Registeradressen TMS3202x<BR>
Register- &amp; Bitadressen TMS370xxx<BR>
Peripherieadressen TMS320C3x<BR>
Befehlsmakros TLCS-47<BR>
Definition von SFRs und Bits f&uuml;r<BR>
8051/8052/80515<BR>
Registeradressen DSP56000<BR>
Peripherieadressen TMS320C5x<BR>
Befehlsmakros &amp; Registeradressen<BR>
PowerPC<BR>
Registeradressen &amp; Makros ST6<BR>
Registeradressen 75K0<BR>
Register- &amp; Speicheradressen TLCS-870<BR>
Register- &amp; Speicheradressen TLCS-90<BR>
Register- &amp; Speicheradressen TLCS-900<BR>
SFR-&amp; Bitadressen Philips XA<BR>
Registeradressen Z8-Familie</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis LIB</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.2: Standardumfang einer Bin&auml;rdistribution - Teil 2<A
             NAME="ref_TabCommonPackageList2"></A>
</CENTER><P>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis MAN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ASL.1<BR>
PLIST.1<BR>
PBIND.1<BR>
P2HEX.1<BR>
P2BIN.1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Kurzanleitung zu AS<BR>
Kurzanleitung zu PLIST<BR>
Kurzanleitung zu PBIND<BR>
Kurzanleitung zu P2HEX<BR>
Kurzanleitung zu P2BIN</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.3: Standardumfang einer Bin&auml;rdistribution - Teil 3<A
             NAME="ref_TabCommonPackageList3"></A>
</CENTER><P>

<P>
Je nach Plattform kann eine Bin&auml;rdistribution aber noch weitere
Dateien enthalten, um einen Betrieb zu erm&ouml;glichen, wie es z.B.
bei DOS-Extendern der Fall ist. F&uuml;r die DOS-DPMI-Version ergeben    
sich die in Tabelle <A HREF="#ref_TabDPMIPackageList">2.4</A>
gelisteten Erg&auml;nzungen. Es spricht &uuml;brigens nichts dagegen,
als Hilfsprogramme die Versionen aus einer DOS-Distribution zu
verwenden, da diese einerseits ohne den Extender-Overhead deutlich
schneller ablaufen und andererseits den vom Extender bereitgestellten
erweiterten Speicher nicht ben&ouml;tigen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DPMI16BI.OVL<BR>
RTM.EXE</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DPMI-Server f&uuml;r den Assembler<BR>
Laufzeit-Modul des Extenders</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.4: Zus&auml;tzliche Dateien in einer
             DPMI-Bin&auml;rdistribution<A
             NAME="ref_TabDPMIPackageList"></A>
</CENTER><P>

<P>
Eine OS/2-Bin&auml;rdistribution enth&auml;lt neben den Basisdateien     
eine Reihe von DLLs, die zur Laufzeitumgebung des verwendeten
emx-Compilers geh&ouml;ren (Tabelle <A
HREF="#ref_TabOS2PackageList">2.5</A>). Falls man diese DLLs (oder
neuere Versionen davon) bereits besitzt, kann man diese auch wieder
l&ouml;schen und seine eigenen benutzen.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datei</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><B> Verzeichnis BIN</B></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>EMX.DLL<BR>
EMXIO.DLL<BR>
EMXLIBC.DLL<BR>
EMXWRAP.DLL</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Laufzeitbibliotheken f&uuml;r AS und<BR>
die Dienstprogramme<BR>
<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.5: Zus&auml;tzliche Dateien in einer
             OS/2-Bin&auml;rdistribution<A
             NAME="ref_TabOS2PackageList"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_2_3_">2.3. Installation</A></H2>
<P>
Eine besondere Installation ist f&uuml;r die Nutzung einer               
Bin&auml;rdistribution nicht notwendig, es gen&uuml;gt, das Archiv an
passender Stelle auszupacken und dann noch einige Kleinigkeiten zu
erg&auml;nzen. Als Beispiel hier eine Installation, wie sie
vielleicht ein UNIX-Anh&auml;nger vornehmen w&uuml;rde:
<P>
Legen Sie ein Verzeichnis c:\as an (im folgenden nehme ich an,
da&szlig; Sie AS auf Laufwerk C installieren wollen), wechseln Sie in
dieses und entpacken Sie das Archiv unter Erhalt der Verzeichnisnamen
(bei Verwendung von PKUNZIP ist dazu die Kommandozeilenoption -d
erforderlich). Sie sollten jetzt folgenden Verzeichnisbaum haben:
<PRE>

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\man
c:\as\doc

</PRE>
Erg&auml;nzen Sie jetzt die<TT> PATH</TT>-Anweisung in Ihrer<TT>
AUTOEXEC.BAT</TT> um das Verzeichnis c:\as\bin, so da&szlig; AS und
seine Hilfsprogramme vom System gefunden werden. In dem<TT>
lib</TT>-Verzeichnis erzeugen Sie mit einem beliebigen Texteditor
eine Datei<TT> AS.RC</TT> mit folgendem Inhalt:
<PRE>

-i c:\as\include

</PRE>
Diese sogenannte<EM> Key-Datei</EM> zeigt AS, in welchem Verzeichnis
er seine Include-Dateien suchen soll. Damit AS diese Key-Datei bei
Start auch beachtet, mu&szlig; noch folgende Anweisung in die<TT>
AUTOEXEC.BAT</TT>:
<PRE>

set ASCMD=@c:\as\lib\as.rc

</PRE>
Was Sie alles noch in der Key-Datei voreinstellen k&ouml;nnen, steht
im folgenden Abschnitt.
<P>
Die Installation der DPMI-Version sollte im Prinzip genauso verlaufen    
wie der reinen DOS-Version; wenn der Pfad das<TT>
bin</TT>-Verzeichnis enth&auml;lt, werden die Dateien des
DOS-Extenders automatisch gefunden und man sollte von dieser Mimik
(mit Ausnahme der l&auml;ngeren Anlaufzeit...) nichts mitbekommen.
Theoretisch ist es m&ouml;glich, da&szlig; Sie auf 80286-Rechnern
beim ersten Start mit einer Meldung der folgenden Form konfrontiert
werden:
<PRE>

  machine not in database (run DPMIINST)

</PRE>
Da das Tool DPMIINST bei neueren Versionen des DOS-Extenders von
Borland aber nicht mehr dabei ist, nehme ich einmal an, da&szlig;
diese Sache sich erledigt hat...falls doch nicht, bitte ich um
R&uuml;ckmeldung!
<P>
Die Installation der OS/2-Version kann in weiten Z&uuml;gen genauso      
ablaufen wie f&uuml;r die DOS-Version, nur da&szlig; dem System noch
die DLLs bwkannt gemacht werden m&uuml;ssen. Wenn Sie den<TT>
LIBPATH</TT>-Eintrag in Ihrer<TT> CONFIG.SYS</TT> nicht erweitern
wollen, ist es nat&uuml;rlich auch m&ouml;glich, die DLLs in ein
Verzeichnis zu verschieben, das bereits dort aufgef&uuml;hrt ist.
<P>
Wie bereits erw&auml;hnt, beschr&auml;nkt sich die
Installationsbeschreibung hier nur auf Bin&auml;rdistributionen. Da
eine Installation unter Unix im Augenblick immer eine                    
Quellcodedistribution ist, geht der Verweis hier unisono in Anhang <A
HREF="#ref_ChapSource">I</A>.
<P>

<H2><A NAME="sect_2_4_">2.4. Aufruf, Parameter</A></H2>
<A NAME="ref_SectCallConvention"></A>
<P>
AS ist ein kommandozeilengesteuertes Programm, d.h. alle Parameter
und Dateiangaben sind in der Kommandozeile anzugeben.
<P>
Zu AS geh&ouml;rt eine Reihe Reihe von Nachrichtendateien (erkennbar
an der Endung<TT> MSG</TT>, aus denen AS zur Laufzeit die f&uuml;r
die jeweilige Landessprache dynamisch nachl&auml;dt. AS sucht nach
diesen Dateien in den folgenden Verzeichnissen:
<UL>
<LI> im aktuellen Verzeichnis;</LI>
<LI> im Verzeichnis der EXE-Datei;</LI>
<LI> in dem in der Environment-Variablen<TT> AS_MSGPATH</TT> angegebenen
    Verzeichnis, oder alternativ in den in der<TT>
    PATH</TT>-Variablen gelisteten Verzeichnissen;</LI>
<LI> In dem Verzeichnis, das AS zur Kompilationszeit durch das Makro<TT>
    LIBDIR</TT> mitgegeben wurde.</LI>
</UL>
Diese Dateien werden von AS<EM> zwingend</EM> zum Betrieb
ben&ouml;tigt, d.h. findet AS diese Dateien nicht, bricht er an
dieser Stelle sofort ab.
<P>
Die Auswahl der Sprache (momentan Deutsch oder Englisch) orientiert
sich unter DOS und OS/2 an der<TT> COUNTRY</TT>-Einstellung in
der<TT> CONFIG.SYS</TT>, unter Unix an der<TT>
LANG</TT>-Environment-Variablen.
<P>
Um den Speicherbedarf von AS unter DOS &uuml;berhaupt befriedigen zu     
k&ouml;nnen, wurden die verschiedenen Codegeneratormodule in der
DOS-Version in einen Overlay verlegt, der Teil des EXE-Files ist.
Eine getrennte OVR-Datei wie bei fr&uuml;heren Versionen von AS
existiert also nicht mehr, AS versucht aber wie bisher auch
weiterhin, die durch das Overlaying entstehenden Verz&ouml;gerungen
durch Nutzung von eventuellem EMS- oder XMS-Speicher zu reduzieren.
Sollte diese Verwendung zu Problemen f&uuml;hren, so k&ouml;nnen Sie
die Verwendung von EMS bzw. XMS unterbinden, indem Sie einer
Environment-Variablen<TT> USEXMS</TT> bzw.<TT> USEEMS</TT> den
Wert<TT> n</TT> zuweisen. So kann man z.B. mit dem Befehl
<PRE>

   SET USEXMS=n

</PRE>
die Verwendung von extended memory verhindern.
<P>
Da AS alle Ein-und Ausgaben &uuml;ber das Betriebssystem abwickelt
(und daher unter DOS auch auf nicht ganz so kompatiblen PC's laufen
sollte) und eine rudiment&auml;re Bildschirmsteuerung ben&ouml;tigt,
gibt er w&auml;hrend der Assemblierung ANSI-Steuersequenzen aus.
Falls Sie in den Ausgaben von AS also seltsame Zeichen sehen sollten,    
fehlt offensichtlich in Ihrer CONFIG.SYS die Einbindung des
ANSI-Treibers (<TT>device=ansi.sys</TT>), die weitere Funktion von AS    
wird dadurch aber nicht beeinflu&szlig;t. Alternativ k&ouml;nnen Sie
aber auch die Ausgabe von ANSI-Sequenzen durch das Setzen der
Environment-Variablen<TT> USEANSI</TT> auf<TT> n</TT> ganz
unterdr&uuml;cken.
<P>
Der DOS-Extender der DPMI-Version l&auml;&szlig;t sich in seiner         
Speicherbelegung durch diverse Kommandozeilenoptionen beeinflussen.
Diese k&ouml;nnen Sie bei Bedarf der Datei DPMIUSER.DOC entnehmen.
Zus&auml;tzlich ist ASX in der Lage, bei Bedarf den vorhandenen
Speicher durch eine Swap-Datei zu ,,erweitern''. Dazu belegt man eine
Environment-Variable<TT> ASXSWAP</TT> folgenderma&szlig;en:
<BLOCKQUOTE>
    <TT> SET ASXSWAP=&lt;Gr&ouml;&szlig;e&gt;[,Dateiname]</TT>
</BLOCKQUOTE>
Die Gr&ouml;&szlig;enangabe erfolgt in Megabytes und<B> mu&szlig;</B>
gemacht werden. Der Name der Datei ist dagegen optional; fehlt er, so
wird die Swap-Datei im aktuellen Verzeichnis unter dem Namen<TT>
ASX.TMP</TT> angelegt. In jedem Falle wird die Swap-Datei nach
Programmende wieder gel&ouml;scht.
<P>
Die Kommandozeilenparameter k&ouml;nnen grob in drei Klassen
eingeteilt werden: Schalter, Key-File-Referenzen (s.u.) und
Dateispezifikationen. Parameter dieser beiden Klassen k&ouml;nnen
beliebig gemischt in der Kommandozeile auftreten, AS wertet zuerst
alle Parameter aus und assembliert dann die angegebenen Dateien.
Daraus folgen zwei Dinge:
<UL>
<LI> Die angegebenen Schalter wirken auf alle angegebenen Quelldateien.
    Sollen mehrere Quelldateien mit unterschiedlich gesetzten
    Schaltern assembliert werden, so mu&szlig; dies in getrennten
    L&auml;ufen erfolgen.</LI>
<LI> Es k&ouml;nnen in einem Durchgang mehrere Dateien assembliert
    werden. Um der Sache die Krone aufzusetzen, d&uuml;rfen die
    Dateiangaben Jokerzeichen enthalten.</LI>
</UL>
Schalterparameter erkennt AS daran, da&szlig; sie durch einen
Schr&auml;gstrich (/) oder Bindestrich (-) eingeleitet werden. Es
gibt dabei sowohl Schalter, die nur aus einem Buchstaben bestehen,
als auch Schalter, die aus einem ganzen Wort bestehen. Immer wenn AS
einen Schalter nicht als ,,Wort-Schalter'' verstehen kann, so
versucht er, die Buchstaben des Wortes als einzelne Schalter zu
interpretieren. Wenn man also z.B.
<PRE>

 -queit

</PRE>
anstelle von
<PRE>

 -quiet

</PRE>
geschrieben h&auml;tte, w&uuml;rde AS die Buchstaben<TT> q, u, e,
i</TT> und<TT> t</TT> als einzelne Schalter auffassen.
Mehrbuchstabige Schalter unterscheiden sich weiterhin von
einbuchstabigen dadurch, da&szlig; AS bei ihnen beliebige
Gro&szlig;-und Kleinschreibungen akzeptiert, w&auml;hrend
einbuchstabige Schalter je nach Gro&szlig;- oder Kleinschreibung
unterschiedliche Bedeutung haben.
<P>
Momentan sind folgende Schalter definiert:<A
NAME="index_SHARED_1"></A>
<UL>
<LI> <TT>l</TT>: Assemblerlisting auf Konsole ausgeben. Falls mehrere
    Passes ausgef&uuml;hrt werden m&uuml;ssen, landen im Gegensatz
    zur n&auml;chsten Option die Listings aller Durchg&auml;nge auf
    der Ausgabe!</LI>
<LI> <TT>L</TT>: Assemblerlisting auf Datei schreiben. Die Listdatei
    erh&auml;lt dabei den gleichen Namen wie die Quelldatei,
    lediglich die Endung wird durch<TT> LST</TT> ersetzt, es sei
    denn...</LI>
<LI> <TT>OLIST</TT>: mit einem zus&auml;tzlichen Argument legt einen
    anderen Pfad bzw. Namen f&uuml;r die Listdatei fest. Falls
    mehrere Dateien assembliert werden, kann diese Option auch
    mehrfach gegeben werden.</LI>
<LI> <TT>o</TT>:Bestimmt einen neuen Namen f&uuml;r die von AS zu
    erzeugende Code-Datei. Wird diese Option mehrfach verwendet, so
    werden die angegebenen Namen nacheinander den zu assemblierenden
    Quelldateien zugeordnet; Negation (s.u.) dieser Option in
    Verbindung mit einem Namen l&ouml;scht den Namen aus der Liste;
    Negation ohne Namensangabe l&ouml;scht die komplette Liste.</LI>
<LI> <TT>SHAREOUT</TT>:dito, nur f&uuml;r eine eventuell zu erzeugende
    SHARE-Datei</LI>
<LI> <TT>c</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in eine C-Quelldatei erlaubt. Die Endung der Datei
    ist<TT> H</TT>.</LI>
<LI> <TT>p</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in den<TT> CONST</TT>-Block eines Pascal- oder
    Modula-Programmes erlaubt. Die Endung der Datei ist<TT>
    INC</TT>.</LI>
<LI> <TT>a</TT>: SHARED-Variablen werden in einem Format abgelegt, das
    die Einbindung in eine Assembler-Quelldatei erlaubt. Die Endung
    der Datei ist<TT> INC</TT>.</LI>
</UL>
Zu Sinn und Funktion der SHARED-Symbole siehe Kapitel <A
HREF="#ref_ChapShareMain">2.12</A> bzw. <A
HREF="#ref_ChapShareOrder">3.9.1</A>.
<UL>
<LI> <TT>g [Format]</TT>: Mit diesem Schalter erzeugt AS zus&auml;tzlich
    eine Datei, die Debug-Informationen f&uuml;r dieses Programm
    enth&auml;lt. Als Format ist dabei entweder ein AS-eigenes Format
    (<TT> Format=MAP</TT>), eine NoICE-kompatible Kommandodatei (<TT>
    Format=NOICE</TT>) oder das Format der AVR-Tools (<TT>
    Format=ATMEL</TT>) erlaubt. Zu den im MAP-Format gespeicherten
    Informationen geh&ouml;rt zum einen die Symboltabelle, zum
    anderen eine Zuordnung von Quellzeilen zu Maschinenadressen. Eine
    genauere Beschreibung des benutzten MAP-Dateiformates findet sich
    in Abschnitt <A HREF="#ref_SectDebugFormat">5.2</A>. Die Endung
    der Datei ist<TT> MAP</TT>,<TT> NOI</TT> bzw.<TT> OBJ</TT>, je
    nach gew&auml;hltem Format. Wird keine explizite Formatangabe
    gemacht, wird das MAP-Format gew&auml;hlt.</LI>
<LI> <TT>noicemask [Wert]</TT>: Normalerweise listet AS in
    NoICE-Debuginfos nur Symbole aus dem CODE-Segment. Mit dieser
    Option und einem als Bitmaske zu verstehenden Wert lassen sich
    andere Symbole aus anderen Segmenten zuschalten. Die Zuordnung
    von Bits zu Segmenten kann Tabelle <A
    HREF="#ref_TabSegmentNums">5.3</A> entnommen werden.</LI>
<LI> <TT>w</TT>: Ausgabe von Warnungen unterdr&uuml;cken;</LI>
<LI> <TT>E [Datei]</TT>: Die von AS erzeugten Fehlermeldungen und
    Warnungen in eine Datei umleiten. Anstatt einer Datei k&ouml;nnen
    auch die 5 Standardhandles (STDIN..STDPRN) als !0 bis !4
    angegeben werden. Default ist !2, also STDERR. Wird die
    Dateiangabe weggelassen, so ist der Name der Fehlerdatei gleich
    dem der Quelldatei, nur mit der Endung<TT> LOG</TT>.</LI>
<LI> <TT>q</TT>: Dieser Schalter unterdr&uuml;ckt alle Meldungen von AS
    mit Ausnahme von Fehlermeldungen und vom Programm selber
    erzeugten Ausgaben. Die Assemblierzeit kann dadurch
    geringf&uuml;gig reduziert werden, und beim Aufruf aus einer
    Shell heraus kann man sich eine Umleitung ersparen. Der Nachteil
    ist, da&szlig; man u.U. einige Minuten ,,im Dunklen'' steht...
    Anstelle von 'q' darf auch 'quiet' geschrieben werden.</LI>
<LI> <TT>h</TT>: Hexadezimalzahlen mit Klein- anstelle von
    Gro&szlig;buchstaben ausgeben. Diese Option ist in erster Linie
    eine Frage des pers&ouml;nlichen Geschmacks.</LI>
<LI> <TT>i &lt;Pfadliste&gt;</TT>: gibt eine Liste von Verzeichnissen an,
    in denen der Assembler automatisch nach Include-Dateien suchen
    soll, falls er diese nicht im aktuellen Verzeichnis findet. Die
    einzelnen Verzeichnisse m&uuml;ssen durch Semikolons getrennt
    werden.</LI>
<LI> <TT>u</TT>: eine Liste der in den Segmenten belegten Bereiche
    berechnen. Sie ist nur sinnvoll, falls ein Listing erzeugt wird.
    Diese Option ben&ouml;tigt erhebliche zus&auml;tzliche Speicher-
    und Rechenleistung, im Normalbetrieb sollte sie daher
    abgeschaltet sein. Da AS aber unabh&auml;ngig vom eingeschalteten
    Listing mit dieser Option auf &uuml;berlappende Speicherbelegung
    pr&uuml;ft, hat sie auch unabh&auml;ngig vom Listing einen
    gewissen Sinn...</LI>
<LI> <TT>C</TT>: erzeugt eine Liste mit Querverweisen. Aufgelistet wird,
    welche (globalen) Symbole in welchen Dateien in welchen Zeilen
    benutzt werden. Auch diese Liste wird nur generiert, falls ein
    Listing erzeugt wird und belegt w&auml;hrend der Assemblierung
    zus&auml;tzlichen Speicherplatz.</LI>
<LI> <TT>s</TT>: eine Liste aller Sektionen (s. Abschnitt <A
    HREF="#ref_ChapLocSyms">3.8</A>) ausgeben. Die Verschachtelung
    wird dabei durch Einr&uuml;ckungen angedeutet.</LI>
<LI> <TT>I</TT>: Analog zur Sektionsliste eine Liste aller bearbeiteten
    Include-Dateien ausgeben.</LI>
<LI> <TT>t &lt;Maske&gt;</TT>: Mit diesem Schalter lassen sich einzelne
    Komponenten des standardm&auml;&szlig;ig ausgegebenen
    Assemblerlistings ein-und ausblenden. Welcher Teil dabei welchem
    Bit zugeordnet ist, ist im &uuml;bern&auml;chsten Abschnitt, der
    genauer auf das Format des Assemblerlistings eingeht, nachgelesen
    werden.</LI>
<LI> <TT>D &lt;Symbolliste&gt;</TT>: Symbole definieren. Die hinter
    dieser Option angegebenen, durch Kommas getrennten Symbole werden
    in der globalen Symboltabelle vor Beginn der Assemblierung
    abgelegt. Defaultm&auml;&szlig;ig werden diese Symbole als ganze
    Zahlen mit dem Wert TRUE abgelegt, mit einem nachgestellten
    Gleichheitszeichen kann aber auch eine andere Belegung
    gew&auml;hlt werden. Der dem Gleichheitszeichen folgende Ausdruck
    darf dabei auch Operatoren oder interne Funktionen beinhalten,
    jedoch<B> KEINE</B> anderen Symbole, selbst wenn diese schon
    davor in der Liste definiert sein sollten! Zusammen mit den
    Befehlen zur bedingten Assemblierung (siehe dort) k&ouml;nnen so
    per Kommandozeile aus einer Quelldatei unterschiedliche
    Programmversionen erzeugt werden.<B> ACHTUNG!</B> Wenn
    case-sensitiv gearbeitet werden soll, mu&szlig; dies in der
    Kommandozeile<EM> vor</EM> Symboldefinitionen angegeben werden,
    sonst werden Symbolnamen schon an dieser Stelle in
    Gro&szlig;buchstaben umgewandelt!</LI>
<LI> <TT>A</TT>: Die Liste globaler Symbole in einer anderen, kompakteren
    Form ablegen. Verwenden Sie diese Option, wenn der Assembler bei
    langen Symboltabellen mit einem Stapel&uuml;berlauf
    abst&uuml;rzt. Eventuell kann diese Option die
    Arbeitsgeschwindigkeit des Assemblers erh&ouml;hen, dies
    h&auml;ngt jedoch von den Quellen ab.</LI>
<LI> <TT>x</TT>: Legt die Ausf&uuml;hrlichkeitsstufe von Fehlermeldungen
    fest. Jedesmal, wenn diese Option angegeben wird, wird die Stufe
    um eins erh&ouml;ht oder gesenkt. W&auml;hrend auf Stufe 0
    (Vorgabe) nur der Fehler selber ausgegeben wird, wird ab Stufe 1
    noch eine erweiterte Meldung ausgegeben, anhand der die
    Identifizierung des Fehlers erleichtert werden soll. Welche
    Fehlermeldungen welche Zusatzinformationen tragen k&ouml;nnen,
    steht in Anhang <A HREF="#ref_ChapErrMess">A</A> mit der Liste
    aller Fehlermeldungen. Auf Stufe 2 (Maximum) wird zus&auml;tzlich
    noch die betroffene Quellzeile mit ausgegeben.</LI>
<LI> <TT>n</TT>: Wird diese Option angegeben, so werden Fehlermeldungen
    nicht nur mit ihrem Klartext, sondern auch mit ihren im Anhang <A
    HREF="#ref_ChapErrMess">A</A> genannten internen Nummern
    ausgegeben. Diese Option ist prim&auml;r f&uuml;r Shells und
    Entwicklungsumgebungen gedacht, denen mit diesen Nummern die
    Identifizierung von Fehlern erleichtert werden soll.</LI>
<LI> <TT>U</TT>: Mit dieser Option schaltet man AS in den case-sensitiven
    Modus um, d.h. in Namen von Symbolen, Sektionen, Makros,
    Zeichentabellen und selbstdefinierte Funktionen werden Klein- und
    Gro&szlig;buchstaben unterschieden, was normalerweise nicht der
    Fall ist.</LI>
<LI> <TT>P</TT>: weist AS an, den von Makroprozessor und bedingter
    Assemblierung bearbeiteten Quelltext in einer Datei abzulegen.
    Dieser Datei fehlen zus&auml;tzlich Leer- und reine
    Kommentarzeilen. Die Endung der Datei ist<TT> I</TT>.</LI>
<LI> <TT>M</TT>: mit diesem Schalter erzeugt AS eine Datei, in der die
    Definitionen der Makros aus der Quelldatei abgespeichert werden,
    die die<TT> EXPORT</TT>-Option verwenden. Diese neue Datei hat
    den gleichen Namen wie die Quelldatei, lediglich die Endung wird
    in<TT> MAC</TT> ge&auml;ndert.</LI>
<LI> <TT>G</TT>: Dieser Schalter bestimmt, ob AS Code erzeugen soll oder
    nicht. Ist er ausgeschaltet, wird die Datei zwar assembliert,
    aber keine Code-Datei geschrieben. Dieser Schalter ist
    defaultm&auml;&szlig;ig aktiviert (logisch, sonst bek&auml;me man
    ja auch gar kein Codefile).</LI>
<LI> <TT>r [n]</TT>: Warnungen ausgeben, falls Situationen eintreten, die
    einen weiteren Pass erfordern. Diese Information kann genutzt
    werden, um die Anzahl der Durchl&auml;ufe zu verringern. Optional
    kann man die Nummer des Passes angeben, ab dem diese Warnungen
    erzeugt werden; ohne Angabe kommen die Warnungen ab dem ersten
    Pass. Machen Sie sich aber so oder so auf einen ziemlichen Haufen
    an Meldungen gefa&szlig;t!!</LI>
<LI> <TT>Y</TT>: Mit diesem Schalter weist man AS an, alle
    Fehlermeldungen wegen zu langer Sprungdistanzen zu verwerfen,
    sobald die Notwendigkeit eines neuen Durchlaufs feststeht. In
    welchen (seltenen) Situationen dieser Schalter notwendig ist,
    kann man in Abschnitt <A HREF="#ref_ForwRefs">2.10</A>
    nachlesen.</LI>
<LI> <TT>cpu &lt;Name: &gt;</TT>: Hiermit kann man man den Zielprozessor
    vorgeben, f&uuml;r den AS Code erzeugen soll, wenn die Quelldatei
    keinen<TT> CPU</TT>-Befehl enth&auml;lt und es sich nicht um
    68008-Code handelt.</LI>
<LI> <TT>alias &lt;neu&gt;=&lt;alt&gt;</TT>:<BR>
    definiert den Prozessortyp<TT> &lt;neu&gt;</TT> als einen Alias
    f&uuml;r den Typen<TT> &lt;alt&gt;</TT>. Zu den Sinn und Zweck
    von Aliassen siehe Abschnitt <A
    HREF="#ref_SectAlias">2.13</A></LI>
<LI> <TT> gnuerrors</TT>: Meldungen &uuml;ber Fehler bzw. Warnungen und
    deren Position nicht im Standardformat von AS, sondern in einem
    dem GNU C-Compiler entlehnten Format anzeigen. Dies erleichtert
    die Integration von AS in f&uuml;r dieses Format ausgelegte
    Umgebungen, unterdr&uuml;ckt aber gleichzeitig die Anzeige der
    pr&auml;zisen Fehlerposition innerhalb Makror&uuml;mpfen!</LI>
</UL>
Sofern Schalter keine Argumente ben&ouml;tigen und ihre
Zusammenziehung keinen mehrbuchstabigen Schalter ergibt, k&ouml;nnen
mehrere Schalter auch auf einen Rutsch angegeben werden, wie z.B im
folgenden Beispiel:
<PRE>

 as test*.asm firstprog -cl /i c:\as\8051\include

</PRE>
Es werden alle Dateien TEST*.ASM sowie die Datei FIRSTPROG.ASM
assembliert, wobei f&uuml;r alle Dateien Listings auf der Konsole
ausgegeben und Sharefiles im C-Format erzeugt werden. Nach Includes
soll der Assembler zus&auml;tzlich im Verzeichnis  C:\AS\8051\INCLUDE
suchen.
<P>
Dieses Beispiel zeigt nebenbei, da&szlig; AS als Defaultendung
f&uuml;r Quelldateien<TT> ASM</TT> annimmt.
<P>
Etwas Vorsicht ist bei Schaltern angebracht, die ein optionales
Argument haben: Folgt auf einen solchen Schalter ohne Argument ein
Dateiname, so versucht AS, diesen als Argument zu verwerten, was
naturgem&auml;&szlig; schief geht:
<PRE>

 as -g test.asm

</PRE>
Die L&ouml;sung w&auml;re in diesem Fall, die<TT> -g</TT>-Option ans
Ende der Kommandozeile zu setzen oder ein explizites<TT>
MAP</TT>-Argument zu spezifizieren.
<P>
Neben der Angabe in der Kommandozeile k&ouml;nnen dauernd
ben&ouml;tigte Optionen in der Environment-Variablen ASCMD abgelegt
werden. Wer z.B. immer Listdateien haben m&ouml;chte und ein festes
Includeverzeichnis hat, kann sich mit dem Befehl
<PRE>

 set ASCMD=-L -i c:\as\8051\include

</PRE>
eine Menge Tipparbeit ersparen. Da die Environment-Optionen vor der
Kommandozeile abgearbeitet werden, k&ouml;nnen Optionen in der
Kommandozeile widersprechende im Environment &uuml;bersteuern.
<P>
Bei sehr langen Pfaden kann es jedoch auch in der ASCMD-Variablen eng
werden. F&uuml;r solche F&auml;lle kann auf eine sog.<I> Key</I>-
Datei ausgewichen werden, in der die Optionen genauso wie in der
Kommandozeile oder ASCMD-Variablen abgelegt werden k&ouml;nnen, nur
da&szlig; diese Datei mehrere Zeilen mit jeweils maximal 255 Zeichen
enthalten darf. Wichtig ist dabei, da&szlig; bei Optionen, die ein
Argument ben&ouml;tigen, sowohl Schalter als auch Argument in<B>
einer</B> Zeile stehen m&uuml;ssen. Der Name der Datei wird AS
dadurch mitgeteilt, da&szlig; er mit einem vorangestellten
Klammeraffen in der ASCMD-Variablen abgelegt wird, z.B.
<PRE>

 set ASCMD=@c:\as\as.key

</PRE>
Um Optionen in der ASCMD-Variablen (oder der Key-Datei) wieder
aufzuheben, kann die Option mit einem vorangestellten Pluszeichen
wieder aufgehoben werden. Soll in einem Einzelfall z.B. doch kein
Listing erzeugt werden, so kann es mit
<PRE>

 as +L &lt;Datei&gt;

</PRE>
wieder aufgehoben werden. Nat&uuml;rlich ist es nicht ganz logisch,
eine Option mit einem Pluszeichen zu negieren...UNIX soit qui mal y
pense.
<P>
Referenzen auf eine Key-Datei k&ouml;nnen nicht nur von der<TT>
ASCMD</TT>-Variablen aus erfolgen, sondern auch direkt von der
Kommandozeile aus, indem man analog zur<TT> ASCMD</TT>-Variablen dem
Dateinamen einen Klammeraffen voranstellt:
<PRE>

 as @&lt;Datei&gt; ....

</PRE>
Die in einem solchen Fall aus dem Key-File gelesenen Optionen werden
so eingearbeitet, als h&auml;tten sie anstelle dieser Referenz in der
Kommandozeile gestanden - es ist also<EM> nicht</EM> wie bei der<TT>
ASCMD</TT>-Variablen so, da&szlig; sie vor allen anderen
Kommandozeilenoptionen abgearbeitet werden w&uuml;rden.
<P>
Das Referenzieren eines Key-Files von einem Key-File selber ist nicht
erlaubt und wird von AS mit einer Fehlermeldung quittiert.
<P>
F&uuml;r den Fall, da&szlig; Sie AS von einem anderen Programm oder
einer Shell aufrufen wollen und diese Shell nur Klein- oder
Gro&szlig;buchstaben in der Kommandozeile &uuml;bergeben will,
existiert folgendes Workaround: Wird vor den Buchstaben der Option
eine Tilde gesetzt, so werden die folgenden Buchstaben immer als
Kleinbuchstaben interpretiert. Analog erzwingt ein Lattenzaun die
Interpretation als Gro&szlig;buchstaben. Es ergeben sich z.B.
folgende Transformationen:
<BLOCKQUOTE>
    <TT> /~I --> /i<BR>
    -#u --> -U</TT>
</BLOCKQUOTE>
<P>
Abh&auml;ngig vom Ablauf der Assemblierung endet der Assembler mit
folgenden Returncodes:
<DL COMPACT>
<DT>0<DD>fehlerfreier Ablauf, h&ouml;chstens Warnungen aufgetreten</DD>
<DT>1<DD>Der Assembler hat nur die Aufrufparameter ausgegeben und endete
    danach sofort.</DD>
<DT>2<DD>Es sind Fehler bei der Assemblierung aufgetreten, es wurde kein
    Codefile erzeugt.</DD>
<DT>3<DD>Es trat ein fataler Fehler w&auml;hrend des Ablaufes auf, der zum
    sofortigen Abbruch gef&uuml;hrt hat.</DD>
<DT>4<DD>Bereits w&auml;hrend des Starts des Assemblers ist ein Fehler
    aufgetreten. Dies kann ein Parameterfehler oder eine fehlerhafte
    Overlay-Datei sein.</DD>
<DT>255<DD>Bei der Initialisierung ist irgendein interner Fehler aufgetreten,
    der auf keinen Fall auftreten sollte...neu booten, noch einmal
    probieren, und bei Reproduzierbarkeit mit mir Verbindung
    aufnehmen!</DD>
</DL>
<P>
Zus&auml;tzlich endet jede Assemblierung einer Datei mit einer
kleinen Statistik, die Fehlerzahlen, Laufzeit, Anzahl der
Durchl&auml;ufe und freien Speicher ausgibt. Bei eingeschaltetem
Assembler-Listing wird diese Statistik zus&auml;tzlich auch in das
Listing geschrieben.
<P>
OS/2 erweitert wie Unix das Datensegment einer Anwendung erst dann,      
wenn sie wirklich mehr Speicher anfordert. Eine Angabe wie
<BLOCKQUOTE>
    <TT> 511 KByte verf&uuml;gbarer Restspeicher</TT>
</BLOCKQUOTE>
bedeutet also nicht einen nahenden Systemabsturz wegen
Speichermangel, sondern stellt nur den Abstand zu der Grenze dar, bei
der OS/2 einfach ein paar mehr Kohlen in den Ofen schaufelt...
<P>
Da es unter C auf verschiedenen Betriebssystemen keine kompatible        
M&ouml;glichkeit gibt, den noch verf&uuml;gbaren Speicher bzw. Stack
zu ermitteln, fehlen bei der C-Version diese beiden Angaben ganz.
<P>

<H2><A NAME="sect_2_5_">2.5. Format der Eingabedateien</A></H2>
<A NAME="ref_AttrTypes"></A>
<P>
Wie die meisten Assembler auch erwartet AS genau einen Befehl pro
Zeile (Leerzeilen sind nat&uuml;rlich auch zugelassen). Die Zeilen
d&uuml;rfen nicht l&auml;nger als 255 Zeichen werden, dar&uuml;ber
hinaus gehende Zeichen werden abgeschnitten.
<P>
Eine einzelne Zeile hat folgendes Format:
<PRE>

[Label[:]]&lt;Befehl&gt;[.Attribut] [Parameter[,Parameter..]] [;Kommentar]

</PRE>
Eine Zeile darf dabei auch &uuml;ber mehrere Zeilen in der Quelldatei
verteilt sein, Folgezeichen (\) verketten diese Teile dann zu einer
einzigen Zeile. Zu beachten ist allerdings, da&szlig; aufgrund der
internen Pufferstruktur die Gesamtzeile nicht 256 Zeichen
&uuml;berschreiten darf. Zeilenangaben in Fehlermeldungen beziehen
sich immer auf die letzte Zeile einer solchen zusammengesetzten
Zeile.
<P>
Der Doppelpunkt nach dem Label ist optional, falls das Label in der
ersten Spalte beginnt (woraus folgt, da&szlig; der Befehl niemals in
Spalte 1 beginnen darf). Man mu&szlig; ihn aber setzen, falls das
Label nicht in der ersten Spalte beginnt, damit AS es von einem
Befehl unterscheiden kann. In letzterem Fall mu&szlig; &uuml;brigens
zwischen Doppelpunkt und dem Befehl mindestens ein Leerzeichen
stehen, falls der eingestellte Zielprozessor zu denjenigen
geh&ouml;rt, bei denen das Attribut auch eine mit einem Doppelpunkt
abgetrennte Formatangabe sein darf. Dieser Knopf ist aus
Eindeutigkeitsgr&uuml;nden n&ouml;tig, da sonst keine Unterscheidung
zwischen Befehl mit Format und Label mit Befehl m&ouml;glich
w&auml;re.
<P>
Einige Signalprozessorreihen von Texas Instruments verwenden den
f&uuml;r das Label vorgesehenen Platz wahlweise auch f&uuml;r einen
Doppelstrich (||), der die parallele Ausf&uuml;hrung mit der
vorangehenden Instruktion anzeigt. Wenn diese beiden Instruktionen
auf Maschinenebene in einem einzigen Wort vereinigt werden (C3x),
macht ein zus&auml;tzliches Label vor der zweiten Anweisung
nat&uuml;rlich keinen Sinn und ist auch nicht vorgesehen. Anders
sieht es beim C6x mit seinen Instruktionspaketen variabler L&auml;nge
aus: Wer dort (unsch&ouml;nerweise...) mitten in ein Paket
hineinspringen will, mu&szlig; das Label daf&uuml;r in eine
Extrazeile davor setzen (das gleiche gilt &uuml;brigens auch f&uuml;r
Bedingungen, die aber zusammen mit dem Doppelstrich in einer Zeile
stehen d&uuml;rfen).
<P>
Das Attribut wird von einer Reihe von Prozessoren benutzt, um
Spezialisierungen oder Kodierungsvarianten eines bestimmten Befehls
zu spezifizieren. Die bekannteste Nutzung des Attributs ist die
Angabe der Operandengr&ouml;&szlig;e, wie z. B. bei der 680x0-Familie
(Tabelle <A HREF="#ref_TabAttrs">2.6</A>).

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Attribut</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>arithmetisch-logischer Befehl</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sprungbefehl</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>B<BR>
W<BR>
L<BR>
Q<BR>
S<BR>
D<BR>
X<BR>
P</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Byte (8 Bit)<BR>
Wort (16 Bit)<BR>
Langwort (32 Bit)<BR>
Vierfachwort (64 Bit)<BR>
Single Precision (32 Bit)<BR>
Double Precision (64 Bit)<BR>
Extended Precision (80/96 Bit)<BR>
Dezimalgleitkomma (80/96 Bit)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>---------<BR>
---------<BR>
16-Bit-Displacement<BR>
---------<BR>
8-Bit-Displacement<BR>
---------<BR>
32-Bit-Displacement<BR>
---------</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.6: Erlaubte Attribute (Beispiel 680x0)<A
             NAME="ref_TabAttrs"></A>
</CENTER><P>

<P>
Da sich diese Anleitung nicht gleichzeitig als Handbuch f&uuml;r die
von AS unterst&uuml;tzten Prozessorfamilien versteht, ist dies leider
auch nicht der richtige Platz, um hier alle m&ouml;glichen Attribute
f&uuml;r alle unterst&uuml;tzten Familien aufzuz&auml;hlen. Es sei
aber angemerkt, da&szlig; i.a. nicht alle Befehle alle Attribute
zulassen, andererseits das Fortlassen eines Attributs meist zur
Verwendung der f&uuml;r diese Familie ,,nat&uuml;rlichen''
Operandengr&ouml;&szlig;e f&uuml;hrt. Zum genaueren Studium greife
man auf ein Programmierhandbuch f&uuml;r die jeweilige Familie
zur&uuml;ck, z.B. in <A HREF="#cite_Williams">[1]</A> f&uuml;r die
68000er.
<P>
Bei TLCS-9000, H8/500 und M16(C) dient das Attribut sowohl der Angabe
der Operandengr&ouml;&szlig;e, falls diese nicht durch die Operanden
klar sein sollte, als auch der des zu verwendenden Befehlsformates.
Dieses mu&szlig; durch einen Doppelpunkt von der
Operandengr&ouml;&szlig;e getrennt werden, z.B. so:
<PRE>

    add.w:g   rw10,rw8

</PRE>
Was dieses Beispiel nicht zeigt, ist, da&szlig; die Formatangabe auch
ohne Operandengr&ouml;&szlig;e geschrieben werden darf. Steht
demgegen&uuml;ber eine Operandengr&ouml;&szlig;e ohne Formatangabe,
verwendet AS automatisch das k&uuml;rzeste Format. Die erlaubten
Befehlsformate und Operandengr&ouml;&szlig;en sind vom
Maschinenbefehl abh&auml;ngig und k&ouml;nnen z.B. <A
HREF="#cite_Tosh9000">[109]</A>, <A HREF="#cite_HitH8_5">[24]</A>, <A
HREF="#cite_MitM16">[44]</A> bzw. <A HREF="#cite_MitM16C">[45]</A>
entnommen werden.
<P>
Die Zahl der Befehlsparameter ist abh&auml;ngig vom Befehl und kann
prinzipiell zwischen 0 und 20 liegen. Die Trennung der Parameter
voneinander erfolgt ausschlie&szlig;lich durch Kommas (Ausnahme:
DSP56xxx, dessen parallele Datentransfers durch Leerzeichen getrennt
werden), wobei in Klammern oder Hochkommas eingeschlossene Kommas
nat&uuml;rlich nicht beachtet werden.
<P>
Anstelle eines Kommentars am Ende kann die Zeile auch nur aus einem
Kommentar bestehen, wenn er in der ersten Spalte beginnt.
<P>
Bei den Leerzeichen zur Trennung einzelnen Komponenten darf es sich
genauso gut um Tabulatoren handeln.
<P>

<H2><A NAME="sect_2_6_">2.6. Format des Listings</A></H2>
<P>
Das von AS bei Angabe der Kommandozeilenoptionen<TT> l</TT> oder<TT>
L</TT> erzeugte Listing l&auml;&szlig;t sich grob in folgende Teile
gliedern:
<OL>
<LI>Wiedergabe des assemblierten Quellcodes;</LI>
<LI>Symbolliste;</LI>
<LI>Makroliste;</LI>
<LI>Funktionsliste;</LI>
<LI>Belegungsliste;</LI>
<LI>Querverweisliste.</LI>
</OL>
Letztere beide werden nur erzeugt, wenn sie durch zus&auml;tzliche
Kommandozeilenoptionen angefordert wurden.
<P>
Im ersten Teil listet AS den kompletten Inhalt aller Quelldateien
inklusive des erzeugten Codes auf. Eine Zeile in diesem Listing hat
dabei folgende Form:
<PRE>

[&lt;n&gt;] &lt;Zeile&gt;/&lt;Adresse&gt; &lt;Code&gt; &lt;Quelle&gt;

</PRE>
Im Feld n zeigt AS die Include-Verschachtelungstiefe an. Die
Hauptdatei (die Datei, mit der die Assemblierung begann), hat dabei
die Tiefe 0, von dort aus eingebundene Dateien haben Tiefe 1 usw. Die
Tiefe 0 wird dabei nicht angezeigt.
<P>
Im Feld<TT> Zeile</TT> wird die Zeilennummer bezogen auf die
jeweilige Datei ausgegeben. Die erste Zeile einer Datei hat dabei
Nummer 1. Die Adresse, an der der f&uuml;r diese Zeile erzeugte Code
abgelegt wurde, folgt hinter dem Schr&auml;gstrich im Feld<TT>
Adresse</TT>.
<P>
Der erzeugte Code selber steht dahinter im Feld<TT> Code</TT> in
hexadezimaler Schreibweise. Je nach Prozessortyp und aktuellem
Segment k&ouml;nnen die Werte entweder als Bytes oder 16/32-Bit-Worte
formatiert sein. Sollte mehr Code erzeugt worden sein, als in das
Feld hineinpa&szlig;t, so werden im Anschlu&szlig; an die Zeile
weitere Zeilen erzeugt, in denen nur dieses Feld belegt ist.
<P>
Im Feld<TT> Quelle</TT> schlu&szlig;endlich wird die Zeile aus der
Quelldatei in ihrer Originalform ausgegeben.
<P>
Die Symboltabelle ist so ausgelegt, da&szlig; sie nach
M&ouml;glichkeit immer in 80 Spalten dargestellt werden kann.
F&uuml;r Symbole ,,normaler L&auml;nge'' wird eine zweispaltige
Ausgabe gew&auml;hlt. Sollten einzelne Symbole mit ihrem Wert die
Grenze von 40 Spalten &uuml;berschreiten, werden sie in einer
einzelnen Zeile ausgegeben. Die Ausgabe erfolgt in alphabetischer
Reihenfolge. Symbole, die zwar definiert, aber nie benutzt wurden,
werden mit einem vorangestellten Stern (*) gekennzeichnet.
<P>
Die bisher genannten Teile sowie die Auflistung aller definierten
Makros / Funktionen lassen sich selektiv aus dem Gesamtlisting
ein-und ausblenden, und zwar mit dem bereits erw&auml;hnten<TT>
t</TT>-Kommandozeilenschalter. Intern existiert in AS ein Byte,
dessen Bits repr&auml;sentieren, welche Teile ausgegeben werden
sollen. Die Zuordnung von Bits zu den Teilen ist in Tabelle <A
HREF="#ref_TabTBits">2.7</A> aufgelistet.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bit</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Teil</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0<BR>
1<BR>
2<BR>
3<BR>
4<BR>
5<BR>
7</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Quelldatei(en)+erzeugter Code<BR>
Symboltabelle<BR>
Makroliste<BR>
Funktionsliste<BR>
Zeilennumerierung<BR>
Registersymboltabelle<BR>
Zeichentabellenliste</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.7: Zuordnung der Bits zu den Listingkomponenten<A
             NAME="ref_TabTBits"></A>
</CENTER><P>

Defaultm&auml;&szlig;ig sind alle Bits auf 1 gesetzt, bei Verwendung
des Schalters
<PRE>

-t &lt;Maske&gt;

</PRE>
werden die in &lt;Maske&gt; gesetzten Bits gel&ouml;scht, so
da&szlig; die entsprechenden Listing-Teile unterdr&uuml;ckt werden.
Analog lassen sich mit einem Pluszeichen einzelne Teile wieder
einschalten, falls man es in der<TT> ASCMD</TT>-Variablen
&uuml;bertrieben hat...will man z.B. nur die Symboltabelle haben, so
reicht
<PRE>

-t 2  .

</PRE>
In der Belegungsliste werden f&uuml;r jedes Segment einzeln die
belegten Bereiche hexadezimal ausgegeben. Handelt es sich bei einem
Bereich um eine einzige Adresse, wird nur diese ausgegeben, ansonsten
erste und letzte Adresse.
<P>
In der Querverweisliste wird f&uuml;r jedes definierte Symbol in
alphabetischer Reihenfolge eine Ausgabe folgender Form erzeugt:
<PRE>

Symbol &lt;Symbolname&gt; (=&lt;Wert&gt;,&lt;Datei&gt;/&lt;Zeile&gt;):
 Datei &lt;Datei 1&gt;:
 &lt;n1&gt;[(m1)]  ..... &lt;nk&gt;[(mk)]
 .
 .
 Datei &lt;Datei l&gt;:
 &lt;n1&gt;[(m1)]  ..... &lt;nk&gt;[(mk)]

</PRE>
F&uuml;r jedes Symbol wird aufgelistet, in welchen Dateien es in
welchen Zeilen angesprochen wurde. Sollte ein Symbol mehrmals in der
gleichen Zeile benutzt worden sein, so wird dies durch eine in
Klammern gesetzte Anzahl hinter der Zeilennummer angedeutet. Sollte
ein Symbol niemals benutzt worden sein, erscheint es auch nicht in
der Liste; entsprechend erscheint eine Datei auch &uuml;berhaupt
nicht in der Liste eines Symbols, falls es in der entsprechenden
Datei nicht referenziert wurde.
<P>
<B> ACHTUNG!</B> AS kann dieses Listing nur dann korrekt aufs Papier
bringen, wenn man ihm vorher die L&auml;nge und Breite des
Ausgabemediums mit Hilfe des<TT> PAGE</TT>-Befehls (siehe dort)
mitgeteilt hat! Der voreingestellte Default sind 60 Zeilen und eine
unbegrenzte Zeilenbreite.
<P>

<H2><A NAME="sect_2_7_">2.7. Symbolkonventionen</A></H2>
<A NAME="ref_SectSymConv"></A>
<P>
Symbole d&uuml;rfen zwar (wie in der Einleitung bereits angedeutet)
bis zu 255 Zeichen lang werden und werden auch auf der ganzen
L&auml;nge unterschieden, die Symbolnamen m&uuml;ssen aber einigen
Konventionen gen&uuml;gen:
<P>
Symbolnamen d&uuml;rfen aus einer beliebigen Kombination von
Buchstaben, Ziffern, Unterstrichen und Punkten bestehen, wobei das
erste Zeichen keine Ziffer sein darf. Der Punkt wurde nur zugelassen,
um der MCS-51-Notation von Registerbits zu gen&uuml;gen, und sollte
m&ouml;glichst nicht in eigenen Symbolnamen verwendet werden. Zur
Segmentierung von Symbolnamen sollte auf jeden Fall der Unterstrich
und nicht der Punkt verwendet werden.
<P>
Defaultm&auml;&szlig;ig ist AS nicht case-sensitiv, es ist also egal,
ob man Gro&szlig;-oder Kleinbuchstaben verwendet. Mittels des
Kommandozeilenschalters<TT> U</TT> l&auml;&szlig;t sich AS jedoch in
einen Modus umschalten, in dem Gro&szlig;- und Kleinschreibung
unterschieden wird. Ob AS umgeschaltet wurde, kann mit dem
vordefinierten Symbol<TT> CASESENSITIVE</TT> ermittelt werden: TRUE
bedeutet Unterscheidung, FALSE keine.
<P>
Tabelle <A HREF="#ref_TabPredefined">2.8</A> zeigt die wichtigsten,
von AS vordefinierten Symbole.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TRUE</TT><BR>
<TT> FALSE</TT><BR>
<TT> CONSTPI</TT><BR>
<TT> VERSION</TT><BR>
<BR>
<TT> ARCHITECTURE</TT><BR>
<BR>
<TT> DATE</TT><BR>
<TT> TIME</TT><BR>
<TT> MOMCPU</TT><BR>
<TT> MOMCPUNAME</TT><BR>
<TT> MOMFILE</TT><BR>
<TT> MOMLINE</TT><BR>
<TT> MOMPASS</TT><BR>
<TT> MOMSECTION</TT><BR>
<BR>
<TT> MOMSEGMENT</TT><BR>
<BR>
 *, $ bzw.<TT> PC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>logisch ,,wahr''<BR>
logisch ,,falsch''<BR>
Kreiszahl Pi (3.1415.....)<BR>
Version von AS in BCD-Kodierung,<BR>
z.B. 1331 hex f&uuml;r Version 1.33p1<BR>
Zielplattform, f&uuml;r die AS &uuml;bersetzt wurde,<BR>
in der Form Prozesor-Hersteller-Betriebssystem<BR>
Datum und<BR>
Zeitpunkt der Assemblierung (Beginn)<BR>
momentan gesetzte Ziel-CPU<BR>
dito, nur als voll ausgeschriebener String<BR>
augenblickliche Quelldatei<BR>
Zeilennummer in Quelldatei<BR>
Nummer das laufenden Durchgangs<BR>
Name der aktuellen Sektion oder<BR>
Leerstring<BR>
Name des mit<TT> SEGMENT</TT> gew&auml;hlten<BR>
Adre&szlig;raumes<BR>
mom. Programmz&auml;hler</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.8: Vordefinierte Symbole<A NAME="ref_TabPredefined"></A>
</CENTER><P>

<B> VORSICHT!</B> W&auml;hrend es im case-insensitiven Modus egal
ist, mit welcher Kombination von Gro&szlig;- und Kleinbuchstaben man
vordefinierte Symbole anspricht, mu&szlig; man sich im
case-sensitiven Modus exakt an die oben angegebene Schreibweise (nur
Gro&szlig;buchstaben) halten!
<P>
Zus&auml;tzlich definieren einige Pseudobefehle noch Symbole, die
eine Abfrage des damit momentan eingestellten Wertes
erm&ouml;glichen. Deren Beschreibung findet sich bei den
zugeh&ouml;rigen Befehlen.
<P>
Ein etwas verstecktes (und mit Vorsicht zu nutzendes) Feature ist,
Symbolnamen aus String-Variablen zusammenzubauen, indem man den Namen
des Strings mit geschweiften Klammern in den Symbolnamen einbaut. So
kann man z.B. den Namen eines Symbols anhand des Wertes eines anderen
Symbols festlegen:
<PRE>

cnt		set	cnt+1
temp		equ	"\{CNT}"
		jnz	skip{temp}
		.
		.
skip{temp}:	nop

</PRE>
<B>ACHTUNG!</B> Der Programmierer ist selber daf&uuml;r
verantwortlich, da&szlig; sich dabei g&uuml;ltige Symbolnamen
ergeben!
<P>
Eine vollst&auml;ndige Auflistung aller von AS verwendeten
Symbolnamen findet sich in Anhang <A HREF="#ref_AppInternSyms">E</A>.
<P>
Neben seinem Wert besitzt auch jedes Symbol eine Markierung, zu
welchen<EM> Segment</EM> es geh&ouml;rt. In erster Linie wird eine
solche Unterscheidung bei Prozessoren ben&ouml;tigt, die mehrere
Adre&szlig;r&auml;ume besitzen. AS kann mit dieser Zusatzinformation
bei Zugriffen &uuml;ber ein Symbol warnen, wenn ein f&uuml;r diesen
Adre&szlig;raum ungeeigneter Befehl verwendet wird. Ein
Segmentattribut wird einem Symol automatisch angeh&auml;ngt, wenn es
als Label oder mit einem Spezialbefehl (z.B.<TT> BIT</TT>) definiert
wird; ein mit dem ,,Universalbefehl''<TT> SET</TT> oder<TT> EQU</TT>
definiertes Symbol ist jedoch ,,typenlos'', d.h. seine Verwendung
wird niemals Warnungen ausl&ouml;sen. Das Segmentattribut eines
Symbols kann mit der eingebauten Funktion<TT> SYMTYPE</TT> abgefragt
werden, etwa so:
<PRE>

Label:
        .
        .
Attr    equ     symtype(Label)  ; ergibt 1

</PRE>
Den einzelnen Segmenttypen sind die in Tabelle <A
HREF="#ref_TabSegNums">2.9</A> aufgelisteten Nummern zugeordnet. Die
aus der Ordnung normaler Symbole etwas herausfallenden
Registersymbole sind n&auml;her in Abschnitt <A
HREF="#ref_SectRegSyms">2.11</A> erl&auml;utert. Mit einem
undefinierten Symbol als Argument liefert die<TT>
SYMTYPE</TT>-Funktion -1 als Ergebnis.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>R&uuml;ckgabewert</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&lt;keines&gt;<BR>
CODE<BR>
DATA<BR>
IDATA<BR>
XDATA<BR>
YDATA<BR>
BITDATA<BR>
IO<BR>
REG<BR>
ROMDATA<BR>
&lt;Registersymbol&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>0<BR>
1<BR>
2<BR>
3<BR>
4<BR>
5<BR>
6<BR>
7<BR>
8<BR>
9<BR>
128</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.9: R&uuml;ckgabewerte der<TT> SYMTYPE</TT>-Funktion<A
             NAME="ref_TabSegNums"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_2_8_">2.8. Tempor&auml;re Symbole</A></H2>
<P>
Besonders bei Programmen mit vielen aufeinanderfolgenden Schleifen
oder IF-artigen Strukturen steht man immer wieder vor dem Problem,
sich st&auml;ndig neue Namen f&uuml;r Labels ausdenken zu
m&uuml;ssen. Dabei wei&szlig; man an sich genau, da&szlig; man dieses
Label nie wieder brauchen wird und am liebsten in irgendeiner Weise
'verwerfen' m&ouml;chte. Eine einfache L&ouml;sung, wenn man nicht
gleich den gro&szlig;en Hammer des Sektionskonzeptes (siehe Kapitel <A
HREF="#ref_ChapLocSyms">3.8</A>) schwingen m&ouml;chte, sind<EM>
tempor&auml;re</EM> Symbole, die solange ihre G&uuml;ltigkeit
behalten, bis ein neues, nicht-tempor&auml;res Symbol definiert wird.
Andere Assembler bieten einen &auml;hnlichen Mechanismus an, der dort
unter dem Stichwort 'lokale Symbole' l&auml;uft, zur besseren
Abgrenzung gegen das Sektionskonzept m&ouml;chte ich aber beim
Begriff 'tempor&auml;re Symbole' bleiben. AS kennt drei
unterschiedliche Typen von tempor&auml;ren Symbolen, um jedem
'Umsteiger' ein Konzept anzubieten, das den Umstieg so einfach wie
m&ouml;glich macht. Leider kocht quasi jeder Assembler bei diesem
Thema sein eigenes S&uuml;ppchen, so da es nur in
Ausnahmef&auml;llen eine 1:1-L&ouml;sung f&uuml;r existierenden Code
geben wird:
<P>

<H3><A NAME="sect_2_8_1_">2.8.1. Tempor&auml;re Symbole mit Namen</A></H3>
<P>
Ein Symbol, dessen Name mit zwei Dollarzeichen beginnt (dies ist
weder f&uuml;r normale Symbole noch Konstanten zul&auml;ssig), ist
ein tempor&auml;res Symbol mit Namen. AS f&uuml;hrt intern einen
Z&auml;hler mit, der zu Beginn der Assemblierung auf Null gesetzt
wird und bei jeder Definition eines nicht-tempor&auml;ren Symbols
inkrementiert wird. Wird ein tempor&auml;res Symbol definiert oder
referenziert, so werden die beiden f&uuml;hrenden Dollarzeichen
gestrichen und der momentane Stand des Z&auml;hlers wird
angeh&auml;ngt. Auf diese Weise erh&auml;lt man mit jedem
nicht-tempor&auml;ren Symbol sozusagen die Symbolnamen zur&uuml;ck -
man kommt an die Symbole vor dieser Definition aber auch nicht mehr
heran! Tempor&auml;re Symbole bieten sich daher besonders f&uuml;r
den Einsatz in kleinen Anweisungsbl&ouml;cken an, typischerweise etwa
ein Dutzend Befehle, auf keinen Fall mehr als eine Bildschirmseite,
sonst kommt man leicht durcheinander...
<P>
Hier ein kleines Beispiel:
<PRE>

$$loop: nop
        dbra    d0,$$loop

split:

$$loop: nop
        dbra    d0,$$loop

</PRE>
W&auml;re das zwischen den Schleifen liegende nicht-tempor&auml;re
Label nicht vorhanden, g&auml;be es nat&uuml;rlich eine Fehlermeldung
wegen eines doppelt definierten Symbols.
<P>
<EM> Namenlose Tempor&auml;re Symbole</EM>
<P>
F&uuml;r all jene, denen tempor&auml;re Symbole mit Namen noch immer
zu kompliziert sind, gibt es eine noch einfachere Variante: Setzt man
als Label ein einfaches Plus- oder Minuszeichen, so werden diese in
die Namen<TT> __forwnn</TT> bzw.<TT> __backmm</TT> umgesetzt,
wobei<TT> nn</TT> bzw.<TT> mm</TT> von Null an laufende Z&auml;hler
sind. Referenziert werden diese Symbole &uuml;ber die Sonderwerte<TT>
- -- ---</TT> bzw.<TT> + ++ +++</TT>, womit sich die drei letzten
'Minussymbole' bzw die drei n&auml;chsten 'Plussymbole' referenzieren
lassen. Welche Variante man benutzt, h&auml;ngt also davon ab, ob man
ein Symbol vorw&auml;rts oder r&uuml;ckw&auml;rts referenzieren will.
<P>
Bei der<EM> Definition</EM> namenloser tempor&auml;rer Symbole gibt
es neben dem Plus- und Minuszeichen noch eine dritte Variante,
n&auml;mlich einen Schr&auml;gstrich (/). Ein so definiertes
tempor&auml;res Symbol kann gleicherma&szlig;en vorw&auml;rts wie
r&uuml;ckw&auml;rts referenziert werden; d. h. je nach Referenzierung
wird es wie ein Minus oder Plus behandelt.
<P>
Namenlose tempor&auml;re Symbole finden ihre Anwendung
&uuml;blicherweise in Konstruktionen, die auf eine Bildschirmseite
passen, wie das bedingte &Uuml;berspringen von ein paar
Maschinenbefehlen oder kleinen Schleifen - ansonsten w&uuml;rde die
Sache zu un&uuml;bersichtlich werden (das ist aber nur ein gut
gemeinter Rat...). Ein Beispiel daf&uuml;r ist das folgende
St&uuml;ck Code, zur Abwechslung mal als 65xx-Code:
<PRE>

        cpu     6502

-       ldx     #00
-       dex
        bne     -            ; springe zu 'dex'
        lda     RealSymbol
        beq     +            ; springe zu 'bne --'
        jsr     SomeRtn
        iny
+       bne     --           ; springe zu 'ldx #00'

SomeRtn:
        rts

RealSymbol:
        dfs     1

  	inc	ptr
   	bne 	+      	    ; springe zu 'tax'
   	inc 	ptr+1
+ 	tax

 	bpl 	++     	    ; springe zu 'dex'
   	beq 	+      	    ; springe vorwaerts zu 'rts'
   	lda 	#0
/  	rts            	    ; Schraegstrich = Wildcard
+ 	dex
   	beq 	-           ; springe rueckwaerts zu 'rts'

ptr:	dfs	2

</PRE>
<P>

<H3><A NAME="sect_2_8_2_">2.8.2. Zusammengesetzte tempor&auml;re Symbole</A></H3>
<P>
Dies ist vielleicht der Typ von tempor&auml;ren Symbolen, der dem
Konzept von lokalen Symbolen und Sektionen am n&auml;chsten kommt.
Wann immer der Name eines Symboles mit einem Punkt (.) anfngt, wird
das Symbol nicht mit diesem Namen in der Symboltabelle abgelegt.
Stattdessen wird der Name des zuletzt definierten Symbols ohne
vorangestellten Punkt davorgeh&auml;ngt. Auf diese Weise nehmen
Sybole, deren Name nicht mit einem Punkt anf&auml;ngt, quasi die
Rolle von 'Bereichsgrenzen' ein und Symbole, deren Name mit einem
Punkt anf&auml;ngt, k&ouml;nnen in jedem Bereich neu verwendet
werden. Sehen wir uns das folgende kurze Beispiel an:
<PRE>

proc1:                    ; nicht-tempor"ares Symbol 'proc1'

.loop   moveq   #20,d0    ; definiert in Wirklichkeit 'proc1.loop'
        dbra    d0,.loop
        rts

proc2:                    ; nicht-tempor"ares Symbol 'proc2'

.loop   moveq   #10,d1    ; definiert in Wirklichkeit 'proc2.loop'
        jsr     proc1
        dbra    d1,.loop
        rts

</PRE>
Man beachte, da&szlig; es weiterhin m&ouml;glich ist, auf alle
tempor&auml;ren Symbole zuzugreifen, auch wenn man sich nicht im
gleichen 'Bereich' befindet, indem man einfach den zusammengesetzten
Namen benutzt (wie z.B. 'proc2.loop' im voranstehenden Beispiel).
<P>
Zusammengesetzte Symbole lassen sich prinzipiell mit Sektionen
kombinieren und k&ouml;nnen so auch zu lokalen Symbolen werden. Man
beachte allerdings, da&szlig; das zuletzt definierte, nicht
tempor&auml;re Symbol nicht pro Sektion gespeichert wird, sondern
lediglich global. Das kann sich aber auch irgendwann einmal
&auml;ndern, man sollte sich also nicht auf das augenblickliche
Verhalten verlassen.
<P>

<H2><A NAME="sect_2_9_">2.9. Formelausdr&uuml;cke</A></H2>
<P>
An den meisten Stellen, an denen der Assembler Zahlenangaben
erwartet, k&ouml;nnen nicht nur einfache Symbole oder Konstanten
angegeben werden, sondern ganze Formelausdr&uuml;cke. Bei den
Komponenten der Formelausdr&uuml;cke kann es sich sowohl um ein
einzelnes Symbol als auch um eine Konstante handeln. Konstanten
d&uuml;rfen entweder Integer-, Gleitkomma-, oder Stringkonstanten
sein.
<P>

<H3><A NAME="sect_2_9_1_">2.9.1. Integerkonstanten</A></H3>
<A NAME="ref_SectIntConsts"></A>
<P>
Integerkonstanten bezeichnen ganze Zahlen. Sie d&uuml;rfen entweder
als eine Folge von Ziffern oder als eine Reihe von in<EM>
einfachen</EM> Hochkommas eingeschlossenen Zeichen geschrieben
werden. Werden sie als Ziffernfolgen geschrieben, so kann dies in
verschiedenen Zahlensystemen erfolgen, deren Kennzeichnung von
verwendeten Zielprozessor abh&auml;ngt (Tabelle <A
HREF="#ref_TabSystems">2.10</A>).
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Intel-Modus<BR>
(Intel, Zilog,<BR>
Thomson, Texas,<BR>
Toshiba, NEC,<BR>
Siemens, Philips,<BR>
Fujitsu, Fairchild,<BR>
Intersil)</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Motorola-Modus<BR>
(Rockwell, Motorola,<BR>
Microchip, Thomson,<BR>
Hitachi)<BR>
<BR>
<BR>
</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>C-Modus<BR>
(PowerPC,<BR>
AMD29K,<BR>
National,<BR>
Symbios,<BR>
Atmel)<BR>
</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dezimal<BR>
hexadezimal<BR>
bin&auml;r<BR>
oktal<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
nachgestelltes H<BR>
nachgestelltes B<BR>
nachgestelltes O<BR>
nachgestelltes Q</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
vorangestelltes $<BR>
vorangestelltes %<BR>
vorangestelltes @<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>direkt<BR>
vorangestelltes 0x<BR>
vorangestelltes 0b<BR>
vorangestellte 0<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.10: m&ouml;gliche Zahlensysteme<A
              NAME="ref_TabSystems"></A>
</CENTER><P>

Falls das Zahlensystem nicht explizit durch vor-oder nachgestelle
Zeichen vorgegeben wird, nimmt AS die Basis an, die mit dem<TT>
RADIX</TT>-Befehl vorgegeben wurde (der Default dieser Einstellung
ist wiederum 10). Mit diesem Befehl lassen sich auch
,,ungew&ouml;hnliche" Zahlensysteme, d.h. andere als 2, 8, 10 oder 16
einstellen.
<P>
G&uuml;ltige Ziffern sind die Zahlen 0 bis 9 sowie die Buchstaben A
bis Z (Wert 10 bis 35) bis zur Basis des Zahlensystems minus eins.
Die Verwendung von Buchstaben in Integerkonstanten bringt allerdings
auch einige Mehrdeutigkeiten mit sich, da Symbolnamen ja auch Ketten
aus Zahlen und Buchstaben sind: Ein Symbolname darf nicht mit einem
Zeichen von 0 bis 9 beginnen, was bedeutet, da&szlig; eine
Integerkonstante, die nicht durch ein anderes Sonderzeichen eindeutig
als solche erkennbar ist, niemals mit einem Buchstaben beginnen darf;
notfalls mu&szlig; man eine eigentlich &uuml;berfl&uuml;ssige Null
voranstellen. Der bekannteste Fall ist das Schreiben von
Hexadezimalkonstanten im Intel-Modus: Ist die vorderste Stelle
zwischen A und F, so hilft das hintangestellte H &uuml;berhaupt
nichts, es mu&szlig; noch eine Null davor (statt F0H also 0F0H). Die
Motorola-oder C-Syntax, die beide das Zahlensystem am Anfang einer
Integerkonstante kennzeichnen, kennen dieses Problem nicht.
(<I>hihihi!</I>).
<P>
Reichlich heimt&uuml;ckisch ist auch, da&szlig; bei immer
h&ouml;heren, mit<TT> RADIX</TT> eingestellten Zahlensystemen, die
bei Intel- und C-Syntax benutzten Buchstaben zur Zahlensystemkennung
immer weiter ,,aufgefressen'' werden; so kann man z.B. nach<TT> RADIX
16</TT> keine bin&auml;ren Konstanten mehr schreiben, und ab<TT>
RADIX 18</TT> in Intel-Syntax auch keine hexadezimalen Konstanten
mehr. Also<B> VORSICHT!</B>
<P>
Mit Hilfe des<TT> RELAXED</TT>-Befehls (siehe Abschnitt <A
HREF="#ref_SectRELAXED">3.9.6</A>) kann die starre Zuordnung einer
Schreibweise zu einem Zielprozessor aufgehoben werden, so da&szlig;
man eine beliebige Schreibweise verwenden kann (auf Kosten der
Kompatibilit&auml;t zu Standard-Assemblern). Defaultm&auml;&szlig;ig
ist diese Option aber ausgeschaltet. Ebenfalls mit dieser Option
er&ouml;ffnet sich eine weitere, vierte Schreibweise f&uuml;r
Integerkonstanten, wie man sie bei manchen Fremdassemblern antrifft:
Bei dieser Schreibweise wird der eigentliche Wert in Hochkommas
geschrieben und das Zahlensystem ('x' oder 'h' f&uuml;r hexadezimal,
'o' f&uuml;r oktal und 'b' f&uuml;r bin&auml;r) direkt davor. Die
Integer-Konstante 305419896 kann damit also folgenderma&szlig;en
geschrieben werden:
<PRE>

 x'12345678'
 h'12345678'
 o'2215053170'
 b'00010010001101000101011001111000'

</PRE>
Diese Schreibweise ist f&uuml;r keine Prozessorarchitektur der
Default und nur im<TT> RELAXED</TT>-Modus erreichbar. Sie dient in
erster Linie der einfacheren Portierung von Fremdquellen und wird
nicht f&uuml;r neu erstellte Programme empfohlen.
<P>
Wie bereits angesprochen, k&ouml;nnen Integer-Konstanten auch als
ASCII-Werte geschrieben werden, so entsprechen
<PRE>

'A'    == $41
'AB'   == $4142
'ABCD' == $41424344

</PRE>
Wichtig ist, da&szlig; hier die Zeichen in<EM> einfachen
Hochkommas</EM> geschrieben werden, um sie von den weiter unten
beschriebenen Stringkonstanten zu unterscheiden.
<P>

<H3><A NAME="sect_2_9_2_">2.9.2. Gleitkommakonstanten</A></H3>
<P>
Gleitkommazahlen werden in der &uuml;blichen halblogarithmischen
Schreibweise geschrieben, die in der allgemeinsten Form
<PRE>

 [-]&lt;Vorkommastellen&gt;[.Nachkommastellen][E[-]Exponent]

</PRE>
lautet.<B> ACHTUNG!</B> Der Assembler versucht eine Konstante zuerst
als Integerkonstante zu verstehen und macht erst dann einen Versuch
mit Gleitkomma, falls dies gescheitert ist. Will man aus
irgendwelchen Gr&uuml;nden die Auswertung als Gleitkommazahl
erzwingen, so kann man dies durch Dummy-Nachkommastellen erreichen,
z.B.<TT> 2.0</TT> anstelle<TT> 2</TT>.
<P>

<H3><A NAME="sect_2_9_3_">2.9.3. Stringkonstanten</A></H3>
<A NAME="ref_SectStringConsts"></A>
<P>
Stringkonstanten m&uuml;ssen in<EM> doppelte Hochkommas</EM> (um sie
von den oben beschrieben ASCII-Integers zu unterscheiden)
eingeschlossen werden. Um nun aber auch G&auml;nsef&uuml;&szlig;chen
und Sonderzeichen ohne Verrenkungen in String-Konstanten einbauen zu
k&ouml;nnen, wurde ein ,,Escape-Mechanismus'' eingebaut, der
Programmierer(inne)n aus C bekannt vorkommen d&uuml;rfte:
<P>
Schreibt man einen Backslash mit einer maximal dreiziffrigen Zahl im
String, so versteht der Assembler dies als Zeichen mit dem
entsprechenden dezimalen ASCII-Wert. Alternativ kann der Zahlenwert
auch hexadezimal oder oktal mit einem vorangestellten x oder einer
vorangestellten 0 geschrieben werden. F&uuml;r die hexadezimale
Schreibweise reduziert sich die Maximalanzahl von Stellen auf 2. So
kann man z.B. mit<TT>\3</TT> ein ETX-Zeichen definieren. Vorsicht
allerdings mit der Definition von NUL-Zeichen! Da die C-Version von      
AS momentan intern zur Speicherung von String-Symbolen C-Strings
benutzt (die durch NUL-Zeichen terminiert werden), sind NUL-Zeichen
in Strings momentan nicht portabel!
<P>
Einige besonders h&auml;ufig gebrauchte Steuerzeichen kann man auch
mit folgenden Abk&uuml;rzungen erreichen:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> \b : Backspace</TD><TD NOWRAP> \a : Klingel</TD><TD NOWRAP> \e : Escape</TD></TR>
    <TR><TD NOWRAP> \t : Tabulator</TD><TD NOWRAP> \n : Zeilenvorschub</TD><TD NOWRAP> \r : Wagenr&uuml;cklauf</TD></TR>
    <TR><TD NOWRAP> \\ : Backslash</TD><TD NOWRAP> \' oder \h : Hochkomma</TD></TR>
    <TR><TD NOWRAP> \" oder \i : G&auml;nsef&uuml;&szlig;chen</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Die Kennbuchstaben d&uuml;rfen sowohl gro&szlig; als auch klein
geschrieben werden.
<P>
&Uuml;ber dieses Escape-Zeichen k&ouml;nnen sogar
Formelausdr&uuml;cke in den String eingebaut werden, wenn sie in
geschweifte Klammern eingefa&szlig;t werden: z.B. ergibt
<PRE>

    message "Wurzel aus 81 : \{sqrt(81)}"

</PRE>
die Ausgabe
<PRE>

    Wurzel aus 81 : 9

</PRE>
Der Assembler w&auml;hlt anhand des Formelergebnistyps die richtige
Ausgabeform, zu vermeiden sind lediglich weitere Stringkonstanten im
Ausdruck, da der Assembler bei der
Gro&szlig;-zu-Kleinbuchstabenumwandlung sonst durcheinanderkommt.
Integer-Ausdr&uuml;cke werden defaultm&auml;&szlig;ig hexadezimal
ausgegeben, dies l&auml;&szlig;t sich jedoch mit dem<TT>
OUTRADIX</TT>-Befehl &auml;ndern.
<P>
Bis auf den Einbau von Formelausdr&uuml;cken ist dieser
Escape-Mechanismus auch in als ASCII definierten Integerkonstanten
zul&auml;ssig, z.B. so:
<PRE>

   move.b   #'\n',d0

</PRE>
Jedoch hat alles seine Grenzen, weil der dar&uuml;berliegende
Splitter, der die Zeile in Opcode und Parameter zerlegt, nicht
wei&szlig;, womit er da eigentlich arbeitet, z.B. hier:
<PRE>

   move.l   #'\'abc',d0

</PRE>
Nach dem dritten Hochkomma findet er das Komma nicht mehr, weil er
vermutet, da&szlig; eine weitere Zeichenkonstante beginnt, und eine
Fehlermeldung &uuml;ber eine falsche Parameterzahl ist die Folge.
Abhilfe w&auml;re z.B., \h anstelle \' zu schreiben.
<P>

<H3><A NAME="sect_2_9_4_">2.9.4. Evaluierung</A></H3>
<P>
Die Berechnung von im Formelausdruck entstehenden Zwischenergebnissen
erfolgt immer mit der h&ouml;chsten verf&uuml;gbaren Wortbreite, d.h.
32 Bit f&uuml;r Ganzzahlen, 80 Bit f&uuml;r Gleitkommazahlen und 255
Zeichen f&uuml;r Strings. Eine eventuelle Pr&uuml;fung auf
Wertebereichs&uuml;berschreitung findet erst am Endergebnis statt.
<P>
Die portable C-Version kann nur mit 64-Bit-Gleitkommazahlen umgehen,     
ist daher auf einen Maximalwert von ca. 10<SUP> 308</SUP>
beschr&auml;nkt. Als Ausgleich werden auf einigen Plattformen
Integers mit 64 Bit Breite behandelt.
<P>

<H3><A NAME="sect_2_9_5_">2.9.5. Operatoren</A></H3>
<P>
Der Assembler stellt zur Verkn&uuml;pfung die in Tabelle <A
HREF="#ref_TabOps">2.11</A> genannten Operanden zur Verf&uuml;gung.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Op.</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>#Ops.</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Int</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Float</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>String</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Rang</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>&lt;&gt;<BR>
&gt;=<BR>
&lt;=<BR>
&lt;<BR>
&gt;<BR>
=<BR>
==<BR>
<BR>
!!<BR>
||<BR>
&amp;&amp;<BR>
  ~~ <BR>
<BR>
-<BR>
+<BR>
#<BR>
/<BR>
  * <BR>
  ^ <BR>
<BR>
!<BR>
|<BR>
&amp;<BR>
&gt;&lt;<BR>
&gt;&gt;<BR>
&lt;&lt;<BR>
  ~ </TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Ungleichheit<BR>
gr&ouml;&szlig;er o. gleich<BR>
kleiner o. gleich<BR>
echt kleiner<BR>
echt gr&ouml;&szlig;er<BR>
Gleichheit<BR>
Alias f&uuml;r =<BR>
<BR>
log. XOR<BR>
log. OR<BR>
log. AND<BR>
log. NOT<BR>
<BR>
Differenz<BR>
Summe<BR>
Modulodivision<BR>
Quotient<BR>
Produkt<BR>
Potenz<BR>
<BR>
bin&auml;res XOR<BR>
bin&auml;res OR<BR>
bin&auml;res AND<BR>
Bitspiegelung<BR>
log. Rechtsschieben<BR>
log. Linksschieben<BR>
bin&auml;res NOT</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
<BR>
<BR>
2<BR>
2<BR>
2<BR>
1<BR>
<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
2<BR>
1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja*)<BR>
ja<BR>
ja<BR>
<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
ja<BR>
ja<BR>
nein<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
ja<BR>
<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
ja<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein<BR>
nein</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>14<BR>
14<BR>
14<BR>
14<BR>
14<BR>
14<BR>
<BR>
<BR>
13<BR>
12<BR>
11<BR>
2<BR>
<BR>
10<BR>
10<BR>
9<BR>
9<BR>
9<BR>
8<BR>
<BR>
7<BR>
6<BR>
5<BR>
4<BR>
3<BR>
3<BR>
1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=7 ALIGN=CENTER>*) Rest wird verworfen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.11: in AS definierte Operatoren<A NAME="ref_TabOps"></A>
</CENTER><P>

Unter ,,Rang'' ist dabei die Priorit&auml;t zu verstehen, die dieser
Operator bei der Teilung eines Ausdruckes in Unterausdr&uuml;cke hat,
der rangh&ouml;chste Operator wird also<I> zuletzt</I> ausgewertet.
Die Reihenfolge der Evaluierung l&auml;&szlig;t sich durch Klammerung
neu festlegen.
<P>
Die Vergleichsoperatoren liefern TRUE, falls die Bedingung zutrifft,
und FALSE falls nicht. Vergleiche betrachten Integerzahlen dabei als
32 Bit breit und vorzeichenbehaftet. F&uuml;r die logischen
Operatoren ist ein Ausdruck TRUE, falls er ungleich 0 ist, ansonsten
FALSE.
<P>
Die Bitspiegelung ist wohl etwas erkl&auml;rungsbed&uuml;rftig: Der
Operator spiegelt die untersten Bits im ersten Operanden,
l&auml;&szlig;t die dar&uuml;berliegenden Bits aber unver&auml;ndert.
Die Zahl der zu spiegelnden Bits ist der rechte Operand und darf
zwischen 1 und 32 liegen.
<P>
Eine keine Fu&szlig;angel beim bin&auml;ren Komplement: Da die
Berechnung grunds&auml;tzlich auf 32- oder 64-Bit-Ebene erfolgt,
ergibt seine Anwendung auf z.B. 8-Bit-Masken &uuml;blicherweise
Werte, die durch voranstehende Einsen nicht mehr im entferntesten in
8-Bit-Zahlen hineinpassen. Eine bin&auml;re UND-Verkn&uuml;pfung mit
einer passenden Maske ist daher unvermeidlich!
<P>

<H3><A NAME="sect_2_9_6_">2.9.6. Funktionen</A></H3>
<P>
Zus&auml;tzlich zu den Operatoren definiert der Assembler noch eine
Reihe in erster Linie transzendenter Funktionen mit
Gleitkommaargument, die Tabellen <A HREF="#ref_TabFuncs1">2.12</A>
und <A HREF="#ref_TabFuncs2">2.13</A> auflisten.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Argument</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Ergebnis</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>SQRT<BR>
<BR>
SIN<BR>
COS<BR>
TAN<BR>
COT<BR>
<BR>
ASIN<BR>
ACOS<BR>
ATAN<BR>
ACOT<BR>
<BR>
EXP<BR>
ALOG<BR>
ALD<BR>
SINH<BR>
COSH<BR>
TANH<BR>
COTH<BR>
<BR>
LN<BR>
LOG<BR>
LD<BR>
ASINH<BR>
ACOSH<BR>
ATANH<BR>
ACOTH<BR>
<BR>
INT<BR>
<BR>
BITCNT<BR>
FIRSTBIT<BR>
LASTBIT<BR>
BITPOS</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Quadratwurzel<BR>
<BR>
Sinus<BR>
Kosinus<BR>
Tangens<BR>
Kotangens<BR>
<BR>
inverser Sinus<BR>
inverser Kosinus<BR>
inverser Tangens<BR>
inverser Kotangens<BR>
<BR>
Exponentialfunktion<BR>
10 hoch Argument<BR>
2 hoch Argument<BR>
hyp. Sinus<BR>
hyp. Kosinus<BR>
hyp. Tangens<BR>
hyp. Kotangens<BR>
<BR>
nat. Logarithmus<BR>
dek. Logarithmus<BR>
2er Logarithmus<BR>
inv. hyp. Sinus<BR>
inv. hyp. Kosinus<BR>
inv. hyp. Tangens<BR>
inv. hyp. Kotangens<BR>
<BR>
ganzzahliger Anteil<BR>
<BR>
bin&auml;re Quersumme<BR>
niedrigstes 1-Bit<BR>
h&ouml;chstes 1-Bit<BR>
einziges 1-Bit</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>arg >= 0<BR>
<BR>
arg in R<BR>
arg in R<BR>
arg <> (2*n+1)*(Pi)/(2)<BR>
arg <> n*Pi<BR>
<BR>
| arg | <= 1<BR>
| arg | <= 1<BR>
arg in R<BR>
arg in R<BR>
<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg in R<BR>
arg <> 0<BR>
<BR>
arg &gt; 0<BR>
arg &gt; 0<BR>
arg &gt; 0<BR>
arg in R<BR>
arg >= 1<BR>
| arg | &lt; 1<BR>
| arg | &gt; 1<BR>
<BR>
arg in R<BR>
<BR>
Integer<BR>
Integer<BR>
Integer<BR>
Integer</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
Gleitkomma<BR>
<BR>
Integer<BR>
<BR>
Integer<BR>
Integer<BR>
Integer<BR>
Integer</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.12: vordefinierte Funktionen in AS - Teil 1 (Integer- und
              Gleitkommafunktionen)<A NAME="ref_TabFuncs1"></A>
</CENTER><P>


<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Argument</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Ergebnis</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>SGN<BR>
<BR>
ABS<BR>
<BR>
TOUPPER<BR>
TOLOWER<BR>
UPSTRING<BR>
<BR>
LOWSTRING<BR>
<BR>
STRLEN<BR>
<BR>
SUBSTR<BR>
<BR>
<BR>
CHARFROMSTR<BR>
<BR>
<BR>
STRSTR<BR>
<BR>
VAL<BR>
<BR>
EXPRTYPE<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Vorzeichen (0/1/-1)<BR>
<BR>
Betrag<BR>
<BR>
pass. Gro&szlig;buchstabe<BR>
pass. Kleinbuchstabe<BR>
wandelt alle Zeichen<BR>
in Gro&szlig;buchstaben<BR>
wandelt alle Zeichen<BR>
in Kleinbuchstaben<BR>
liefert L&auml;nge eines<BR>
Strings<BR>
extrahiert Teil eines<BR>
Strings<BR>
<BR>
extrahiert ein<BR>
Zeichen aus einem<BR>
String<BR>
sucht Teilstring in<BR>
einem String<BR>
evaluiert Stringin-<BR>
halt als Ausdruck<BR>
liefert Typ des<BR>
Arguments<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer oder<BR>
Gleitkomma<BR>
Integer oder<BR>
Gleitkomma<BR>
Integer<BR>
Integer<BR>
String<BR>
<BR>
String<BR>
<BR>
String<BR>
<BR>
String,<BR>
Integer,<BR>
Integer<BR>
String,<BR>
Integer<BR>
<BR>
String,<BR>
String<BR>
String<BR>
<BR>
Integer,<BR>
Gleitkomma,<BR>
String</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
Integer oder<BR>
Gleitkomma<BR>
Integer<BR>
Integer<BR>
String<BR>
<BR>
String<BR>
<BR>
Integer<BR>
<BR>
String<BR>
<BR>
<BR>
Integer<BR>
<BR>
<BR>
Integer<BR>
<BR>
abh. von<BR>
Argument<BR>
0<BR>
1<BR>
2</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 2.13: vordefinierte Funktionen in AS - Teil 2 (Integer- und
              String-Funktionen)<A NAME="ref_TabFuncs2"></A>
</CENTER><P>

Die Funktionen<TT> FIRSTBIT</TT>,<TT> LASTBIT</TT> und<TT>
BITPOS</TT> liefern als Ergebnis -1, falls &uuml;berhaupt kein bzw.
nicht genau ein Bit gesetzt ist. Zus&auml;tzlich gibt<TT> BITPOS</TT>
in einem solchen Fall eine Fehlermeldung aus.
<P>
Die String-Funktion<TT> SUBSTR</TT> erwartet als ersten Parameter den
Quellstring, als zweiten die Startposition und als dritten die Anzahl
zu extrahierender Zeichen (eine 0 bedeutet, alle Zeichen bis zum Ende
zu extrahieren). Analog erwartet<TT> CHARFROMSTR</TT> den Quellstring
als erstes Argument und die Zeichenposition als zweites Argument.
Falls die angegebene Position gr&ouml;&szlig;er oder gleich der
L&auml;nge des Quellstrings ist, liefert<TT> SUBSTR</TT> einen
Leerstring, w&auml;hrend<TT> CHARFROMSTR</TT> eine -1 ergibt. Eine
Position kleiner Null wird von<TT> SUBSTR</TT> als Null behandlet,
w&auml;hrend<TT> CHARFROMSTR</TT> in diesem Fall ebenfalls eine -1
liefert.
<P>
Hier ein Beispiel, wie man die beiden Funktionen einsetzt, um einen
String im Speicher abzulegen, wobei das String-Ende durch ein
gesetztes MSB gekennzeichnet ist:
<P>
<PRE>

dbstr   macro   arg
        if      strlen(arg) &gt; 1
         db     substr(arg, 0, strlen(arg) - 1)
        endif
        if      strlen(arg) &gt; 0
         db     charfromstr(arg, strlen(arg) - 1) | 80h
        endif
        endm

</PRE>
<P>
<TT> STRSTR</TT> liefert das erste Auftreten des zweiten Strings im
ersten bzw. -1, falls das Suchmuster nicht gefunden wurde. Analog
zu<TT> SUBSTR</TT> und<TT> CHARFROMSTR</TT> hat das erste Zeichen den
Positionswert 0.
<P>
Wenn eine Funktion auch Gleitkommaargumente erwartet, so soll dies
nicht bedeuten, da&szlig; man nicht z.B.
<PRE>

wur2   equ      sqrt(2)

</PRE>
schreiben d&uuml;rfte --- in solchen F&auml;llen findet automatisch
eine Typkonvertierung statt. Umgekehrt mu&szlig; allerdings die<TT>
INT</TT>-Funktion angewandt werden, um eine Gleitkommazahl ganz zu
bekommen. Bei der Benutzung dieser Funktion ist zu beachten,
da&szlig; sie als Ergebnis immer einen vorzeichenbehafteten Integer
liefert, sie hat also einen Wertebereich von ca. +/-2.0E9.
<P>
Schaltet man AS in den case-sensitiven Modus, so k&ouml;nnen im
Gegensatz zu vordefinierten Symbolen die vordefinierten Funktionen
weiterhin in beliebiger Schreibweise angesprochen werden. Bei
selbstdefinierten Funktionen (siehe Abschnitt <A
HREF="#ref_SectFUNCTION">3.4.9</A> wird allerdings unterschieden.
Dies hat zur Folge, da&szlig; z.B. bei der Definition einer
Funktion<TT> Sin</TT> man mit<TT> Sin</TT> diese Funktion auch
erreicht, mit allen anderen Schreibweisen jedoch die eingebaute
Funktion.
<P>
F&uuml;r die korrekte Umwandlung von Klein-zu Gro&szlig;buchstaben       
ist eine DOS-Version >= 3.30 erforderlich.
<P>
<P>

<H2><A NAME="sect_2_10_">2.10. Vorw&auml;rtsreferenzen und andere Desaster</A></H2>
<A NAME="ref_ForwRefs"></A>                                              
<P>
Dieser Abschnitt ist das Produkt eines gewissen Grolls auf die
(durchaus legale) Art und Weise, wie einige Leute programmieren, die
in Zusammenhang mit AS bisweilen das eine oder andere Problem
verursachen kann. Die Rede ist hier von sogenannten
,,Vorw&auml;rtsreferenzen''. Was unterscheidet eine
Vorw&auml;rtsreferenz von einer normalen Referenz? Dazu sehe man sich
folgendes Programmbeispiel an (man sehe mir bitte meine -- auch im
Rest dieser Anleitung anzutreffende -- 68000-Lastigkeit nach):
<PRE>

        move.l  #10,d0
loop:   move.l  (a1),d1
        beq     skip
        neg.l   d1
skip:   move.l  d1,(a1+)
        dbra    d0,loop

</PRE>
Denkt man sich den Scheifenrumpf mit dem Sprung weg, so bleibt ein
&auml;u&szlig;erst angenehm zu assemblierendes Programm &uuml;brig:
die einzige Referenz ist der R&uuml;cksprung zum Anfang des Rumpfes,
und da ein Assembler ein Programm von vorne nach hinten
durcharbeitet, hat er den Symbolwert bereits ermittelt, bevor er ihn
zum erstem Mal ben&ouml;tigt. Sofern man ein Programm hat, das nur
solche R&uuml;ckw&auml;rtsreferenzen besitzt, ist man in der
angenehmen Lage, nur einmal durch den Quellcode gehen zu m&uuml;ssen,
um den korrekten und optimalen Maschinencode zu finden. Einige
Hochsprachen wie Pascal mit ihrer strikten Regel, da&szlig; alles vor
der ersten Benutzung definiert sein mu&szlig;, nutzen genau diese
Eigenschaft aus, um den &uuml;bersetzungsvorgang zu beschleunigen.
<P>
Leider ist die Sache im Falle von Assembler nicht so einfach, denn
man will ja bisweilen auch vorw&auml;rts im Code springen oder
mu&szlig; aus bestimmten Gr&uuml;nden Variablendefinitionen hinter
den Code verlegen. Dies ist im Beispiel der Fall f&uuml;r den
bedingten Sprung, mit dem ein anderer Befehl &uuml;bersprungen wird.
Wenn der Assembler im ersten Durchlauf auf den Sprungbefehl trifft,
so sieht er sich mit der Situation konfrontiert, entweder die
Teilfelder der Instruktion, die die Sprungadresse beinhalten,
leerzulassen, oder seitens des Formelparsers (der das
Adre&szlig;argument ja auswerten mu&szlig;) anstelle des korrekten,
aber unbekannten Wertes einen Wert anzubieten, der ,,niemandem
wehtut''. Bei einem einfachen Assembler, der nur eine Zielarchitektur
kennt und bei dem sich die betroffenen Befehle an einer Hand
abz&auml;hlen lassen, wird man sicher die erste Variante w&auml;hlen,
bei AS mit seinen vielen Dutzend Zielen w&auml;re die Zahl der
Sonderabfragen aber extrem hoch geworden, so da&szlig; nur der zweite
Weg in Frage kam: Falls im ersten Pass ein unbekanntes Symbol
auftaucht, so liefert der Formelparser den momentanen Stand des
Programmz&auml;hlers als Ergebnis zur&uuml;ck! Nur dieser Wert ist
geeignet, relativen Spr&uuml;ngen mit Sprungdistanzen unbekannter
L&auml;nge eine Adresse anzubieten, die nicht zu Fehlern f&uuml;hrt.
Dies beantwortet auch die bisweilen gestellte Frage, warum in einem
Listing des ersten Passes (dies bleibt z.B. stehen, wenn AS aufgrund
anderer Fehler den zweiten Pass erst gar nicht beginnt), z.T. falsche
Adressen im erzeugten Bin&auml;rcode gezeigt werden - dies sind noch
nicht aufgel&ouml;ste Vorw&auml;rtsreferenzen.
<P>
Das obige Beispiel offenbart allerdings noch eine weitere
Schwierigkeit von Vorw&auml;rtsreferenzen: Je nach Abstand von Quelle
und Ziel im Code kann der Sprungbefehl entweder lang oder kurz sein.
Diese Entscheidung &uuml;ber die Code-L&auml;nge - und damit auch die
Adressen folgender Labels - kann jedoch mangels genauer Kenntnis der
Zieladresse im ersten Pass nicht erfolgen. Sofern der Programmierer
nicht explizit kenntlich gemacht hat, ob der Sprung lang oder kurz
sein soll, behelfen sich reine 2-Pass-Assembler wie &auml;ltere
MASM-Versionen von Microsoft damit, im ersten Pass (nach diesem
m&uuml;ssen alle Adressen festliegen) Platz f&uuml;r die l&auml;ngste
Version zu reservieren und im zweiten Pass den
&uuml;bersch&uuml;ssigen Platz mit<TT> NOP</TT>s aufzuf&uuml;llen.
AS-Versionen bis 1.37 taten dieses ebenfalls, danach bin ich auf das
Multipass-Verfahren &uuml;bergegangen, das die strenge Einteilung in
zwei Passes aufhebt und beliebig viele Durchg&auml;nge erlaubt. Dazu
wird im ersten Pass der optimale Code mit den angenommenen
Symbolwerten erzeugt. Stellt AS fest, da&szlig; im zweiten Pass durch
Codel&auml;ngenver&auml;nderungen sich Werte von Symbolen
ge&auml;ndert haben, so wird einfach noch ein dritter Pass eingelegt,
und da durch die neuen Symbolwerte des zweiten Passes auch im dritten
Pass sich der Code wieder verk&uuml;rzen oder verl&auml;ngern kann,
ist ein weiterer Pass nicht unm&ouml;glich. Ich habe schon
8086-Programme erlebt, bei denen erst nach 12 Durchg&auml;ngen alles
stimmte. Leider erlaubt dieser Mechanismus nicht die Vorgabe einer
Maximalzahl von Durchl&auml;ufen, ich kann als Regel nur sagen,
da&szlig; die Anzahl von Durchl&auml;ufen sinkt, je mehr man davon
Gebrauch macht, Sprung- oder Adre&szlig;l&auml;ngen explizit
vorzugeben.
<P>
Speziell bei gro&szlig;en Programmen kann es zu einer interessanten
Situation kommen: Die Lage eines vorw&auml;rts gerichteten Sprunges
hat sich im zweiten Pass so weit gegen&uuml;ber dem ersten
verschoben, da&szlig; der jetzt noch benutzte Label-Wert aus dem
ersten Pass au&szlig;erhalb der erlaubten Sprungdistanz liegt. AS
ber&uuml;cksichtigt solche Situationen, indem er jegliche
Fehlermeldungen &uuml;ber zu weite Sprungdistanzen unterdr&uuml;ckt,
sobald er erkannt hat, da&szlig; er wegen sich &auml;ndernder
Symbolwerte ohnehin einen weiteren Durchlauf machen mu&szlig;. Dies
funktioniert zwar in 99% aller F&auml;lle, es gibt jedoch auch
Konstrukte, in denen der erste, derartig kritische Befehl bereits
auftaucht, bevor AS eine Chance hat, zu erkennen, da&szlig; ein neuer
Pass erforderlich ist. Das folgende Beispiel konstruiert eine solche
Situation mit Hilfe einer Vorw&auml;rtsreferenz (und war der
Anla&szlig; f&uuml;r die &Uuml;berschrift dieses Abschnitts...):
<PRE>

        cpu   6811

        org     $8000
        beq     skip
        rept    60
         ldd    Var
        endm
skip:   nop

Var     equ     $10

</PRE>
Aufgrund der Adre&szlig;lage nimmt AS im ersten Pass lange Adressen
f&uuml;r die<TT> LDD</TT>-Befehle an, was eine Code-L&auml;nge von
180 Bytes ergibt und im zweiten Pass (zum Zeitpunkt des<TT>
BEQ</TT>-Befehls ist noch der ,,falsche'' Wert von<TT> skip</TT>
aktuell, d.h. AS wei&szlig; zu diesem Zeitpunkt noch nicht, da&szlig;
der Code in Wirklichkeit nur 120 Bytes lang ist) gibt es eine
Fehlermeldung wegen einer &uuml;berschrittenen Sprungdistanz. Dieser
Fehler l&auml;&szlig;t sich auf drei Arten vermeiden:
<OL>
<LI>Weisen Sie AS explizit darauf hin, da&szlig; er f&uuml;r die<TT>
    LDD</TT>-Befehle kurze Adressen verwenden darf (<TT>ldd
    &lt;Var</TT>)</LI>
<LI>Entfernen Sie diese vermaledeite, verfluchte Vorw&auml;rtsreferenz
    und setzen Sie die<TT> EQU</TT>-Anweisung nach vorne, wo sie
    hingeh&ouml;rt (OK, ich beruhige mich ja schon wieder...)</LI>
<LI>F&uuml;r ganz Unentwegte: Benutzten Sie die<TT> -Y</TT>-Option, so
    da&szlig; AS die Fehlermeldung beim Erkennen der
    Adre&szlig;verschiebung nachtr&auml;glich verwirft. Nicht
    sch&ouml;n, aber...</LI>
</OL>
Noch ein Hinweis zum<TT> EQU</TT>-Befehl: Da AS nicht wissen kann, in
welchem Zusammenhang ein mit<TT> EQU</TT> definiertes Symbol
sp&auml;ter verwendet wird, wird ein<TT> EQU</TT> mit
Vorw&auml;rtsreferenzen im ersten Pass &uuml;berhaupt nicht
durchgef&uuml;hrt. Wird das mit<TT> EQU</TT> definierte Symbol also
im zweiten Pass vorw&auml;rts referenziert:
<PRE>

        move.l  #sym2,d0
sym2    equ     sym1+5
sym1    equ     0

</PRE>
so handelt man sich im zweiten Pass eine Fehlermeldung wegen eines
undefinerten Symbols ein...aber warum machen Leute eigentlich solche
Dinge ???
<P>
Zugegeben, das war ein ziemlich l&auml;nglicher Ausflug, aber es
mu&szlig;te einfach einmal sein. Was sollte man als Erkenntnis aus
diesem Abschnitt mitnehmen?
<OL>
<LI>AS versucht immer, den k&uuml;rzestm&ouml;glichen Code zu erzeugen.
    Dazu ben&ouml;tigt er eine endliche Zahl von Durchl&auml;ufen.
    Wenn man ihn nicht gerade knebelt, kennt AS keine
    R&uuml;cksichten...</LI>
<LI>Wenn sinnvoll und m&ouml;glich, Sprung- und Adre&szlig;l&auml;ngen
    explizit vorgeben. Man kann damit u.U. die Anzahl der
    Durchl&auml;ufe deutlich reduzieren.</LI>
<LI>Vorw&auml;rtsreferenzen auf das allern&ouml;tigste beschr&auml;nken.
    Man erleichtert sich und AS das Leben damit erheblich!</LI>
</OL>
<P>

<H2><A NAME="sect_2_11_">2.11. Registersymbole</A></H2>
<A NAME="ref_SectRegSyms"></A><A NAME="index_Registersymbole_1"></A>
<P>
<EM> G&uuml;ltigkeit: PowerPC, M-Core, 4004/4040, 80C16x, AVR</EM>
<P>
Manchmal ist es erw&uuml;nscht, nicht nur einer Speicheradresse oder
einer Konstanten, sondern auch einem Register einen symbolischen
Namen zuzuweisen, um seine Funktion in einem bestimmten
Programmabschnitt zu verdeutlichen. Dies ist bei Prozessoren, die die
Register schlicht als einen weiteren Adre&szlig;raum behandeln, recht
problemlos, da als Register damit auch Zahlenausdr&uuml;cke erlaubt
sind und man solche Symbole mit schlichten<TT> EQU</TT>s definieren
kann (z.B. bei MCS-96 oder TMS7000). Bei den allermeisten Prozessoren
jedoch sind Registernamen festgelegte Literale, und AS behandelt sie
aus Geschwindigkeitsgr&uuml;nden gesondert, so da&szlig; ein
besonderer Mechanismus vonn&ouml;ten ist, um symbolische Register zu
definieren. Ein Registersymbol wird &uuml;blicherweise durch die<TT>
REG</TT>-Anweisung definiert und hat ansonsten die gleiche Form wie
eine<TT> EQU</TT>-Definition. Sie unterliegt jedoch einer Reihe von
Einschr&auml;nkungen: Zum einen ist ein Registersymbol eine reine 'as
is' gespeicherte Zeichenkette, die auch nur in dieser Form verwendet
werden kann. Es ist also z.B. keine Arithmetik m&ouml;glich, um aus
einem Register den Nachfolger zu berechnen, etwa so:
<PRE>

myreg   reg     r17         ; Definition Registersymbol
        addi    myreg+1,3   ; geht nicht!

</PRE>
Zum anderen mu&szlig; ein Registersymbol vor seiner ersten Nutzung
definiert werden; eine Vorw&auml;rtsreferenz w&uuml;rde dazu
f&uuml;hren, da&szlig; AS bei nicht gefundenem Registersymbol eine
Vorw&auml;rtsreferenz auf eine Speicherstelle vermutet, und bei den
meisten Prozessoren sind die Nutzungsm&ouml;glichkeiten f&uuml;r
Speicherstellen als Operanden deutlich eingeschr&auml;nkter als
f&uuml;r Register, so da&szlig; es mit ziemlicher Sicherheit Fehler
hagelt...
<P>
Registersymbole sind analog zu normalen Symbolen lokal zu Sektionen,
und es ist auch durch Anh&auml;ngen eines in eckige Klammern
gesetzten Sektionsnamens m&ouml;glich, auf ein Registersymbol aus
einer bestimmten Sektion zuzugreifen. Aufgrund der fehlenden
M&ouml;glichkeit zur Vorw&auml;rtsreferenz gibt es aber keine
Entsprechung zur<TT> FORWARD</TT>-Direktive, und da Registersymbole
im allgemeinen nur in einem sehr eng umschr&auml;nkten Kontext eine
Bedeutung haben, ist ein Export per<TT> PUBLIC</TT> oder<TT>
GLOBAL</TT> auch nicht vorgesehen.
<P>
Sind in einem Kontext ein normales als auch ein Registersymbol
gleichen Namens bekannt, so wird immer das Registersymbol vorgezogen.
Dies ist aber nicht der Fall, wenn der Name nicht alleine, sondern
eingebunden in einen Ausdruck steht (dazu reichen Klammern!), dann
wird das normale Symbol benutzt.
<P>

<H2><A NAME="sect_2_12_">2.12. Sharefile</A></H2>
<A NAME="ref_ChapShareMain"></A><A NAME="index_SHARED_2"></A>
<P>
Diese Funktion ist ein Abfallprodukt aus den reinen
68000er-Vorg&auml;ngern von AS, da sie vielleicht doch der (die?!)
eine oder andere gebrauchen k&ouml;nnte, habe ich sie dringelassen.
Grundproblem ist es, an bestimmte beim Assemblieren entstehende
Symbole heranzukommen, weil man evtl. mit diesen
Adre&szlig;informationen auf den Speicher des Zielsystems zugreifen
m&ouml;chte. Der Assembler erlaubt es, mit Hilfe des<TT>
SHARED</TT>-Pseudobefehles (siehe dort) Symbolwerte extern zur
Verf&uuml;gung zu stellen. Zu diesem Zweck erstellt der Assembler im
zweiten Pass eine Textdatei mit den gew&uuml;nschten Symbolen und
ihren Werten, die mittels Include in ein Hochsprachen-oder weiteres
Assemblerprogramm eingebunden werden k&ouml;nnen. Das Format der
Textdatei (C, Pascal oder Assembler) wird durch die
Kommandozeilenschalter<TT> p</TT>,<TT> c</TT> oder<TT> a</TT>
festgelegt.
<P>
<B> ACHTUNG!</B> Ist keiner dieser Schalter angegeben, so wird auch
keine Datei erzeugt, egal ob sich<TT> SHARED</TT>-Befehle im
Quelltext finden oder nicht!
<P>
AS pr&uuml;ft beim Anlegen der Share-Datei nicht, ob bereits eine
Datei gleichen Namens existiert, eine solche wird ggfs. einfach
&uuml;berschrieben. Eine Abfrage halte ich nicht f&uuml;r sinnvoll,
da AS dann bei jedem Lauf fragen w&uuml;rde, ob er die alte Version
der Share-Datei &uuml;berschreiben darf, und das w&auml;re doch sehr
l&auml;stig...
<P>

<H2><A NAME="sect_2_13_">2.13. Prozessor-Aliasse</A></H2>
<A NAME="ref_SectAlias"></A>
<P>
Mit Varianten g&auml;ngiger Mikrocontroller-Familien ist es wie mit
Kaninchen: Sie vermehren sich schneller, als man mit der Versorgung
hinterherkommen kann. Im Zuge der Entwicklung von Prozessorkernen als
Bausteine f&uuml;r ASICs und von Controller-Familien mit vom Kunden
w&auml;hlbarer Peripherie wird die Zahl von Controller-Varianten, die
sich von einem bekannten Typ nur in einigen Peripherie-Details
unterscheiden, immer gr&ouml;&szlig;er. Die Unterscheidung der
einzelnen Typen ist aber trotz meist identischer Prozessorkernes
wichtig, um z.B. in den Includefiles den korrekten Satz von
Peripherieregistern einzublenden. Bisher habe ich mich zwar immer
bem&uuml;ht, die wichtigsten Vertreter einer Familie in AS einzubauen
(und werde das auch weiter tun), aber manchmal l&auml;uft mir die
Entwicklung einfach auf und davon...es mu&szlig;te also ein
Mechanismus her, mit dem man die Liste der unterscheidbaren
Prozessortypen selbst erweitern kann.
<P>
Das Ergebnis davon sind Prozessor-Aliasse: Mit der
Kommandozeilenoption<TT> alias</TT> kann man einen neuen Prozessortyp
definieren, der im Befehlssatz einem anderen, in AS fest eingebauten
Typ entspricht. Bei Benutzung dieses Typs im<TT> CPU</TT>-Befehl wird
sich AS also wie beim ,,Original'' verhalten, mit einem Unterschied:
Die Variablen<TT> MOMCPU</TT> bzw.<TT> MOMCPUNAME</TT> werden auf den
Namen des Alias gesetzt, wodurch der neue Name zur Unterscheidung
z.B. in Includefiles dienen kann.
<P>
Die Definition dieser Aliasse wurde aus zwei Gr&uuml;nden mit
Kommandozeilenoptionen anstatt Pseudobefehlen vorgenommen: zum einen
w&auml;re es ohnehin nicht m&ouml;glich gewesen, die Definition der
Aliasse zusammen mit den Registerdefinitionen in eine Include-Datei
zu legen, denn in einem Programm, das so eine Datei benutzen wollte,
m&uuml;&szlig;te sie ja sowohl vor als auch nach dem<TT>
CPU</TT>-Befehl in der Hauptdatei eingebunden werden - eine
Vorstellung, die irgendwo zwischen unelegant und unm&ouml;glich
liegt. Zum zweiten erm&ouml;glicht diese Implementierung, die
Definition der neuen Typen in eine Datei zu legen, die &uuml;ber
die<TT> ASCMD</TT>-Variable beim Start automatisch ausgef&uuml;hrt
wird, ohne das sich das Programm darum k&uuml;mmern m&uuml;&szlig;te.
<P>

<H1><A NAME="sect_3_">3. Pseudobefehle</A></H1>
<P>
Nicht f&uuml;r alle Prozessoren sind alle Pseudobefehle definiert.
Vor der Beschreibung eines Befehls ist deshalb jeweils vermerkt,
f&uuml;r welche Prozessortypen dieser Befehl erlaubt ist.
<P>

<H2><A NAME="sect_3_1_">3.1. Definitionen</A></H2>
<P>

<H3><A NAME="sect_3_1_1_">3.1.1. SET, EQU und CONSTANT</A></H3>
<A NAME="index_SET_1"></A><A NAME="index_EQU_1"></A><A
NAME="index_CONSTANT_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren,<TT> CONSTANT</TT> nur
KCPSM(3)</EM>
<P>
<TT> SET</TT> und<TT> EQU</TT> erlauben die Definition typenloser
Konstanten, d.h. sie werden keinem Segment zugeordnet und ihre
Verwendung erzeugt in keinem Fall eine Warnung wegen
Segmentverquickung. W&auml;hrend<TT> EQU</TT> Konstanten definiert,
die nicht wieder (mit<TT> EQU</TT>) ge&auml;ndert werden k&ouml;nnen,
erlaubt<TT> SET</TT> die Definition von Variablen, die sich
w&auml;hrend des Assemblerlaufes ver&auml;ndern lassen. Dies ist
n&uuml;tzlich z.B. bei der Allokation von Resourcen &agrave; la
Interruptvektoren, wie im folgenden Beispiel:
<PRE>

VecCnt  SET     0         ; irgendwo am Anfang
        ...
DefVec  MACRO   Name      ; einen neuen Vektor belegen
Name    EQU     VecCnt
VecCnt  SET     VecCnt+4
        ENDM
        ...
        DefVec  Vec1      ; ergibt Vec1=0
        DefVec  Vec2      ; ergibt Vec2=4

</PRE>
Intern werden Konstanten und Variablen identisch gespeichert, der
einzige Unterschied ist, da&szlig; sie als unver&auml;nderbar
markiert werden, wenn sie mit<TT> EQU</TT> definiert werden. Der
Versuch, eine Konstante mit<TT> SET</TT> zu ver&auml;ndern, gibt eine
Fehlermeldung.
<P>
Mit<TT> EQU/SET</TT> lassen sich Konstanten aller Typen definieren,
z.B.
<PRE>

IntZwei   EQU   2
FloatZwei EQU   2.0

</PRE>
Einige Prozessoren besitzen leider bereits selber einen<TT>
SET</TT>-Befehl. Bei diesen mu&szlig;<TT> EVAL</TT> anstelle von<TT>
SET</TT> verwendet werden.
<P>
Anstelle von<TT> EQU</TT> darf auch einfach ein Gleichheitszeichen
geschrieben werden, analog kann man anstelle von<TT> SET</TT>
bzw.<TT> EVAL</TT> einfach<TT> :=</TT> schreiben.
<P>
Aus Kompatibilit&auml;tsgr&uuml;nden zum Originalassembler gibt es
f&uuml;r das KCPSM-Target auch den<TT> CONSTANT</TT>-Befehl, der im
Gegensatz zu<TT> EQU</TT> Namen und Wert als Argument erwartet, also
z.B. so:
<PRE>

      CONSTANT  const1, 2

</PRE>
<TT> CONSTANT</TT> ist allerdings auf Integer-Konstanten
beschr&auml;nkt.
<P>
Defaultm&auml;&szlig;ig sind mit<TT> SET</TT> oder<TT> EQU</TT>
definierte Symbole typenlos, optional kann jedoch als zweites
Argument ein Segmentname (<TT>CODE, DATA, IDATA, XDATA, YDATA,
BITDATA, IO oder REG</TT>) oder<TT> MOMSEGMENT</TT> f&uuml;r das
aktuell gesetzte Segment angegeben werden, um das Symbol einem
bestimmten Adre&szlig;raum zuordnen. AS ber&uuml;cksichtigt dabei
nicht, ob der benutzte Adre&szlig;raum bei dem aktuell gesetzten
Zielprozessor auch vorhanden ist!
<P>

<H3><A NAME="sect_3_1_2_">3.1.2. SFR und SFRB</A></H3>
<A NAME="index_SFR_1"></A><A NAME="index_SFRB_1"></A>
<P>
<EM> G&uuml;ltigkeit: diverse, SFRB nur MCS-51</EM>
<P>
Diese Befehle funktionieren wie<TT> EQU</TT>, nur sind die damit
definierten Symbole dem direkt adressierbaren Datensegment
zugeordnet, d.h. sie dienen bevorzugt zur Definition von RAM-Zellen
und (wie der Name ahnen l&auml;&szlig;t) im Datenbereich
eingeblendeten Hardwareregistern. Der dabei zugelassene Wertebereich
ist identisch mit dem bei<TT> ORG</TT> f&uuml;r das<TT>
DATA</TT>-Segment zugelassenen (s. Abschnitt <A
HREF="#ref_SectORG">3.2.1</A>).<TT> SFR</TT> und<TT> SFRB</TT>
unterscheiden sich darin, da&szlig;<TT> SFRB</TT> das Register als
bitadressierbar kennzeichnet, weshalb AS zus&auml;tzlich 8 Symbole
erzeugt, die dem Bitsegment zugeordnet werden und die Namen<TT>
xx.0</TT> bis<TT> xx.7</TT> tragen, z.B.
<PRE>

PSW     SFR     0d0h   ; ergibt PSW = D0H (Datensegment)

PSW     SFRB    0d0h   ; zusaetzlich PSW.0 = D0H (Bit)
                       ; bis PSW.7 = D7H (Bit)

</PRE>
Da beim 80C251 grunds&auml;tzlich alle SFRs ohne zus&auml;tzliche
Bit-Symbole bitadressierbar sind, ist der<TT> SFRB</TT>-Befehl
f&uuml;r ihn auch nicht mehr definiert; die Bits<TT> PSW.0</TT>
bis<TT> PSW.7</TT> sind automatisch vorhanden.
<P>
AS &uuml;berpr&uuml;ft bei der Definition eines bitadressierbaren
Registers mit<TT> SFRB</TT>, ob die Speicherstelle &uuml;berhaupt
bitadressierbar ist (Bereich 20h..3fh bzw. 80h, 88h, 90h,
98h...0f8h). Ist sie es nicht, so wird eine Warnung ausgegeben; die
dann erzeugten Bit-Symbole sind undefiniert.
<P>

<H3><A NAME="sect_3_1_3_">3.1.3. XSFR und YSFR</A></H3>
<A NAME="index_XSFR_1"></A><A NAME="index_YSFR_1"></A>
<P>
<EM> G&uuml;ltigkeit: DSP56xxx</EM>
<P>
Auch der DSP56000 hat einige Peripherieregister memory-mapped im
Speicher liegen, die Sache wird jedoch dadurch komplizierter,
da&szlig; es zwei Datenbereiche gibt, den X-und Y-Bereich. Diese
Architektur erlaubt einerseits zwar einen h&ouml;heren
Parallelit&auml;tsgrad, zwingt jedoch andererseits dazu, den
normalen<TT> SFR</TT>-Befehl in die beiden oben genannten Varianten
aufzuspalten. Sie verhalten sich identisch zu<TT> SFR</TT>, nur
da&szlig;<TT> XSFR</TT> ein Symbol im X-Adre&szlig;raum definiert
und<TT> YSFR</TT> entsprechend eines im Y-Adre&szlig;raum. Der
erlaubte Wertebereich ist 0..$ffff.
<P>

<H3><A NAME="sect_3_1_4_">3.1.4. LABEL</A></H3>
<A NAME="index_LABEL_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Die Funktion des<TT> LABEL</TT>-Befehls ist identisch zu<TT>
EQU</TT>, nur wird das Symbol nicht typenlos, sondern erh&auml;lt das
Attribut ,,Code''.<TT> LABEL</TT> wird genau f&uuml;r einen Zweck
ben&ouml;tigt: Labels in Makros sind normalerweise lokal, also nicht
au&szlig;erhalb des Makros zugreifbar. Mit einem<TT> EQU</TT>-Befehl
kann man sich zwar aus der Aff&auml;re ziehen, die Formulierung
<PRE>

&lt;Name&gt;   label    $

</PRE>
erzeugt aber ein Symbol mit korrekten Attributen.
<P>

<H3><A NAME="sect_3_1_5_">3.1.5. BIT</A></H3>
<A NAME="index_BIT_1"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-(2)51, XA, 80C166, 75K0, ST9</EM>
<P>
<TT> BIT</TT> dient dazu, ein einzelnes Bit einer Speicherstelle mit
einem symbolischen Namen gleichzusetzen. Da die Art und Weise, wie
verschiedene Prozessoren Bitverarbeitung und -adressierung betreiben,
stark variiert, verh&auml;lt sich auch dieser Befehl je nach
Zielplattform anders:
<P>
F&uuml;r die MCS/51-Familie, die einen eigenen Adre&szlig;raum
f&uuml;r Bitoperanden besitzt, ist die Funktion von<TT> BIT</TT> ganz
analog zu<TT> SFR</TT>, d.h. es wird einfach ein Integer-Symbol mit
dem angegebenen Wert und dem Segment BDATA erzeugt. F&uuml;r alle
anderen Prozessoren wird die Bitadressierung dagegen zweidimensional
mit Adresse und Bitstelle vorgenommen. In diesem Fall verpackt AS
beide Teile in einer vom jeweiligen Prozessor abh&auml;ngigen Weise
in ein Integer-Symbol und dr&ouml;selt dieses bei der Benutzung
wieder in die beiden Teile auseinander. Letzterer Fall trifft auch
schon f&uuml;r den 80C251 zu: W&auml;hrend zum Beispiel der Befehl
<PRE>

Mein_Carry	bit	PSW.7

</PRE>
auf einem 8051 noch dem Symbol<TT> Mein_Carry</TT> den Wert 0d7h
zuweisen w&uuml;rde, w&uuml;rde auf einem 80C251 dagegen ein Wert von
070000d0h generiert werden, d.h. die Adresse steht in Bit 0..7 sowie
die Bitstelle in Bit 24..26. Dieses Verfahren entspricht dem, das
auch beim DBIT- Befehl des TMS370 angewendet wird und funktioniert
sinngem&auml;&szlig; so auch beim 80C166, nur da&szlig; dort
Bitstellen von 0 bis 15 reichen d&uuml;rfen:
<PRE>

MSB     BIT     r5.15

</PRE>
Beim Philips XA findet sich in Bit 0..9 die Bitadresse, wie sie auch
in die Maschinenbefehle eingesetzt wird, f&uuml;r Bits aus den
RAM-Speicher wird in Bit 16..23 die 64K-Bank eingesetzt.
<P>
Noch etwas weiter geht der<TT> BIT</TT>-Befehl bei der 75K0-Familie:
Da dort Bitadressierungen nicht nur absolute Basisadressen verwenden
d&uuml;rfen, sind sogar Ausdr&uuml;cke wie
<PRE>

bit1    BIT     @h+5.2

</PRE>
erlaubt.
<P>
Beim ST9 ist es hingegen m&ouml;glich, Bits auch invertiert
anzusprechen, was beim<TT> BIT</TT>-Befehl auch ber&uuml;cksichtigt
wird:
<PRE>

invbit  BIT     r6.!3

</PRE>
N&auml;heres zum<TT> BIT</TT>-Befehl beim ST9 findet sich bei den
prozessorspezifischen Hinweisen.
<P>

<H3><A NAME="sect_3_1_6_">3.1.6. DBIT</A></H3>
<A NAME="index_DBIT_1"></A>
<P>
<EM> G&uuml;ltigkeit: TMS 370xxx</EM>
<P>
Die TMS370-Reihe hat zwar kein explizites Bit-Segment, jedoch
k&ouml;nnen einzelne Bits als Symbol durch diesen Befehl simuliert
werden.<TT> DBIT</TT> ben&ouml;tigt zwei Operanden, n&auml;mlich
einmal die Adresse der Speicherstelle, in der das Bit liegt, sowie
die genaue Position des Bits im Byte. So definiert man z.B. mit
<PRE>

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

</PRE>
das Bit, welches Interrupts von Anschlu&szlig; INT3 freigibt. So
definierte Bits k&ouml;nnen dann von den Befehlen<TT> SBIT0, SBIT1,
CMPBIT, JBIT0</TT> und<TT> JBIT</TT> genutzt werden.
<P>

<H3><A NAME="sect_3_1_7_">3.1.7. PORT</A></H3>
<A NAME="index_PORT_1"></A>
<P>
<EM> G&uuml;ltigkeit: 8080/8085/8086, XA, Z80, 320C2x/5x, TLCS-47,
AVR</EM>
<P>
<TT> PORT</TT> arbeitet analog zu<TT> SFR</TT>, nur wird das Symbol
dem I/O-Adre&szlig;bereich zugeordnet. Erlaubte Werte sind 0..7 beim
3201x, 0..15 beim 320C2x, 0..65535 beim 8086 und 320C5x, 0..63 beim
AVR und 0..255 beim Rest.
<P>
Beispiel: eine PIO 8255 liege auf Adresse 20H:
<PRE>

PIO_Port_A PORT 20h
PIO_Port_B PORT PIO_Port_A+1
PIO_Port_C PORT PIO_Port_A+2
PIO_Ctrl   PORT PIO_Port_A+3

</PRE>
<P>

<H3><A NAME="sect_3_1_8_">3.1.8. REG und NAMEREG</A></H3>
<A NAME="index_REG_1"></A><A NAME="index_NAMEREG_1"></A>
<P>
<EM> G&uuml;ltigkeit: AVR, M*Core, ST9, 80C16x, KCPSM (<TT>
NAMEREG</TT> nur f&uuml;r KCPSM(3)), LatticeMico8</EM>
<P>
Obwohl immer mit gleicher Syntax, hat diese Anweisung von Prozessor
zu Prozessor eine leicht abweichende Bedeutung: Falls der
Zielprozessor f&uuml;r Register einen eigenen Adre&szlig;raum
verwendet, so hat<TT> REG</TT> die Wirkung eines simplen<TT>
EQU</TT>s f&uuml;r eben diesen Adre&szlig;raum (z.B. beim ST9).
F&uuml;r alle anderen Prozessoren definiert<TT> REG</TT>
Registersymbole, deren Funktion in Abschnitt <A
HREF="#ref_SectRegSyms">2.11</A> beschrieben sind.
<P>
<TT> NAMEREG</TT> existiert aus Kompatibilit&auml;tsgr&uuml;nden zum
Originalassembler f&uuml;r den KCPSM. Es hat die gleiche Funktion,
lediglich werden sowohl Register- als auch symbolischer Name als
Argumente angegeben, z.B. so:
<PRE>

     NAMEREG  s08, treg

</PRE>
<P>

<H3><A NAME="sect_3_1_9_">3.1.9. LIV und RIV</A></H3>
<A NAME="index_LIV_1"></A><A NAME="index_RIV_1"></A>
<P>
<EM> G&uuml;ltigkeit: 8X30x</EM>
<P>
<TT> LIV</TT> und<TT> RIV</TT> dienen dazu, sogenannte IV-Bus-Objekte
zu definieren. Bei diesen handelt es sich um Bitgruppen in peripheren
Speicherzellen mit einer L&auml;nge von 1..8 Bit, die fortan
symbolisch angesprochen werden k&ouml;nnen, so da&szlig; man bei den
entsprechenden Befehlen nicht mehr Adresse, L&auml;nge und Position
separat angeben mu&szlig;. Da die 8X30x-Prozessoren zwei periphere
Adre&szlig;r&auml;ume besitzen (einen ,,linken'' und einen
,,rechten'', sind auch zwei separate Befehle definiert. Die Parameter
dieser Befehle sind allerdings identisch: es m&uuml;ssen drei
Parameter sein, die Adresse, Startposition und L&auml;nge angeben.
Weitere Hinweise zur Benutzung von Busobjekten finden sich in
Abschnitt <A HREF="#ref_8X30xSpec">4.17</A>.
<P>

<H3><A NAME="sect_3_1_10_">3.1.10. CHARSET</A></H3>
<A NAME="index_CHARSET_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Einplatinensysteme, zumal wenn sie LCDs ansteuern, benutzen
h&auml;ufig einen anderen Zeichensatz als ASCII, und da&szlig; die
Umlautkodierung mit der im PC &uuml;bereinstimmt, d&uuml;rfte wohl
reiner Zufall sein. Um nun aber keine fehlertr&auml;chtigen
Handumkodierungen vornehmen zu m&uuml;ssen, enth&auml;lt der
Assembler eine Umsetzungstabelle f&uuml;r Zeichen, die jedem
Quellcode ein Zielzeichen zuordnet. Zur Modifikation dieser Tabelle
(die initial 1:1 &uuml;bersetzt), dient der Befehl<TT>
CHARSET</TT>.<TT> CHARSET</TT> kann mit verschiedenen Parameterzahlen
und -typen angewendet werden. Ist die Parameterzahl eins, so
mu&szlig; es sich um einen String-Ausdruck handeln, der von AS als
Dateiname interpretiert wird. Aus dieser Datei liest AS dann die
ersten 256 Bytes aus und kopiert sie in die &Uuml;bersetzungstabelle.
Hiermit lassen sich also komplexere, extern erzeugte Tabellen in
einem Schlag aktivieren. In allen anderen Varianten mu&szlig; der
erste Parameter ein Integer im Bereich von 0 bis 255 sein, der den
Startpunkt der in der &Uuml;bersetzungstabelle zu modifizierenden
Eintr&auml;ge angibt. Es folgen dann ein oder zwei weitere Parameter,
die die Art der &Uuml;bersetzung angeben:
<P>
Ein einzelner, weiterer Integer ver&auml;ndert genau einen Eintrag.
So bedeutet z.B.
<BLOCKQUOTE>
    <TT> CHARSET '&auml;',128</TT>
</BLOCKQUOTE>
da&szlig; das Zielsystem das &auml; mit der Zahl 128 kodiert. Sind
jedoch zwei weitere Integers angegeben, so ist der erste von ihnen
der letzte zu modifizierende Eintrag, der zweite der neue Wert des
ersten Eintrags; alle weiteren Eintr&auml;ge bis zum Bereichsende
werden sequentiell neu belegt. Falls z.B. das Zielsystem keine
Kleinbuchstaben unterst&uuml;tzt, k&ouml;nnen mit
<PRE>

        CHARSET 'a','z','A'

</PRE>
alle Kleinbuchstaben auf die passenden Gro&szlig;buchstaben
automatisch umgemappt werden.
<P>
In der letzten Variante folgt nach dem Startindex ein String, der die
ab dem Startindex abzulegenden Zeichen angibt. Das letzte Beispiel
k&ouml;nnte man also auch so formulieren:
<PRE>

        CHARSET 'a',"ABCDEFGHIJKLMNOPQRSTUVWXYZ"

</PRE>
<P>
<TT> CHARSET</TT> kann auch ganz ohne Parameter aufgerufen werden,
allerdings mit ziemlich gr&uuml;ndlichen Folgen: Dies bewirkt eine
Reinitialisierung der &Uuml;bersetzungstabelle in ihren Urzustand,
d.h. man bekommt wieder eine 1:1-&Uuml;bersetzung.
<P>
<B> ACHTUNG!</B><TT> CHARSET</TT> beeinflu&szlig;t nicht nur im
Speicher abgelegte Stringkonstanten, sondern auch als ,,ASCII''
formulierte Integerkonstanten. Dies bedeutet, da&szlig; eine evtl.
bereits modifizierte Umsetzungstabelle in den obigen Beispielen zu
anderen Ergebnissen f&uuml;hren kann!
<P>

<H3><A NAME="sect_3_1_11_">3.1.11. CODEPAGE</A></H3>
<A NAME="index_CODEPAGE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit der<TT> CHARSET</TT>-Anweisung hat man zwar beliebige Freiheiten
in der Zeichenzuordnung zwischen Entwicklungs- und Zielplattform,
wenn auf der Zielplattform jedoch verschiedene Zeichens&auml;tze
existieren, kann das Umschalten zwischen diesen jedoch zu einer
umst&auml;ndlichen Orgie von<TT> CHARSET</TT>-Kommandos werden. Mit
der<TT> CODEPAGE</TT>-Anweisung kann man jedoch mehrere
Zeichentabellen vorhalten und zwischen diesen mit einem Befehl
umschalten. Als Parameter erwartet<TT> CODEPAGE</TT> ein oder zwei
Namen: zum einen den Namen der fortan zu benutzenden Tabelle, zum
anderen optional den Namen der Tabelle, die die initiale Belegung der
Tabelle vorgibt (dieser Parameter hat somit auch nur eine Bedeutung
beim ersten Umschalten auf eine Tabelle, bei der AS sie automatisch
anlegt). Fehlt der zweite Parameter, so ist die initiale Belegung der
neuen Tabelle gleich der vorher aktiven Tabelle. Alle folgenden<TT>
CHARSET</TT>-Anweisungen ver&auml;ndern<EM> nur</EM> die momentan
aktive Tabelle.
<P>
Zu Beginn eines Durchlaufes wird von AS automatisch eine einzelne
Zeichentabelle mit dem Namen<TT> STANDARD</TT> erzeugt und 1:1
vorbelegt. Verwendet man keine<TT> CODEPAGE</TT>-Anweisungen, so
beziehen sich alle mit<TT> CHARSET</TT> gemachten Einstellungen auf
diese Tabelle.
<P>

<H3><A NAME="sect_3_1_12_">3.1.12. ENUM</A></H3>
<A NAME="index_ENUM_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ENUM</TT> dient analog zu dem entsprechenden Befehl in C dazu,
Aufz&auml;hlungstypen zu definieren, d.h. eine Reihe von
Integer-Konstanten, denen fortlaufende Werte (von 0 an beginnend)
zugewiesen werden. Als Parameter werden dabei die Namen der zu
definierenden Symbole angegeben, wie in dem folgenden Beispiel:
<BLOCKQUOTE>
    <TT> ENUM SymA,SymB,SymC</TT>
</BLOCKQUOTE>
Dieser Befehl weist den Symbolen<TT> SymA</TT>,<TT> SymB</TT> und<TT>
SymC</TT> die Werte 0, 1 und 2 zu.
<P>
<TT> ENUM</TT>-Befehle sind von Hause aus einzeilig, d.h. bei einem
neuen<TT> ENUM</TT>-Befehl beginnt die Numerierung wieder bei Null.
Mehrzeilige Aufz&auml;hlungen kann man aber mit einem kleinen Trick
erreichen, der die Tatsache ausnutzt, da&szlig; man mit einer
expliziten Zuweisung den internen Z&auml;hler neu setzen kann, wie in
dem folgenden Fall:
<BLOCKQUOTE>
    <TT> ENUM Januar=1,Februar,M&auml;rz,April,Mai,Juni</TT>
</BLOCKQUOTE>
Hier werden den Monatsnamen die Zahlenwerte 1..6 zugewiesen.
M&ouml;chte man die Aufz&auml;hlung nun fortsetzen, geht das
folgenderma&szlig;en:
<BLOCKQUOTE>
    <TT> ENUM Juli=Juni+1,August,September,Oktober<BR>
    ENUM November=Oktober+1,Dezember</TT>
</BLOCKQUOTE>
Die Definition von Symbolen mit<TT> ENUM</TT> gleicht einer
Definition mit<TT> EQU</TT>, d.h. es ist nicht m&ouml;glich, einem
Symbol einen neuen Wert zuzuweisen.
<P>

<H3><A NAME="sect_3_1_13_">3.1.13. PUSHV und POPV</A></H3>
<A NAME="index_PUSHV_1"></A><A NAME="index_POPV_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit<TT> PUSHV</TT> und<TT> POPV</TT> ist es m&ouml;glich, den Wert
von (nicht makrolokalen) Symbolen tempor&auml;r zu speichern und zu
einem sp&auml;teren Zeitpunkt wiederherzustellen. Die Speicherung
erfolgt auf<EM> Stacks</EM>, d.h. Last-In-First-Out-Speichern. Ein
Stack hat einen Namen, der den allgemeinen Symbolkonventionen
gen&uuml;gen mu&szlig;, und existiert so lange, wie er mindestens ein
Element enth&auml;lt: Ein bisher nicht existierender Stack wird
bei<TT> PUSHV</TT> automatisch angelegt, ein durch<TT> POPV</TT> leer
werdender Stack wird automatisch wieder aufgel&ouml;st. Der Name des
Stacks, auf den Symbole abgelegt und von dem sie wieder abgeholt
werden sollen, ist der erste Parameter von<TT> PUSHV</TT> bzw.<TT>
POPV</TT>, danach folgt eine beliebige Menge von Symbolen als weitere
Parameter. Alle in der Liste aufgef&uuml;hrten Symbole m&uuml;ssen
bereits existieren, es ist also<EM> nicht</EM> m&ouml;glich, mit
einem<TT> POPV</TT>-Befehl implizit neue Symbole zu definieren.
<P>
Stacks stellen eine globale Ressource dar, d.h. ihre Namen sind nicht
lokal zu Sektionen.
<P>
Wichtig ist, da&szlig; die Variablenliste<EM> immer</EM> von links
nach rechts abgearbeitet wird. Wer also mehrere Variablen mit<TT>
POPV</TT> von einem Stack herunterholen will, mu&szlig; diese in
genau umgekehrter Reihenfolge zum entsprechenden<TT> PUSHV</TT>
angeben!
<P>
Der Name des Stacks kann auch weggelassen werden, etwa so:
<PRE>

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

</PRE>
AS verwendet dann einen internen, vordefinierten Default-Stack.
<P>
Nach Ende eines Durchlaufes &uuml;berpr&uuml;ft AS, ob noch Stacks
existieren, die nicht leer sind, und gibt deren Namen sowie
,,F&uuml;llstand'' aus. Mit diesen Warnungen kann man herausfinden,
ob an irgendeiner Stelle die<TT> PUSHV</TT>'s und<TT> POPV</TT>'s
nicht paarig sind. Es ist jedoch in keinem Fall m&ouml;glich,
Symbolwerte in einem Stack &uuml;ber mehrere Durchl&auml;ufe
hinwegzuretten: Zu Beginn eines Durchlaufes werden alle Stacks
geleert!
<P>

<H2><A NAME="sect_3_2_">3.2. Codebeeinflussung</A></H2>
<P>

<H3><A NAME="sect_3_2_1_">3.2.1. ORG</A></H3>
<A NAME="ref_SectORG"></A><A NAME="index_ORG_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ORG</TT> erlaubt es, den assemblerinternen
Adre&szlig;z&auml;hler mit einem neuen Wert zu besetzen. Der
Wertebereich ist vom momentan gew&auml;hlten Segment und vom
Prozessortyp abh&auml;ngig (Tabellen <A HREF="#ref_TabORG1">3.1</A>
bis <A HREF="#ref_TabORG4">3.4</A>). Die untere Grenze ist dabei
immer 0; die obere Grenze der angegebene Wert minus eins.
<P>
Falls in einer Familie verschiedene Varianten unterschiedlich
gro&szlig;e Adre&szlig;r&auml;ume haben, ist jeweils der maximale
Raum aufgef&uuml;hrt.
<P>
ORG wird in erster Linie ben&ouml;tigt, um dem Code eine neue
Startadresse zu geben und damit verschiedene, nicht
zusammenh&auml;ngende Codest&uuml;cke in einer Quelldatei
unterzubringen. Sofern nicht in einem Feld explizit anders angegeben,
ist die vorgegebene Startadresse in einem Segment (d.h. die ohne<TT>
ORG</TT> angenommene) immer 0.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Ziel</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> CODE</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> XDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> YDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> BITDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IO</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> REG</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> ROMDATA</SMALL></SMALL></TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68xxx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> DSP56000/</SMALL></SMALL><BR>
<SMALL><SMALL> DSP56300</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K/<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PowerPC</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M*Core</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6800,6301,</SMALL></SMALL><BR>
<SMALL><SMALL> 6811</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6805/</SMALL></SMALL><BR>
<SMALL><SMALL> HC08</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K/<BR>
64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6809,</SMALL></SMALL><BR>
<SMALL><SMALL> 6309</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68HC12(X),</SMALL></SMALL><BR>
<SMALL><SMALL> XGATE</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68HC16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68RS08</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> H8/300</SMALL></SMALL><BR>
<SMALL><SMALL> H8/300H</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> H8/500</SMALL></SMALL><BR>
<SMALL><SMALL> (Min)</SMALL></SMALL><BR>
<SMALL><SMALL> H8/500</SMALL></SMALL><BR>
<SMALL><SMALL> (Max)</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SH7000/</SMALL></SMALL><BR>
<SMALL><SMALL> 7600/7700</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6502,</SMALL></SMALL><BR>
<SMALL><SMALL> MELPS740</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 65816,</SMALL></SMALL><BR>
<SMALL><SMALL> MELPS-</SMALL></SMALL><BR>
<SMALL><SMALL> 7700</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MELPS-</SMALL></SMALL><BR>
<SMALL><SMALL> 4500</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>416<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M16</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> M16C</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.1: Adre&szlig;bereiche f&uuml;r<TT> ORG</TT> --- Teil 1<A
             NAME="ref_TabORG1"></A>
</CENTER><P>


<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Ziel</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> CODE</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> XDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> YDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> BITDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IO</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> REG</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> ROMDATA</SMALL></SMALL></TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 4004</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8008</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-48,</SMALL></SMALL><BR>
<SMALL><SMALL> MCS-41</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-51</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<SUP>*</SUP><BR>
<SMALL><SMALL> In. 80H</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80C390</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<SUP>*</SUP><BR>
<SMALL><SMALL> In. 80H</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-251</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MCS-96</SMALL></SMALL><BR>
<SMALL><SMALL> 196(N)/</SMALL></SMALL><BR>
<SMALL><SMALL> 296</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8080,</SMALL></SMALL><BR>
<SMALL><SMALL> 8085</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80x86,</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 68xx0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 8X30x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 2650</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> XA</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
<SMALL><SMALL> In. 1K</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> AVR</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 29XXX</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 80C166,</SMALL></SMALL><BR>
<SMALL><SMALL> 80C167</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256K<BR>
16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Z80,</SMALL></SMALL><BR>
<SMALL><SMALL> Z180,</SMALL></SMALL><BR>
<SMALL><SMALL> Z380</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
512K<SUP>+</SUP><BR>
4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
256<BR>
4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Z8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> eZ8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> KCPSM</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=10 ALIGN=LEFT><SUP>*</SUP> Da der 8051 kein RAM jenseits 80h hat, mu&szlig; der Initialwert f&uuml;r den 8051<BR>
als Zielprozessor auf jeden Fall mit<TT> ORG</TT> angepa&szlig;t werden!!</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP COLSPAN=10 ALIGN=LEFT><SUP>+</SUP> Da der Z180 weiterhin logisch nur 64K ansprechen kann, ist der<BR>
ganze Adre&szlig;raum nur mittels<TT> PHASE</TT>-Anweisungen erreichbar!</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.2: Adre&szlig;bereiche f&uuml;r<TT> ORG</TT> --- Teil 2<A
             NAME="ref_TabORG2"></A>
</CENTER><P>


<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Ziel</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> CODE</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> XDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> YDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> BITDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IO</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> REG</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> ROMDATA</SMALL></SMALL></TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> KCPSM3</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Mico8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4096</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 900(L)</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-90</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 870</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-47</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TLCS-</SMALL></SMALL><BR>
<SMALL><SMALL> 9000</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C5x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C5x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>32<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 16C64,</SMALL></SMALL><BR>
<SMALL><SMALL> 16C86</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
8K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
512<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><BR>
---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> PIC</SMALL></SMALL><BR>
<SMALL><SMALL> 17C42</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST6</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST7</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ST9</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 6804</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 32010</SMALL></SMALL><BR>
<SMALL><SMALL> 32015</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K<BR>
4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>144<BR>
256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8<BR>
8</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C2x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C3x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 320C5x/</SMALL></SMALL><BR>
<SMALL><SMALL> 320C20x/</SMALL></SMALL><BR>
<SMALL><SMALL> 320C54x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS</SMALL></SMALL><BR>
<SMALL><SMALL> 9900</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.3: Adre&szlig;bereiche f&uuml;r<TT> ORG</TT> --- Teil 3<A
             NAME="ref_TabORG3"></A>
</CENTER><P>


<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> Ziel</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> CODE</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> DATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> XDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> YDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> BITDATA</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> IO</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> REG</SMALL></SMALL></TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER><SMALL><SMALL> ROMDATA</SMALL></SMALL></TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> TMS</SMALL></SMALL><BR>
<SMALL><SMALL> 70Cxx</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 370xxx</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> MSP430</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> SC/MP</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 807x</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> COP4</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> COP8</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> ACE</SMALL></SMALL><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K<BR>
<SMALL><SMALL> In. 800H/</SMALL></SMALL><BR>
<SMALL><SMALL> 0C00H</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> &micro;PD</SMALL></SMALL><BR>
<SMALL><SMALL> 78(C)10</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 75K0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 78K0</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7720</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>128<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 7725</SMALL></SMALL><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>2K<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>256<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1024<BR>
</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 77230</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>8K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>512</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>1K</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> 53C8XX</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>4G</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> F<SUP>2</SUP></SMALL></SMALL>MC8L</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>64K</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><SMALL><SMALL> F<SUP>2</SUP></SMALL></SMALL>MC16L</SMALL></SMALL></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>16M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>---</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.4: Adre&szlig;bereiche f&uuml;r<TT> ORG</TT> --- Teil 4<A
             NAME="ref_TabORG4"></A>
</CENTER><P>

<P>

<H3><A NAME="sect_3_2_2_">3.2.2. CPU</A></H3>
<A NAME="index_CPU_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit diesem Befehl wird festgelegt, f&uuml;r welchen Prozessor im
weiteren Code erzeugt werden soll. Die Befehle der anderen
Prozessorfamilien sind dann nicht greifbar und erzeugen eine
Fehlermeldung!
<P>
Die Prozessoren k&ouml;nnen grob in Familien unterschieden werden, in
den Familien dienen unterschiedliche Typen noch einmal zur
Feinunterscheidung:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> a)</TD><TD NOWRAP> 68008 -> 68000 -> 68010 -> 68012 -></TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> MCF5200 -> 68332 -> 68340 -> 68360 -></TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 68020 -> 68030 -> 68040</TD></TR>
</TABLE></BLOCKQUOTE>
In dieser Familie liegen die Unterschiede in hinzukommenden Befehlen
und Adressierungsarten (ab 68020). Eine kleine Ausnahme stellt der
Schritt zum 68030 dar, dem 2 Befehle fehlen:<TT> CALLM</TT> und<TT>
RTM</TT>. Die drei Vertreter der 683xx-Famile haben den gleichen
Prozessorkern (eine leicht abgemagerte 68020-CPU), jedoch v&ouml;llig
unterschiedliche Peripherie. MCF5200 repr&auml;sentiert die
ColdFire-Familie von Motorola, zum 680x0 bin&auml;r
abw&auml;rtskompatible RISC-Prozesoren. Beim 68040 kommen die
zus&auml;tzlichen Steuerregister (via<TT> MOVEC</TT> erreichbar)
f&uuml;r On-Chip-MMU und Caches sowie einige Systembefehle f&uuml;r
selbige hinzu.
<BLOCKQUOTE>
    b) 56000 --> 56002 --> 56300
</BLOCKQUOTE>
W&auml;hrend der 56002 nur Befehle zum Inkrementieren und
Dekrementieren der Akkus erg&auml;nzt, ist der 56300-Kern schon fast
ein neuer Prozessor: Er vergr&ouml;&szlig;ert alle
Adre&szlig;r&auml;ume von 64K-W&ouml;rtern auf 16M und verdoppelt
fast die Anzahl der Befehle.
<BLOCKQUOTE>
    c) PPC403 -> PPC403GC -> MPC505 -> MPC601 -> RS6000
</BLOCKQUOTE>
Der PCC403 ist eine abgespeckte Version der PowerPC-Linie ohne
Gleitkommaeinheit, demzufolge sind s&auml;mtliche Gleitkommabefehle
bei ihm gesperrt; daf&uuml;r sind einige mikrocontrollerspezifische
Befehle enthalten, die er als einziges Mitglied in dieser Familie
kennt. Die GC-Variante des PPC403 hat zus&auml;tzlich eine MMU und
deshalb einige Befehle zu deren Steuerung mehr. Der MPC505 (eine
Mikrokontroller-Variante mit FPU) unterscheidet sich solange vom
601er nur in den Peripherieregistern, wie ich es nicht besser
wei&szlig; - <A HREF="#cite_Mot505">[58]</A> h&auml;lt sich da noch
etwas bedeckt... Die RS6000-Reihe kennt noch einige Befehle mehr (die
auf vielen 601er-Systemen emuliert werden, um vollst&auml;ndige
Kompatibilit&auml;t herzustellen), au&szlig;erdem verwendet IBM z.T.
andere Mnemonics f&uuml;r diese reinen Workstation-Prozessoren, als
Remineszenz an die 370er-Gro&szlig;rechner...
<BLOCKQUOTE>
    d) MCORE
</BLOCKQUOTE>
<BLOCKQUOTE>
    e) XGATE
</BLOCKQUOTE>
<BLOCKQUOTE>
    f) 6800 -> 6301 -> 6811
</BLOCKQUOTE>
W&auml;hrend der 6301 nur neue Befehle definiert, liefert der 6811
neben weiteren Befehlen ein zweites Indexregister Y zur Adressierung.
<BLOCKQUOTE>
    g) 6809/6309 und 6805/68HC08/68HCS08
</BLOCKQUOTE>
Diese Prozessoren sind zwar teilweise quellcodekompatibel zu den
anderen 68xx-ern, haben aber ein anderes Bin&auml;rcodeformat und
einen deutlich eingeschr&auml;nkteren (6805) bzw. erweiterten (6809)
Befehlssatz. Der 6309 ist eine CMOS-Version des 6809, die zwar
offiziell nur kompatibel zum 6809 ist, inoffiziell aber mehr Register
und deutlich mehr Befehle besitzt (siehe <A
HREF="#cite_Kaku">[37]</A>).
<BLOCKQUOTE>
    h) 68HC12 --> 68HC12X
</BLOCKQUOTE>
Der 12X-Kern bietet eine Reihe neuer Befehle, bzw. bestehende Befehle
wurden um neue Adressierungsarten erg&auml;nzt.
<BLOCKQUOTE>
    i) 68HC16
</BLOCKQUOTE>
<BLOCKQUOTE>
    j) HD6413308 --> HD6413309
</BLOCKQUOTE>
Diese beiden Namen repr&auml;sentieren die 300er und 300H-Varianten
der H8-Familie; die H-Version besitzt dabei einen gr&ouml;&szlig;eren
Adre&szlig;raum (16 Mbyte statt 64Kbyte), doppelt so breite Register
(32 Bit) und kennt einige zus&auml;tzliche Befehle und
Adressierungsarten. Trotzdem ist sie bin&auml;r
aufw&auml;rtskompatibel.
<BLOCKQUOTE>
    k) HD6475328 --> HD6475348 --> HD6475368 --> HD6475388
</BLOCKQUOTE>
Diese Prozessoren besitzen alle den gleichen CPU-Kern; Die unter-
schiedlichen Typen dienen lediglich der Einbindung des korrekten
Registersatzes in der Datei<TT> REG53X.INC</TT>.
<BLOCKQUOTE>
    l) SH7000 --> SH7600 --> SH7700
</BLOCKQUOTE>
Der Prozessorkern des 7600ers bietet eine Handvoll Befehle mehr, die
L&uuml;cken im Befehlssatz des 7000ers schlie&szlig;en
(verz&ouml;gerte, bedingte sowie relative und indirekte Spr&uuml;nge,
Multiplikationen mit 32-Bit-Operanden sowie
Multiplizier/Addier-Befehle). Die 7700er-Reihe (auch als SH3
gel&auml;ufig) bietet weiterhin eine zweite Registerbank, bessere
Schiebebefehle sowie Befehle zur Cache-Steuerung.
<BLOCKQUOTE>
    m) 6502 -> 65(S)C02 / MELPS740
</BLOCKQUOTE>
Die CMOS-Version definiert einige zus&auml;tzliche Befehle,
au&szlig;erdem sind bei einigen Befehlen Adressierungsarten
hinzugekommen, die beim 6502 nicht m&ouml;glich waren. Die
Mitsubishi-Mikrokontroller dagegen erweitern den 6502-Befehlssatz in
erster Linie um Bitoperationen und Multiplikations-/Divisionsbefehle.
Bis auf den unbedingten Sprung und Befehle zur
Inkrementierung/Dekremetierung des Akkumulatos sind die Erweiterungen
disjunkt. Dem 65SC02 fehlen die Bitmanipulationsbefehle des 65C02.
Mit dem Prozessortyp 6502UNDOC sind die ,,undokumentierten''
6502-Befehle erreichbar, d.h. die Operationen, die sich bei der
Verwendung nicht als Befehle definierter Bitkombinationen im Opcode
ergeben. Die von AS unterst&uuml;tzten Varianten sind im Kapitel mit
den prozessorspezifischen Hinweisen beschrieben.
<BLOCKQUOTE>
    n) MELPS7700, 65816
</BLOCKQUOTE>
Neben einer ,,16-Bit-Version'' des 6502-Befehlssatzes bieten diese
Prozessoren einige Befehlserweiterungen. Diese sind aber
gr&ouml;&szlig;erenteils disjunkt, da sie sich an ihren jeweiligen
8-bittigen Vorbildern (65C02 bzw. MELPS-740) orientieren. Z.T.~werden
auch andere Mnemonics f&uuml;r gleiche Befehle verwendet.
<BLOCKQUOTE>
    o) MELPS4500
</BLOCKQUOTE>
<BLOCKQUOTE>
    p) M16
</BLOCKQUOTE>
<BLOCKQUOTE>
    q) M16
</BLOCKQUOTE>
<BLOCKQUOTE>
    r) 4004 -> 4040
</BLOCKQUOTE>
Der 4040 besitzt gegen&uuml;ber seinem Vorg&auml;nger ein gutes
Dutzend zus&auml;tzlicher Maschineninstruktionen.
<BLOCKQUOTE>
    s) 4008 -> 8008NEW
</BLOCKQUOTE>
Intel hat 1975 die Mnemonics des umdefiniert, die zweite Variante
spiegelt diesen neuen Befehlssatz wieder. Eine gleichzeitige
Unterst&uuml;tzung beider Varianten war nicht m&ouml;glich, da
teilweise &Uuml;berschneidungen vorliegen.
<BLOCKQUOTE>
    t) 8021, 8022, 8039, 80C39, 8048, 80C48, 8041, 8042
</BLOCKQUOTE>
Bei den ROM-losen Versionen 8039 und 80C39 sind die Befehle verboten,
die den BUS (Port 0) ansprechen. Der 8021 und 8022 sind
Sonderversionen mit stark abgemagertem Befehlssatz, wof&uuml;r der
8022 zwei A/D-Wandler und die dazugeh&ouml;rigen Steuerbefehle
enth&auml;lt. Die CMOS-Versionen lassen sich mit dem<TT>
IDL</TT>-Befehl in einen Ruhezustand niedriger Stromaufnahme
&uuml;berf&uuml;hren. Der 8041 und 8042 haben einige Zusatzbefehle
zur Steuerung der Busschnittstelle, daf&uuml;r fehlen aber einige
andere Befehle. Dar&uuml;ber hinaus ist bei diesen Prozessoren der
Programmadre&szlig;raum nicht extern erweiterbar, weshalb AS das
Codesegment bei diesen Prozessoren auf 1 bzw. 2 Kbyte begrenzt.
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> u)</TD><TD NOWRAP> 87C750 -> 8051, 8052, 80C320, 80C501, 80C502,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 80C504, 80515, and 80517</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> -> 80C390</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> -> 80C251</TD></TR>
</TABLE></BLOCKQUOTE>
Der 87C750 kann nur max. 2 Kbyte Programmspeicher adressieren,
weshalb die<TT> LCALL</TT>- und<TT> LJMP</TT>-Befehle bei ihm fehlen.
Zwischen den acht mittleren Prozessoren nimmt AS selber
&uuml;berhaupt keine Unterscheidung vor, sondern verwaltet den
Unterschied lediglich in der Variablen<TT> MOMCPU</TT> (s.u.), die
man mit<TT> IF</TT>-Befehlen abfragen kann. Eine Ausnahme stellt
lediglich der 80C504, der in seiner momentanen Form noch einen
Maskenfehler zeigt, wenn eine<TT> AJMP</TT>- oder<TT>
ACALL</TT>-Anweisung auf der vorletzten Adresse einer 2K-Seite steht.
AS benutzt in einem solchen Fall automatisch lange Sprungbefehle bzw.
gibt eine Fehlermeldung aus. Der 80C251 hingegen stellt einen
drastischen Fortschritt in Richtung 16/32 Bit, gr&ouml;&szlig;erer
Adre&szlig;r&auml;ume und orthogonalerem Befehlssatz dar. Den 80C390
k&ouml;nnte man vielleicht als die 'kleine L&ouml;sung' bezeichnen:
Dallas Semiconductor hat den Befehlssatz und die Architektur nur so
weit ver&auml;ndert, wie es f&uuml;r die 16 MByte gro&szlig;en
Adre&szlig;r&auml;ume notwendig war.
<BLOCKQUOTE>
    v) 8096 -> 80196 -> 80196N -> 80296
</BLOCKQUOTE>
Neben einem anderen Satz von SFRs (die &uuml;brigens von Unterversion
zu Unterversion stark differieren) kennt der 80196 eine Reihe von
zus&auml;tzlichen Befehlen und kennt einen ,,Windowing''-Mechanismus,
um das gr&ouml;&szlig;ere interne RAM anzusprechen. Die
80196N-Familie wiederum erweitert den Adre&szlig;raum auf 16 Mbyte
und f&uuml;hrt eine Reihe von Befehlen ein, mit denen man auf
Adressen jenseits 64 Kbyte zugreifen kann. Der 80296 erweitert den
CPU-Kern um Befehle zur Signalverarbeitung und ein zweites
Windowing-Register, verzichtet jedoch auf den<EM> Peripheral
Transaction Server</EM> (PTS) und verliert damit wieder zwei
Maschinenbefehle.
<BLOCKQUOTE>
    w) 8080 -> 8085 -> 8085UNDOC
</BLOCKQUOTE>
Der 8085 kennt zus&auml;tzlich die Befehle<TT> RIM</TT> und<TT>
SIM</TT> zum Steuern der Interruptmaske und der zwei I/O-Pins. Der
Typ<TT> 8085UNDOC</TT> schaltet zus&auml;tzliche, nicht von Intel
dokumentierte Befehle ein. Diese Befehle sind in Abschnitt <A
HREF="#ref_8085Spec">4.15</A> dokumentiert.
<BLOCKQUOTE>
    x) 8086 -> 80186 -> V30 -> V35
</BLOCKQUOTE>
Hier kommen wieder nur neue Befehle dazu. Die entsprechenden 8-Bitter
sind wegen ihrer Befehlskompatibilit&auml;t nicht aufgef&uuml;hrt,
f&uuml;r ein 8088-System ist also z.B. 8086 anzugeben.
<BLOCKQUOTE>
    y) 80960
</BLOCKQUOTE>
<BLOCKQUOTE>
    z) 8X300 -> 8X305
</BLOCKQUOTE>
Der 8X305 besitzt eine Reihe zus&auml;tzlicher Arbeitsregister, die
dem 8X300 fehlen und kann mit diesen auch zus&auml;tzliche
Operationen ausf&uuml;hren, wie das direkte Schreiben von
8-Bit-Werten auf Peripherieadressen.
<BLOCKQUOTE>
    aa) XAG1, XAG2, XAG3
</BLOCKQUOTE>
Diese Prozessoren unterscheiden sich nur in der Gr&ouml;&szlig;e des
eingebauten ROMs, die in<TT> STDDEFXA.INC</TT> definiert ist.
<BLOCKQUOTE>
    ab) AT90S1200 -> AT90S2313 -> AT90S4414 -> AT90S8515 -> ATMEGA8
    -> ATMEGA16
</BLOCKQUOTE>
Der erste Vertreter der AVR-Reihe stellt die Minimalkonfiguration
dar, ohne RAM-Speicher und demzufolge auch ohne Load/Store-Befehle.
Die n&auml;chsten drei Prozessoren unterscheiden sich nur im
Speicherausbau und in der eingebauten Peripherie, was in<TT>
REGAVR.INC</TT> differenziert wird. &Auml;hnlich verh&auml;lt es sich
mit den Mega-AVRs, die gegen&uuml;ber den Vorg&auml;ngern aber auch
neue Maschinenbefehle mitbringen.
<BLOCKQUOTE>
    ac) AM29245 -> AM29243 -> AM29240 -> AM29000
</BLOCKQUOTE>
Je weiter man sich in der Liste nach rechts bewegt, desto weniger
Befehle m&uuml;ssen in Software emuliert werden. W&auml;hrend z.B.
der 29245 noch nicht einmal einen Hardware-Multiplizierer besitzt,
fehlen den beiden Vertretern in der Mitte nur die Gleitkommabefehle.
Der 29000 dient dabei als ,,generischer'' Typ, der alle Befehle in
Hardware versteht.
<BLOCKQUOTE>
    ad) 80C166 --> 80C167,80C165,80C163
</BLOCKQUOTE>
80C167 und 80C165/163 haben anstelle 256 Kbyte max. 16 Mbyte
Adre&szlig;raum, au&szlig;erdem kennen sie einige zus&auml;tzliche
Befehle f&uuml;r erweiterte Adressierungsmodi sowie atomare
Befehlssequenzen. Untereinander unterscheiden sich diese Prozessoren
der ,,zweiten Generation'' nur in der eingebauten Peripherie.
<BLOCKQUOTE>
    ae) Z80 -> Z80UNDOC -> Z180 -> Z380
</BLOCKQUOTE>
W&auml;hrend f&uuml;r den Z180 nur die zus&auml;tzlichen Befehle
definiert sind (d.h. die Z180-MMU findet noch keine
Ber&uuml;cksichtigung), besitzt der Z380 32-Bit-Register, einen
linearen 4Gbyte-Adre&szlig;raum sowie neben einer Reihe von
Befehlserweiterungen, die den Befehlssatz deutlich orthogonaler
machen, neue Adressierungsmodi (Ansprechen der
Indexregisterh&auml;lften, Stack-relativ). Zu einem kleinen Teil
existieren diese Erweiterungen aber auch schon beim Z80 als
undokumentierte Befehle, die mit der Variante<TT> Z80UNDOC</TT>
zugeschaltet werden k&ouml;nnen. Eine Liste mit den zus&auml;tzlichen
Befehlen findet sich im Kapitel mit den prozessorspezifischen
Hinweisen.
<BLOCKQUOTE>
    af) Z8601, Z8604, Z8608, Z8630, Z8631 -> eZ8
</BLOCKQUOTE>
Die Varianten mit Z8-Kern unterscheiden sich nur in Speicherausbau
und Peripherie, d.h. die Wahl hat auf den unterst&uuml;tzten
Befehlssatz keinen Effekt. Deutlich anders ist jedoch der eZ8, mit
einem stark erweiterten Befehlssatz, der auch nur auf Quellebene
weitestgehens aufw&auml;rts-kompatibel ist.
<BLOCKQUOTE>
    ag) KCPSM, KCPSM3
</BLOCKQUOTE>
Bei beiden Prozessorkernen handelt es sich um keine
eigenst&auml;ndigen Bausteine, sondern Logik-Kerne f&uuml;r
Gate-Arrays der Firma Xilinx. Die 3er-Variante bietet einen
gr&ouml;&szlig;eren Adre&szlig;raum sowie einige zus&auml;tzliche
Instruktionen. Es ist zu beachten, da&szlig; sie nicht bin&auml;r
aufw&auml;rtskompatibel ist!
<BLOCKQUOTE>
    ah) MICO8
</BLOCKQUOTE>
<BLOCKQUOTE>
    ai) 96C141, 93C141
</BLOCKQUOTE>
Diese beiden Prozessoren repr&auml;sentieren die beiden Varianten der
Prozessorfamilie: TLCS-900 und TLCS-900L. Die Unterschiede dieser
beiden Varianten werden in Abschnitt <A
HREF="#ref_TLCS900Spec">4.22</A> genauer beleuchtet.
<BLOCKQUOTE>
    aj) 90C141
</BLOCKQUOTE>
<BLOCKQUOTE>
    ak) 87C00, 87C20, 87C40, 87C70
</BLOCKQUOTE>
Die Prozessoren der TLCS-870-Reihe haben zwar den identischen
CPU-Kern, je nach Variante aber eine unterschiedliche
Peripherieausstattung. Zum Teil liegen Register gleichen Namens auf
unterschiedlichen Adressen. Die Datei STDDEF87.INC benutzt analog zur
MCS-51-Familie die hier m&ouml;gliche Unterscheidung, um automatisch
den korrekten Symbolsatz bereitzustellen.
<BLOCKQUOTE>
    al) 47C00 -> 470C00 -> 470AC00
</BLOCKQUOTE>
Diese drei Varianten der TLCS-47-Familie haben unterschiedlich
gro&szlig;e RAM-und ROM-Adre&szlig;bereiche, wodurch jeweils einige
Befehle zur Bankumschaltung hinzukommen oder wegfallen.
<BLOCKQUOTE>
    am) 97C241
</BLOCKQUOTE>
<BLOCKQUOTE>
    an) 16C54 -> 16C55 -> 16C56 -> 16C57
</BLOCKQUOTE>
Diese Prozessoren unterscheiden sich durch den verf&uuml;gbaren
Adre&szlig;raum im Programmspeicher, d.h. durch die Adresse, ab der
der AS &Uuml;berl&auml;ufe anmeckert.
<BLOCKQUOTE>
    ao) 16C64, 16C84
</BLOCKQUOTE>
Analog zur MCS-51-Familie findet hier keine Unterscheidung im
Codegenerator statt, die unterschiedlichen Nummern dienen lediglich
der Einblendung der korrekten SFRs in STDDEF18.INC.
<BLOCKQUOTE>
    ap) 17C42
</BLOCKQUOTE>
<BLOCKQUOTE>
    aq) ST6210/ST6215 -> ST6220/ST6225
</BLOCKQUOTE>
Die einzige Unterscheidung, die AS zwischen den beiden Paaren
vornimmt, ist der bei den ersten beiden kleinere Adre&szlig;raum (2K
anstelle 4K). Die Feinunterscheidung dient zur automatischen
Unterscheidung in der Quelldatei, welche Hardware jeweils vorhanden
ist (analog zum 8051/52/515).
<BLOCKQUOTE>
    ar) ST7
</BLOCKQUOTE>
<BLOCKQUOTE>
    as) ST9020, ST9030, ST9040, ST9050
</BLOCKQUOTE>
Diese 4 Namen vetreten die vier ,,Unterfamilien'' der ST9-Familie,
die sich durch eine unterschiedliche Ausstattung mit
On-Chip-Peripherie auszeichen. Im Prozessorkern sind sie identisch,
so da&szlig; diese Unterscheidung wieder nur im Includefile mit den
Peripherieadressen zum Zuge kommt.
<BLOCKQUOTE>
    at) 6804
</BLOCKQUOTE>
<BLOCKQUOTE>
    au) 32010 -> 32015
</BLOCKQUOTE>
Der TMS32010 besitzt nur 144 Byte internes RAM, weshalb AS Adressen
im Datensegment auf eben diesen Bereich begrenzt. F&uuml;r den 32015
gilt diese Beschr&auml;nkung nicht, es kann der volle Bereich von
0--255 angesprochen werden.
<BLOCKQUOTE>
    av) 320C25 -> 320C26 -> 320C28
</BLOCKQUOTE>
Diese Prozessoren unterscheiden sich nur leicht in der
On-Chip-Peripherie sowie den Konfigurationsbefehlen.
<BLOCKQUOTE>
    aw) 320C30, 320C31
</BLOCKQUOTE>
Der 320C31 ist eine etwas ,,abgespeckte'' Version mit dem gleichen
Befehlssatz, jedoch weniger Peripherie. In STDDEF3X.INC wird diese
Unterscheidung ausgenutzt.
<BLOCKQUOTE>
    ax) 320C203 -> 320C50, 320C51, 320C53
</BLOCKQUOTE>
Ersterer ist der generelle Repr&auml;sentant f&uuml;r die
C20x-Signalprozessorfamilie, die eine Untermenge des
C5x-Befehlssatzes implementieren. Die Unterscheidung zwischen den
verschiedenen C5x-Prozessoren wird von AS momentan nicht ausgenutzt.
<BLOCKQUOTE>
    ay) 320C541
</BLOCKQUOTE>
Dies ist momentan der Pepr&auml;sentant f&uuml;r die
TMS320C54x-Familie...
<BLOCKQUOTE>
    az) TMS9900
</BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> ba)</TD><TD NOWRAP> TMS70C00, TMS70C20, TMS70C40,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70CT20, TMS70CT40,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70C02, TMS70C42, TMS70C82,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> TMS70C08, TMS70C48</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Alle Mitglieder dieser Familie haben den gleichen CPU-Kern,
unterscheiden sich im Befehlssatz also nicht. Die Unterschiede finden
sich nur in der Datei REG7000.INC, in der Speicherbereiche und
Peripherieadressen definiert werden. Die in einer Zeile stehenden
Typen besitzen jeweils gleiche Peripherie und gleiche interne
RAM-Menge, unterscheiden sich also nur in der Menge eingebauten ROMs.
<BLOCKQUOTE>
    bb) 370C010, 370C020, 370C030, 370C040 und 370C050
</BLOCKQUOTE>
Analog zur MCS-51-Familie werden die unterschiedlichen Typen nur zur
Unterscheidung der Peripherie in STDDEF37.INC genutzt, der
Befehlssatz ist identisch.
<BLOCKQUOTE>
    bc) MSP430
</BLOCKQUOTE>
<BLOCKQUOTE>
    bd) SC/MP
</BLOCKQUOTE>
<BLOCKQUOTE>
    be) 8070
</BLOCKQUOTE>
Dieser PRozessor repr&auml;sentiert die gesamte 807x-Familie (die
mindestens aus den 8070, 8072 und 8073 besteht), der jedoch ein
einheitlicher CPU-Kern gemeinsam ist.
<BLOCKQUOTE>
    bf) COP87L84
</BLOCKQUOTE>
Dies ist das momentan einzige unterst&uuml;tzte Mitglied der
COP8-Familie von National Semiconductor. Mir ist bekannt, da&szlig;
die Familie wesentlich gr&ouml;&szlig;er ist und auch Vertreter mit
unterschiedlich gro&szlig;em Befehlssatz existieren, die nach Bedarf
hinzukommen werden. Es ist eben ein Anfang, und die Dokumentation von
National ist ziemlich umfangreich...
<BLOCKQUOTE>
    bg) COP410 -> COP420 Die COP42x-Derivate bieten einige weitere
    Befehle, des weiteren wurden Befehlen in ihrem Wertebereich
    erweitert.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bh)</TD><TD NOWRAP> SC14400, SC14401, SC14402, SC14404, SC14405,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> SC14420, SC14421, SC14422, SC14424</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Diese Gruppe von DECT-Controller unterscheidet sich in ihrem
Befehlsumfang, da jeweils unterschiedliche B-Feld Datenformate
unterst&uuml;tzt werden und deren Architektur im Laufe der Zeit
optimiert wurde.
<BLOCKQUOTE>
    bi) 7810 -> 78C10
</BLOCKQUOTE>
Die NMOS-Version besitzt keinen STOP-Modus; der entspechende Befehl
sowie das ZCM-Register fehlen demzufolge.<B> VORSICHT!</B> NMOS- und
CMOS-Version differieren zum Teil in den Reset-Werten einiger
Register!
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bj)</TD><TD NOWRAP> 75402,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75004, 75006, 75008,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75268,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75304, 75306, 75308, 75312, 75316,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75328,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75104, 75106, 75108, 75112, 75116,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75206, 75208, 75212, 75216,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> 75512, 75516</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Dieses ,,F&uuml;llhorn'' an Prozessoren unterscheidet sich innerhalb
einer Gruppe nur durch die RAM- und ROM-Gr&ouml;&szlig;e; die Gruppen
untereinander unterscheiden sich einmal durch ihre on-chip-Peripherie
und zum anderen durch die M&auml;chtigkeit des Befehlssatzes.
<BLOCKQUOTE>
    bk) 78070
</BLOCKQUOTE>
Dies ist das einzige, mir momentan vertraute Mitglied der
78K0-Familie von NEC. Es gelten &auml;hnliche Aussagen wie zur
COP8-Familie!
<BLOCKQUOTE>
    bl) 78214
</BLOCKQUOTE>
Dies ist momentan der Repr&auml;sentant der 78K2-Familie von NEC.
<BLOCKQUOTE>
    bm) 7720 -> 7725
</BLOCKQUOTE>
Der &micro;PD7725 bietet im Vergleich zu seinem Vorg&auml;nger
gr&ouml;&szlig;ere Adre&szlig;r&auml;ume und einige zus&auml;tzliche
Befehle.<B> VORSICHT!</B> Die Prozessoren sind nicht zueinander
bin&auml;rkompatibel!
<BLOCKQUOTE>
    bn) 77230
</BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> bo)</TD><TD NOWRAP> SYM53C810, SYM53C860, SYM53C815, SYM53C825,</TD></TR>
    <TR><TD NOWRAP></TD><TD NOWRAP> SYM53C875, SYM53C895</TD></TR>
</TABLE></BLOCKQUOTE>
Die einfacheren Mitglieder dieser Familie von SCSI-Prozessoren
besitzen einige Befehlsvarianten nicht, au&szlig;erdem unterscheiden
sie sich in ihrem Satz interner Register.
<BLOCKQUOTE>
    bp) MB89190
</BLOCKQUOTE>
Dieser Prozessortyp repr&auml;sentiert die F<SUP>2</SUP>MC8L-Serie
von Fujitsu...
<BLOCKQUOTE>
    bq) MB9500
</BLOCKQUOTE>
...so wie dieser es momentan f&uuml;r die 16-Bit-Varianten von
Fujitsu tut!
<P>
Beim CPU-Befehl mu&szlig; der Prozessortyp als einfache Konstante
angegeben werden, eine Berechnung &agrave; la
<PRE>

        CPU     68010+10

</PRE>
ist also nicht zul&auml;ssig. G&uuml;ltige Aufrufe sind z.B.
<PRE>

        CPU     8051

</PRE>
oder
<PRE>

        CPU     6800

</PRE>
Egal, welcher Prozessortyp gerade eingestellt ist, in der
Integervariablen MOMCPU wird der momentane Status als Hexadezimalzahl
abgelegt. F&uuml;r den 68010 ist z.B.<TT> MOMCPU=$68010</TT>,
f&uuml;r den 80C48<TT> MOMCPU=80C48H</TT>. Da man Buchstaben
au&szlig;er A..F nicht als Hexziffer interpretieren kann, mu&szlig;
man sich diese bei der Hex-Darstellung des Prozessors wegdenken.
F&uuml;r den Z80 ist z.B.<TT> MOMCPU=80H</TT>.
<P>
Dieses Feature kann man vorteilhaft einsetzen, um je nach
Prozessortyp unterschiedlichen Code zu erzeugen. Der 68000 z.B. kennt
noch keinen Befehl f&uuml;r den Unterprogrammr&uuml;cksprung mit
Stapelkorrektur. Mit der Variablen<TT> MOMCPU</TT> kann man ein Makro
definieren, das je nach Prozessortyp den richtigen Befehl benutzt
oder ihn emuliert:
<PRE>

myrtd   MACRO   disp
        IF      MOMCPU$&lt;$68010   ; auf 68008 und
         MOVE.L (sp),disp(sp)    ; 68000 emulieren
         LEA    disp(sp),sp
         RTS
        ELSEIF
         RTD    #disp            ; ab 68010 direkt
        ENDIF                    ; benutzen
        ENDM

        CPU     68010
        MYRTD   12               ; ergibt RTD #12

        CPU     68000
        MYRTD   12               ; ergibt MOVE.. /
                                 ; LEA.. / RTS

</PRE>
Da nicht alle Prozessornamen nur aus Ziffern und Buchstaben zwischen
A und F bestehen, wird zus&auml;tzlich der volle Name in der
String-Variablen<TT> MOMCPUNAME</TT> abgelegt.
<P>
Implizit schaltet der Assembler mit dem<TT> CPU</TT>-Befehl das
aktuelle Segment wieder auf Code zur&uuml;ck, da dies das einzige
Segment ist, das alle Prozessoren definieren.
<P>
Default f&uuml;r den Prozessortyp ist<TT> 68008</TT>, sofern dieser
&uuml;ber die gleichnamige Kommandozeilenoption nicht ver&auml;ndert
wurde.
<P>

<H3><A NAME="sect_3_2_3_">3.2.3. SUPMODE, FPU, PMMU</A></H3>
<A NAME="index_SUPMODE_1"></A><A NAME="index_FPU_1"></A><A
NAME="index_PMMU_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> 680x0, FPU auch 80x86, i960, SUPMODE auch TLCS-900,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> SH7000, i960, 29K, XA, PowerPC, M*CORE und TMS9900</EM></TD></TR>
</TABLE></EM>
<P>
Mit diesen drei Schaltern kann bestimmt werden, auf welche Teile des
Befehlssatzes verzichtet werden soll, weil die daf&uuml;r
n&ouml;tigen Vorbedingungen im folgenden Codest&uuml;ck nicht gegeben
sind. Als Parameter f&uuml;r diese Befehle darf entweder<TT> ON</TT>
oder<TT> OFF</TT> gegeben werden, der momentan gesetzte Zustand kann
aus einer Variablen ausgelesen werden, die entweder TRUE oder FALSE
ist.
<P>
Die Befehle bedeuten im einzelnen folgendes:
<UL>
<LI> <TT>SUPMODE</TT>: erlaubt bzw. sperrt Befehle, f&uuml;r deren
    Ausf&uuml;hrung der Prozessor im Supervisorstatus sein mu&szlig;.
    Die Statusvariable hei&szlig;t<TT> INSUPMODE</TT>.</LI>
<LI> <TT>FPU</TT>: erlaubt bzw. sperrt die Befehle des numerischen
    Koprozessors 8087 bzw. 68881/68882. Die Statusvariable
    hei&szlig;t<TT> FPUAVAIL</TT>.</LI>
<LI> <TT>PMMU</TT>: erlaubt bzw. sperrt die Befehle der
    Speicherverwaltungseinheit 68851 bzw. der im 68030 eingebauten
    MMU.<B> ACHTUNG!</B> Die 68030-MMU erlaubt nur eine rel. kleine
    Untermenge der 68851-Befehle. Der Assembler kann hier keine
    Pr&uuml;fung vornehmen! Die Statusvariable hei&szlig;t<TT>
    PMMUAVAIL</TT>.</LI>
</UL>
Benutzung von auf diese Weise gesperrten Befehlen erzeugt bei<TT>
SUPMODE</TT> eine Warnung, bei<TT> PMMU</TT> und<TT> FPU</TT> eine
echte Fehlermeldung.
<P>

<H3><A NAME="sect_3_2_4_">3.2.4. FULLPMMU</A></H3>
<A NAME="index_FULLPMMU_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0</EM>
<P>
Motorola hat zwar ab dem 68030 die PMMU in den Prozessor integriert,
diese aber nur mit einer Funktionsuntermenge der externen PMMU 68851
ausgestattet. AS sperrt bei aktiviertem PMMU-Befehlssatz (s.o.)
deshalb alle fehlenden Befehle, wenn als Zielprozessor 68030 oder
h&ouml;her eingestellt wurde. Nun kann es aber sein, da&szlig; in
einem System mit 68030-Prozessor die interne MMU abgeschaltet wurde
und der Prozessor mit einer externen 68851 betrieben wird. Mit<TT>
FULLPMMU ON</TT> kann man AS dann mitteilen, da&szlig; der
vollst&auml;ndige MMU-Befehlssatz zugelassen ist. Umgekehrt kann man,
wenn man portablen Code erzeugen will, alle zus&auml;tzlichen Befehle
trotz 68020-Zielplattform mit<TT> FULLPMMU OFF</TT> abschalten. Die
Umschaltung darf beliebig oft erfolgen, die momentane Einstellung
kann aus einem gleichnamigen Symbol ausgelesen werden.<B>
ACHTUNG!</B> Der<TT> CPU</TT>-Befehl besetzt f&uuml;r 680x0-Argumente
implizit diese Einstellung vor!<TT> FULLPMMU</TT> mu&szlig; also auf
jeden Fall nach dem<TT> CPU</TT>-Befehl kommen!
<P>

<H3><A NAME="sect_3_2_5_">3.2.5. PADDING</A></H3>
<A NAME="index_PADDING_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, M*Core, XA, H8, SH7000, TMS9900, MSP430,
ST7</EM>
<P>
Prozessoren der 680x0-Familie stehen ungeraden Adressen ziemlich
kritisch gegen&uuml;ber: Befehle d&uuml;rfen nicht auf einer
ungeraden Adresse beginnen, und Datenzugriffe sind mit ungeraden
Adressen bis zum 68010 nur byteorientiert erlaubt. Die H8-Familie
setzt bei Zugriffen auf ungerade Adressen das unterste Adre&szlig;bit
einfach ganz auf Null, die 500er ,,bedanken'' sich wiederum mit einer
Exception... AS bem&uuml;ht sich daher, mit<TT> DC</TT> oder<TT>
DS</TT> angelegte Datenstrukturen immer mit einer geraden Bytezahl
abzulegen. Das bedeutet bei den Befehlen<TT> DS.B</TT> und<TT>
DC.B</TT> aber unter Umst&auml;nden, da&szlig; ein F&uuml;llbyte
eingef&uuml;gt werden mu&szlig;. Dieses Verhalten kann man mit
dem<TT> PADDING</TT>-Befehl ein- und ausschalten. Als Argument ist
analog zu den vorherigen Befehlen<TT> ON</TT> oder<TT> OFF</TT>
erlaubt, und die augenblickliche Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden. Defaultm&auml;&szlig;ig
ist<TT> PADDING</TT> nur f&uuml;r die 680x0-Familie eingeschaltet,
f&uuml;r alle anderen werden erst nach Umschaltung Padding-Bytes
eingef&uuml;gt!
<P>

<H3><A NAME="sect_3_2_6_">3.2.6. PACKING</A></H3>
<A NAME="index_PACKING_1"></A>
<P>
<EM> G&uuml;ltigkeit: AVR</EM>
<P>
<TT> PACKING</TT> ist in gewisser Weise &auml;hnlich zu<TT>
PADDING</TT>, es arbeitet nur gewisserma&szlig;en anders herum:
w&auml;hrend<TT> PADDING</TT> die abgelegten Daten erg&auml;nzt, um
komplette Worte und damit ein Alignment zu erhalten, quetscht<TT>
PACKING</TT> mehrere Werte in ein einzelnes Wort. Dies macht im
Code-Segment des AVR Sinn, weil dort mit einem Spezialbefehl (<TT>
LPM</TT>) auf einzelne Bytes in den 16-Bit-Worten zugegriffen werden
kann. Ist diese Option eingeschaltet (Argument<TT> ON</TT>), so
werden immer zwei Byte-Werte bei<TT> DATA</TT> in ein Wort gepackt,
analog zu den einzelnen Zeichen von String-Argumenten. Der
Wertebereich der Integer-Argumente reduziert sich dann nat&uuml;rlich
auf -128...+255. Ist diese Option dagegen ausgeschaltet,
(Argument<TT> OFF</TT>), so bekommt jedes Integer-Argument sein
eigenes Wort und darf auch Werte von -32768...+65535 annehmen.
<P>
Diese Unterscheidung betrifft nur Integer-Argumente von<TT>
DATA</TT>, Strings werden immer gepackt. Zu beachten ist weiterhin,
da&szlig; dieses Packen nur innerhalb der Argumente eines<TT>
DATA</TT>-Befehls funktionieren kann, wer also mehrere<TT>
DATA</TT>-Befehle hinterienander hat, f&auml;ngt sich bei ungeraden
Argumentzahlen trotzdem halbvolle W&ouml;rter ein!
<P>

<H3><A NAME="sect_3_2_7_">3.2.7. MAXMODE</A></H3>
<A NAME="index_MAXMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: TLCS-900, H8</EM>
<P>
Die Prozessoren der TLCS-900-Reihe k&ouml;nnen in 2 Betriebsarten
arbeiten, dem Minimum-und Maximum-Modus. Je nach momentaner
Betriebsart gelten f&uuml;r den Betrieb und den Assembler etwas
andere Eckwerte. Mit diesem Befehl und den Parametern<TT> ON</TT>
oder<TT> OFF</TT> teilt man AS mit, da&szlig; der folgende Code im
Maximum- oder Minimum-Modus abl&auml;uft. Die momentane Einstellung
kann aus der Variablen<TT> INMAXMODE</TT> ausgelesen werden.
Voreinstellung ist<TT> OFF</TT>, d.h. Minimum-Modus.
<P>
Analog dazu teilt man im H8-Modus AS mit diesem Befehl mit, ob mit
einem 64K- oder 16Mbyte-Adre&szlig;raum gearbeitet wird. F&uuml;r den
einfachen 300er ist diese Einstellung immer<TT> OFF</TT> und kann
nicht ver&auml;ndert werden.
<P>

<H3><A NAME="sect_3_2_8_">3.2.8. EXTMODE und LWORDMODE</A></H3>
<A NAME="index_EXTMODE_1"></A><A NAME="index_LWORDMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: Z380</EM>
<P>
Der Z380 kann in insgesamt 4 Betriebsarten arbeiten, die sich durch
die Einstellung von 2 Flags ergeben: Das XM-Flag bestimmt, ob der
Prozessor mit einem 64 Kbyte oder 4 Gbyte gro&szlig;en
Adre&szlig;raum arbeiten soll und kann nur gesetzt werden (nach einem
Reset steht es Z80-kompatibel auf 0). Demgegen&uuml;ber legt das
LW-Flag fest, ob Wort-Befehle mit einer Wortl&auml;nge von 16 oder 32
Bit arbeiten sollen. Die Stellung dieser beiden Flags
beeinflu&szlig;t Wertebereichseinschr&auml;nkungen von Konstanten
oder Adressen, weshalb man AS &uuml;ber diese beiden Befehle deren
Stellung mitteilen mu&szlig;. Als Default nimmt AS an, da&szlig;
beide Flags auf 0 stehen, die momentane Einstellung (<TT>ON</TT>
oder<TT> OFF</TT>) kann aus den vordefinierten Variablen<TT>
INEXTMODE</TT> bzw.<TT> INLWORDMODE</TT> ausgelesen werden.
<P>

<H3><A NAME="sect_3_2_9_">3.2.9. SRCMODE</A></H3>
<A NAME="index_SRCMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-251</EM>
<P>
Intel hat den Befehlssatz der 8051er beim 80C251 deutlich erweitert,
hatte aber leider nur noch einen einzigen freien Opcode f&uuml;r
diese Befehle frei. Damit der Prozessor nicht auf alle Ewigkeit durch
einen Pr&auml;fix behindert bleibt, hat Intel zwei Betriebsarten
vorgesehen: Den Bin&auml;r- und den Quellmodus. Im Bin&auml;rmodus
ist der Prozessor voll 8051-kompatibel, alle erweiterten Befehle
ben&ouml;tigen den noch freien Opcode als Pr&auml;fix. Im Quellmodus
tauschen diese neuen Befehle ihre Position in der Code-Tabelle mit
den entsprechenden 8051-Instruktionen, welche dann wiederum mit einem
Pr&auml;fix versehen werden m&uuml;ssen. Damit AS wei&szlig;, wann er
Pr&auml;fixe setzen mu&szlig; und wann nicht, mu&szlig; man ihm mit
diesem Befehl mitteilen, ob der Prozessor im Quellmodus (<TT>ON</TT>)
oder Bin&auml;rmodus (<TT>OFF</TT>) betrieben wird. Die momentane
Einstellung kann man aus der Variablen<TT> INSRCMODE</TT> auslesen.
Der Default ist<TT> OFF</TT>.
<P>

<H3><A NAME="sect_3_2_10_">3.2.10. BIGENDIAN</A></H3>
<A NAME="index_BIGENDIAN_1"></A>
<P>
<EM> G&uuml;ltigkeit: MCS-51/251, PowerPC</EM>
<P>
Bei den Prozessoren der 8051-Serie ist Intel seinen eigenen
Prinzipien untreu geworden: Der Prozessor verwendet entgegen
jeglicher Tradition eine Big-Endian-Orientierung von Mehrbytewerten!
W&auml;hrend dies bei den MCS-51-Prozessoren noch nicht
gro&szlig;artig auffiel, da der Prozessor ohnehin nur 8-bittig auf
Speicherzellen zugreifen konnte, man sich die Byte-Anordnung bei
eigenen Datenstrukturen also aussuchen konnte, ist dies beim MCS-251
nicht mehr so, er kann auch ganze (Lang-)Worte aus dem Speicher lesen
und erwartet dabei das MSB zuerst. Da dies nicht der bisherigen
Arbeitsweise von AS bei der Konstantenablage entspricht, kann man nun
mit diesem Befehl umschalten, ob die Befehle<TT> DB, DW, DD, DQ</TT>
und<TT> DT</TT> mit Big- oder Little-Endian-Orientierung arbeiten
sollen. Mit<TT> BIGENDIAN OFF</TT> (Voreinstellung) wird wie bei
&auml;lteren AS-Versionen zuerst das niederwertigste Byte abgelegt,
mit<TT> BIGENDIAN ON</TT> wird die MCS-251-kompatible Variante
benutzt. Nat&uuml;rlich kann man diese Einstellung beliebig oft im
Code &auml;ndern; die momentane Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden.
<P>

<H3><A NAME="sect_3_2_11_">3.2.11. WRAPMODE</A></H3>
<A NAME="index_WRAPMODE_1"></A>
<P>
<EM> G&uuml;ltigkeit: Atmel AVR</EM>
<P>
Ist dieser Schalter auf<TT> ON</TT> gesetzt, so veranla&szlig;t man
AS dazu, anzunehmen, der Programmz&auml;hler des Prozessors habe
nicht die volle, durch die Architektur gegebene L&auml;nge von 16
Bits, sondern nur eine L&auml;nge, die es gerade eben erlaubt, das
interne ROM zu adressieren. Im Falle des AT90S8515 sind dies z.B. 12
Bit, entsprechend 4 KWorten oder 8 KBytes. Damit werden relative
Spr&uuml;nge vom Anfang des ROMs zum Ende und umgekehrt m&ouml;glich,
die bei strenger Arithmetik einen out-of-branch ergeben w&uuml;rden,
hier jedoch funktionieren, weil die &Uuml;bertragsbits bei der
Zieladressenberechnung 'unter den Tisch' fallen. Vergewissern Sie
sich genau, ob die von Ihnen eingesetzte Prozessorvariante so
arbeitet, bevor Sie diese Option einschalten! Im Falle des oben
erw&auml;hnten AT90S8515 ist diese Option sogar zwingend n&ouml;tig,
um &uuml;berhaupt quer durch den ganzen Adre&szlig;raum springen zu
k&ouml;nnen...
<P>
Defaultm&auml;&szlig;ig steht dieser Schalter auf<TT> OFF</TT>, der
momentane Stand l&auml;&szlig;t sich aus einem gleichnamigen Symbol
auslesen.
<P>

<H3><A NAME="sect_3_2_12_">3.2.12. SEGMENT</A></H3>
<A NAME="index_SEGMENT_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Bestimmte Mikrokontroller und Signalprozessoren kennen mehrere
Adre&szlig;bereiche, die nicht miteinander mischbar sind und jeweils
auch verschiedene Befehle zur Ansprache ben&ouml;tigen. Um auch diese
verwalten zu k&ouml;nnen, stellt der Assembler mehrere
Programmz&auml;hler zur Verf&uuml;gung, zwischen denen mit dem<TT>
SEGMENT</TT>-Befehl hin-und hergeschaltet werden kann. Dies erlaubt
es, sowohl in mit<TT> INCLUDE</TT> eingebundenen Unterprogrammen als
auch im Hauptprogramm ben&ouml;tigte Daten an der Stelle zu
definieren, an denen sie benutzt werden. Im einzelnen werden folgende
Segmente mit folgenden Namen verwaltet:
<UL>
<LI> <TT>CODE</TT>: Programcode;</LI>
<LI> <TT>DATA</TT>: direkt adressierbare Daten (dazu rechnen auch
    SFRs);</LI>
<LI> <TT>XDATA</TT>: im extern angeschlossenen RAM liegende Daten oder
    X-Adre&szlig;raum beim DSP56xxx oder ROM-Daten beim
    &micro;PD772x;</LI>
<LI> <TT>YDATA</TT>: Y-Adre&szlig;raum beim DSP56xxx;</LI>
<LI> <TT>IDATA</TT>: indirekt adressierbare (interne) Daten;</LI>
<LI> <TT>BITDATA</TT>: der Teil des 8051-internen RAMs, der bitweise
    adressierbar ist;</LI>
<LI> <TT>IO</TT>: I/O-Adre&szlig;bereich;</LI>
<LI> <TT>REG</TT>: Registerbank des ST9;</LI>
<LI> <TT>ROMDATA</TT>: Konstanten-ROM der NEC-Signalprozessoren.</LI>
</UL>
Zu Adre&szlig;bereich und Initialwerten der Segmente siehe Abschnitt
<A HREF="#ref_SectORG">3.2.1</A>. (<TT>ORG</TT>). Je nach
Prozessorfamilie sind auch nicht alle Segmenttypen erlaubt.
<P>
Das Bitsegment wird so verwaltet, als ob es ein Bytesegment
w&auml;re, d.h. die Adressen inkrementieren um 1 pro Bit.
<P>
Labels, die in einem Segment eines bestimmten Typs definiert werden,
erhalten diesen Typ als Attribut. Damit hat der Assembler eine
begrenzte Pr&uuml;fm&ouml;glichkeit, ob mit den falschen Befehlen auf
Symbole in einem Segment zugegriffen wird. In solchen F&auml;llen
wird der Assembler eine Warnung ausgeben.
<P>
Beispiel:
<PRE>

        CPU     8051    ; MCS-51-Code

        SEGMENT code    ; Testcodeblock

        SETB    flag    ; keine Warnung
        SETB    var     ; Warnung : falsches Segment

        SEGMENT data

var     DB      ?

        SEGMENT bitdata

flag    DB      ?

</PRE>
<P>

<H3><A NAME="sect_3_2_13_">3.2.13. PHASE und DEPHASE</A></H3>
<A NAME="index_PHASE_1"></A><A NAME="index_DEPHASE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
In manchen Anwendungen (speziell Z80-Systeme) mu&szlig; Code vor der
Benutzung in einen anderen Adre&szlig;bereich verschoben werden. Da
der Assembler davon aber nichts wei&szlig;, w&uuml;rde er alle Labels
in dem zu verschiebenden Teil auf die Ladeadressen ausrichten. Der
Programmierer m&uuml;&szlig;te Spr&uuml;nge innerhalb dieses
Bereiches entweder lageunabh&auml;ngig kodieren oder die Verschiebung
bei jedem Symbol ,,zu Fu&szlig;'' addieren. Ersteres ist bei manchen
Prozessoren gar nicht m&ouml;glich, letzteres sehr
fehleranf&auml;llig.
<P>
Mit dem Befehlen<TT> PHASE</TT> und<TT> DEPHASE</TT> ist es
m&ouml;glich, dem Assembler mitzuteilen, auf welcher Adresse der Code
im Zielsystem effektiv ablaufen wird:
<PRE>

        PHASE   &lt;Adresse&gt;

</PRE>
informiert den Assembler davon, da&szlig; der folgende Code auf der
spezifizierten Adresse ablaufen soll. Der Assembler berechnet
daraufhin die Differenz zum echten Programmz&auml;hler und addiert
diese Differenz bei folgenden Operationen dazu:
<UL>
<LI> Adre&szlig;angabe im Listing</LI>
<LI> Ablage von Labelwerten</LI>
<LI> Programmz&auml;hlerreferenzen in relativen Spr&uuml;ngen und
    Adre&szlig;ausdr&uuml;cken</LI>
<LI> Abfrage des Programmz&auml;hlers mit den Symbolen * bzw. $</LI>
</UL>
Diese ,,Verschiebung'' wird mit dem Befehl
<PRE>

        DEPHASE

</PRE>
wieder aufgehoben.
<P>
Obwohl dieses Befehlspaar vornehmlich in Codesegmenten Sinn macht,
verwaltet der Assembler f&uuml;r alle definierten Segmente
Phasenwerte.
<P>

<H3><A NAME="sect_3_2_14_">3.2.14. SAVE und RESTORE</A></H3>
<A NAME="index_SAVE_1"></A><A NAME="index_RESTORE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit dem Befehl<TT> SAVE</TT> legt der Assembler den Inhalt folgender
Variablen auf einen internen Stapel:
<UL>
<LI> momentan gew&auml;hlter Prozessortyp (mit<TT> CPU</TT>
    gesetzt);</LI>
<LI> momentan aktiver Speicherbereich (mit<TT> SEGMENT</TT>
    gesetzt);</LI>
<LI> Flag, ob Listing ein- oder ausgeschaltet ist (mit<TT> LISTING</TT>
    gesetzt);</LI>
<LI> Flag, ob Expansionen folgender Makos im Listing ausgegeben werden
    sollen (mit<TT> MACEXP</TT> gesetzt).</LI>
<LI> momentan aktive Zeichen&uuml;bersetzungstabelle (mit<TT>
    CODEPAGE</TT> gesetzt).</LI>
</UL>
Mit dem Gegenst&uuml;ck<TT> RESTORE</TT> wird entsprechend der
zuletzt gesicherte Zustand von diesem Stapel wieder heruntergeladen.
Diese beiden Befehle sind in erster Linie f&uuml;r Includefiles
definiert worden, um in diesen Dateien die obigen Variablen beliebig
ver&auml;ndern zu k&ouml;nnen, ohne ihren originalen Inhalt zu
verlieren. So kann es z.B. sinnvoll sein, in Includefiles mit
eigenen, ausgetesteten Unterprogrammen die Listingerzeugung
auszuschalten:
<PRE>

        SAVE            ; alten Zustand retten
        LISTING OFF     ; Papier sparen
        ..              ; der eigentliche Code
        RESTORE         ; wiederherstellen

</PRE>
Gegen&uuml;ber einem einfachen<TT> LISTING OFF..ON</TT>-P&auml;rchen
wird hier auch dann der korrekte Zustand wieder hergestellt, wenn die
Listingerzeugung bereits vorher ausgeschaltet war.
<P>
Der Assembler &uuml;berpr&uuml;ft, ob die Zahl von<TT>
SAVE</TT>-und<TT> RESTORE</TT>-Befehlen &uuml;bereinstimmt und
liefert in folgenden F&auml;llen Fehlermeldungen:
<UL>
<LI> <TT>RESTORE</TT> und der interne Stapel ist leer;</LI>
<LI> nach Ende eines Passes ist der Stapel nicht leer.</LI>
</UL>
<P>

<H3><A NAME="sect_3_2_15_">3.2.15. ASSUME</A></H3>
<A NAME="index_ASSUME_1"></A>
<P>
<EM> G&uuml;ltigkeit: diverse</EM>
<P>
Mit diesem Befehl kann man AS den aktuellen Stand bestimmter Register
mitteilen, deren Inhalt sich nicht mit einem einfachen<TT> ON</TT>
oder<TT> OFF</TT> beschreiben l&auml;&szlig;t. Typischerweise sind
dies Register, die die Adressierungseinheiten beeinflussen und deren
Werte AS wissen mu&szlig;, um korrekte Adressierungen zu erzeugen.
Wichtig ist, da&szlig; man AS mit ASSUME diese Werte nur mitteilt, es
wird<EM> kein</EM> Maschinencode erzeugt, der diese Werte in die
entsprechenden Register l&auml;dt!
<P>

<H4>6809</H4>
<P>
Im Gegensatz zu seinen ,,Vorg&auml;ngern'' wie 6800 und 6502 kann
beim 6809 die Lage der direct page, d.h. des Adressbereiches, der mit
ein Byte langen Adressen erreichbar ist, frei bestimmt werden. Dazu
dient das sog. ,,Direct Page Register'' (<TT>DPR</TT>), das die
Seitennummer festlegt. Ihm mu&szlig; man mittels<TT> ASSUME</TT>
einen passenden Wert zuweisen, wenn man einen anderen Wert als die
Vorgabe von 0 in DPR schreibt, sonst werden Adressen falscher
L&auml;nge erzeugt...
<P>

<H4>68HC11K4</H4>
<P>
Auch beim HC11 konnten die Entwickler letzten Endes nicht dem
'S&uuml;ndenfall' widerstehen und haben in den K4 ein Banking-Schema
eingebaut, um mit 16 Adre&szlig;leitungen mehr als 64 Kbyte
anzusprechen. Die Register<TT> MMSIZ</TT>,<TT> MMWBR</TT>,<TT>
MM1CR</TT> und<TT> MM2CR</TT> legen fest, ob wie die beiden
zus&auml;tzlichen 512K-Bereiche in den physikalischen Adre&szlig;raum
eingeblendet werden sollen. Initial nimmt AS den Reset-Zustand dieser
Register an, d.h. alle mit $00 belegt und das Windowing ist
abgeschaltet.
<P>

<H4>68HC12X</H4>
<P>
Wie die Variante ohne anh&auml;ngendes 'X' kennt auch der HC12X eine
kurze direkte Adressierungsart, die hier jedoch auch andere
Adre&szlig;bereiche als die ersten 256 Byte erreichen kann. &Uuml;ber
das<TT> DIRECT</TT>-Register kann die 256-Byte-Seite vorgegeben
werden, die mit dieser kurzen Adressierungsart angesprochen wird.
Mittels<TT> ASSUME</TT> wird AS der momentane Stand dieses Registers
mitgeteilt, so da&szlig; bei absoluten Adressen automatisch die
effizienteste Adressierungsart gew&auml;hlt werden kann. Default ist
0, was auch dem Reset-Zustand entspricht.
<P>

<H4>68HC16</H4>
<P>
Um mit seinen nur 16 Bit breiten Adre&szlig;operanden einen 1 Mbyte
gro&szlig;en Adre&szlig;raum ansprechen zu k&ouml;nnen, bedient sich
der 68HC16 einer Reihe von Bank-Registern, die die fehlenden oberen
vier Adre&szlig;bits nachliefern. Davon ist das<TT> EK</TT>-Register
f&uuml;r absolute Datenzugriffe (nicht Spr&uuml;nge!) zust&auml;ndig.
AS &uuml;berpr&uuml;ft bei jeder absoluten Adressierung, ob die
oberen vier Bits der Adresse mit dem &uuml;ber<TT> ASSUME</TT>
spezifizierten Wert &uuml;bereinstimmen. Differieren die Werte, gibt
AS eine Warnung aus. Der Vorgabewert f&uuml;r<TT> EK</TT> ist 0.
<P>

<H4>H8/500</H4>
<P>
Im Maximum-Modus wird der erweiterte Adre&szlig;raum dieser
Prozessorreihe durch eine Reihe von Bank-Registern adressiert. Diese
tragen die Namen DP (Register 0..3, absolute Adressen), EP (Register
4/5) und TP (Stack). Den momentanen Wert von DP ben&ouml;tigt AS, um
zu &uuml;berpr&uuml;fen, ob absolute Adressen in der momentan
adressierbaren Bank liegen; die beiden anderen Register werden nur
f&uuml;r indirekte Adressierungen benutzt und entziehen sich daher
der Kontrolle; ob man ihre Werte angibt oder nicht, ist daher
Geschmackssache. Wichtig ist dagegen wieder das BR-Register, das
angibt, auf welchen 256-Byte-Bereich mit kurzen Adressen zugegriffen
werden kann. Allen Registern ist gemeinsam, da&szlig; AS<EM>
keine</EM> Initialwerte f&uuml;r sie annimmt, da sie nach einem
Prozessor-Reset undefiniert sind; wer absolut adressieren will,
mu&szlig; daher auf jeden Fall DR und DP belegen!
<P>

<H4>MELPS740</H4>
<P>
Die Mikrokontroller dieser Reihe kennen f&uuml;r den<TT>
JSR</TT>-Befehl eine besondere Adressierungsart ,,special page'', mit
deren Hilfe man Spr&uuml;nge in die oberste Seite des internen ROMs
k&uuml;rzer kodieren kann. Diese ist nat&uuml;rlich vom jeweiligen
Chip abh&auml;ngig, und es gibt mehr Chips, als es mit dem<TT>
CPU</TT>-Befehl sinnvoll w&auml;re, zu kodieren...also mu&szlig;<TT>
ASSUME</TT> herhalten, um die Lage dieser Seite vorzugeben, z.B.
<PRE>

        ASSUME SP:$1f ,

</PRE>
falls das interne ROM 8K gro&szlig; ist.
<P>

<H4>MELPS7700/65816</H4>
<P>
Diese Prozessoren beinhalten eine Reihe von Registern, deren Inhalt
AS kennen mu&szlig;, um den korrekten Code zu erzeugen. Es handelt
sich um folgende Register:
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Wertebereich</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Default</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>DT<BR>
PG<BR>
DPR<BR>
X<BR>
M</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Datenbank<BR>
Code-Bank<BR>
direkt adr. Seite<BR>
Indexregisterbreite<BR>
Akkumulatorbreite</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0-$ff<BR>
0-$ff<BR>
0-$ffff<BR>
0 oder 1<BR>
0 oder 1</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0<BR>
0<BR>
0<BR>
0<BR>
0</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Um mich nicht in endlose Wiederholungen zu ergehen, verweise ich
f&uuml;r die Benutzung dieser Werte auf Kapitel <A
HREF="#ref_MELPS7700Spec">4.9</A>. Die Handhabung erfolgt ansonsten
genauso wie beim 8086, d.h. es k&ouml;nnen auch hier mehrere Werte
auf einmal gesetzt werden und es wird<B> kein</B> Code erzeugt, der
die Register mit den Werten besetzt. Dies bleibt wieder einzig und
allein dem Programmierer &uuml;berlassen!
<P>

<H4>MCS-196/296</H4>
<P>
Alle Prozessoren der MCS-96-Familie besitzen ab dem 80196 ein
Register<TT> WSR</TT>, mit dessen Hilfe Speicherbereiche aus dem
erweiterten internen RAM oder dem SFR-Bereich in Bereiche des
Registerfiles eingeblendet werden und so mit kurzen Adressen
angesprochen werden k&ouml;nnen. Teilt man AS mit Hilfe des<TT>
ASSUME</TT>-Befehls mit, welchen Wert das WSR-Register hat, so stellt
er bei absoluten Adressen automatisch fest, ob sie durch das
Windowing mit 1-Byte-Adressen erreicht werden k&ouml;nnen; umgekehrt
werden auch f&uuml;r durch das Windowing &uuml;berdeckte Register
automatisch lange Adressen erzeugt. Der 80296 besitzt ein
zus&auml;tzliches, zweites Register<TT> WSR1</TT>, um zwei
unterschiedliche Speicherbereiche gleichzeitig in das Registerfile
einblenden zu k&ouml;nnen. Sollte es m&ouml;glich sein, eine
Speicherzelle &uuml;ber beide Bereiche zu adressieren, so w&auml;hlt
AS immer den Weg &uuml;ber<TT> WSR</TT>!
<P>

<H4>8086</H4>
<P>
Der 8086 kann Daten aus allen Segmenten in einem Befehl adressieren,
ben&ouml;tigt jedoch sog. ,,Segment-Pr&auml;fixe'', wenn ein anderes
Segmentregister als DS verwendet werden soll. Zus&auml;tzlich kann es
sein, da&szlig; das DS-Register auf ein anderes Segment verstellt
ist, um z.B. &uuml;ber l&auml;ngere Strecken nur Daten im Codesegment
zu adressieren. Da AS aber keine Sinnanalyse des Codes vornimmt,
mu&szlig; ihm &uuml;ber diesen Befehl mitgeteilt werden, auf welche
Segmente die Segmentregister momentan zeigen, z.B.
<PRE>

   ASSUME  CS:CODE, DS:DATA    .

</PRE>
Allen vier Segmenten des 8086 (SS,DS,CS,ES) k&ouml;nnen auf diese
Weise Annahmen zugewiesen werden. Dieser Befehl erzeugt jedoch<B>
keinen</B> Code, um die Werte auch wirklich in die Segmentregister zu
laden, dies mu&szlig; vom Programm getan werden.
<P>
Die Benutzung diese Befehls hat zum einen die Folge, da&szlig; AS bei
sporadischen Zugriffen ins Codesegment automatisch Pr&auml;fixe
voranstellen kann, andererseits da&szlig; man AS mitteilen kann,
da&szlig; das DS-Register verstellt wurde und man sich im folgenden
explizite<TT> CS:</TT>-Anweisungen sparen kann.
<P>
G&uuml;ltige Argumente hinter dem Doppelpunkt sind<TT> CODE,
DATA</TT> und<TT> NOTHING</TT>. Letzterer Wert dient dazu, AS
mitzuteilen, da&szlig; das Segmentregister keinen f&uuml;r AS
verwendbaren Wert enth&auml;lt. Vorinitialisiert sind folgende<TT>
ASSUME</TT>s :
<PRE>

  CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING

</PRE>
<P>

<H4>XA</H4>
<P>
Die XA-Familie besitzt einen Datenadre&szlig;raum von 16 Mbyte, ein
Proze&szlig; kann jedoch nur immer innerhalb einer 64K-Seite
adressieren, die durch das DS-Register vorgegeben wird. AS mu&szlig;
man den momentanen Wert dieses Registers vorgeben, damit er Zugriffe
auf absolute Adressen &uuml;berpr&uuml;fen kann.
<P>

<H4>29K</H4>
<P>
Die Prozessoren der 29K-Familie besitzen ein Register<TT> RBP</TT>,
mit dessen Hilfe B&auml;nke von 16 Registern vor der Benutzung im
User-Modus gesch&uuml;tzt werden k&ouml;nnen. Dazu kann man ein
entsprechendes Bit in diesem Register setzen. Mit<TT> ASSUME</TT>
kann man AS nun mitteilen, welchen Wert RBP gerade hat. Auf diese
Weise kann AS warnen, falls versucht wird, im User-Modus auf
gesch&uuml;tzte Register zuzugreifen.
<P>

<H4>80C166/167</H4>
<P>
Obwohl keines der Register im 80C166/167 breiter als 16 Bit ist,
besitzt dieser Prozessor 18/24 Adre&szlig;leitungen, kann also bis zu
256 Kbyte/16 Mbyte adressieren. Um diesen Widerspruch unter einen Hut
zu bekommen, verwendet er nicht die von Intel her bekannte (...und
ber&uuml;chtigte) Segmentierung oder hat unflexible
Bankregister...nein, er macht Paging! Dazu wird der ,,logische''
Adre&szlig;raum von 64 Kbyte in 4 Seiten zu 16 Kbyte eingeteilt, und
f&uuml;r jede Seite existiert ein Seitenregister (bezeichnet als<TT>
DPP0...DPP3</TT>), das bestimmt, welche der physikalischen 16/1024
Seiten dort eingeblendet wird. AS versucht nun, den Adre&szlig;raum
grunds&auml;tzlich mit 256 Kbyte/16 Mbyte aus der Sicht des
Programmierers zu verwalten, d.h. bei absoluten Zugriffen ermittelt
AS die physikalische Seite und schaut in der mit<TT> ASSUME</TT>
eingestellten Seitenverteilung nach, wie die Bits 14 und 15 der
logischen Adresse gesetzt werden m&uuml;ssen. Pa&szlig;t kein
Seitenregister, so wird eine Warnung ausgegeben.
Defaultm&auml;&szlig;ig nimmt AS an, da&szlig; die vier Register
linear die ersten 64 Kbyte abbilden, etwa in der folgenden Form:
<PRE>

        ASSUME  DPP0:0,DPP1:1,DPP2:2,DPP3:3

</PRE>
Der 80C167 kennt noch einige Befehle, die die Seitenregister in ihrer
Funktion &uuml;bersteuern k&ouml;nnen. Wie diese Befehle die
Adre&szlig;generierung beeinflussen, ist im Kapitel mit den
prozessorspezifischen Hinweisen beschrieben.
<P>

<H4>TLCS-47</H4>
<P>
Der von der Architektur her vorgegebene Datenadre&szlig;raum dieser
Prozessoren (egal ob man direkt oder &uuml;ber das HL-Register
adressiert) betr&auml;gt lediglich 256 Nibbles. Da die ,,besseren''
Familienmitglieder aber bis zu 1024 Nibbles RAM on chip haben, war
Toshiba gezwungen, einen Bankingmechanismus &uuml;ber das
DMB-Register einzuf&uuml;hren. AS verwaltet das Datensegment als
einen durchgehenden Adre&szlig;raum und pr&uuml;ft bei jeder direkten
Adressierung, ob die Adresse in der momentan aktiven Bank liegt. Die
von AS momentan angenommene Bank kann mittels
<PRE>

        ASSUME  DMB:&lt;0..3&gt;

</PRE>
festgelegt werden. Der Default ist 0.
<P>

<H4>ST6</H4>
<A NAME="ref_ST6Assume"></A>
<P>
Die Mikrokontroller der ST62-Reihe sind in der Lage, einen Teil (64
Byte) des Codebereiches in den Datenbereich einzublenden, z.B. um
Konstanten aus dem ROM zu laden. Dies bedeutet aber auch, da&szlig;
zu einem Zeitpunkt immer nur ein Teil des ROMs adressiert werden
kann. Welcher Teil dies ist, wird durch ein bestimmtes Register
bestimmt. Dem Inhalt dieses Registers kann AS zwar nicht direkt
kontrollieren, man kann ihm aber mit diesem Befehl mitteilen, wenn
man dem Register einen neuen Wert zugewiesen hat. AS kann dann
pr&uuml;fen und ggfs. warnen, falls auf Adressen im Codesegment
zugegriffen wird, die nicht im ,,angek&uuml;ndigten'' Fenster liegt.
Hat die Variable<TT> VARI</TT> z.B. den Wert 456h, so setzt
<PRE>

        ASSUME  ROMBASE:VARI&gt;&gt;6

</PRE>
die AS-interne Variable auf 11h, und ein Zugriff auf<TT> VARI</TT>
erzeugt einen Zugriff auf die Adresse 56h im Datensegment.
<P>
Anstelle eines Symbols kann auch schlicht<TT> NOTHING</TT> angegeben
werden, z.B. wenn das Bank-Register tempor&auml;r als Speicherzelle
benutzt wird. Dieser Wert ist auch die Voreinstellung.
<P>

<H4>ST9</H4>
<P>
Die ST9-Familie verwendet zur Adressierung von Code- und Datenbereich
exakt die gleichen Befehle. Welcher Adre&szlig;raum dabei jeweils
angesprochen wird, h&auml;ngt vom Stand des DP-Flags im Flag-Register
ab. Damit AS bei absoluten Zugriffen &uuml;berpr&uuml;fen kann, ob
man mit Symbolen aus dem korrekten Adre&szlig;raum arbeitet (das
funktioniert nat&uuml;rlich<EM> nur</EM> bei absoluten Zugriffen!),
mu&szlig; man ihm per<TT> ASSUME</TT> mitteilen, ob das DP-Flag
momentan auf 0 (Code) oder 1 (Daten) steht. Der Initialwert dieser
Annahme ist 0.
<P>

<H4>&micro;PD78(C)10</H4>
<P>
Diese Prozessoren besitzen ein Register (V), mit dessen Hilfe die
,,Zeropage'', d.h. die Lage der mit nur einem Byte adressierbaren
Speicherzellen sich in Seitengrenzen im Speicher frei verschieben
l&auml;&szlig;t. Da man aber aus Bequemlichkeitsgr&uuml;nden nicht
mit Ausdr&uuml;cken wie
<PRE>

        inrw    Lo(Zaehler)

</PRE>
arbeiten will, &uuml;bernimmt AS diese Arbeit, allerdings nur unter
der Voraussetzung, da&szlig; man ihm &uuml;ber einen<TT>
ASSUME</TT>-Befehl den Inhalt des V-Registers mitteilt. Wird ein
Befehl mit Kurzadressierung benutzt, so wird &uuml;berpr&uuml;ft, ob
die obere H&auml;lfte des Adre&szlig;ausdrucks mit dem angenommenen
Inhalt &uuml;bereinstimmt. Stimmt sie nicht, so erfolgt eine Warnung.
<P>

<H4>78K2</H4>
<P>
78K2 ist eine 8/16-Bit-Architektur, die nachtr&auml;glich durch
Banking auf einen (Daten-)Adre&szlig;raum von einem MByte erweitert
wurde. Das Banking wird mit den Registern PM6 (Normalfall) bzw. P6
(alternativer Fall mit vorangestelltem &amp;) realisiert, die die
fehlenden oberen vier Bits nachliefern. Zumindest bei absoluten
Adressen kann AS &uuml;berpr&uuml;fen, ob die gerade angesprochene,
lineare 20-bittige Adresse innerhalb des gegebenen 64K-Fensters
liegt.
<P>

<H4>320C3x</H4>
<P>
Da alle Instruktionsworte dieser Prozessorfamilie nur 32 Bit lang
sind, und von diesen 32 Bit nur 16 Bit f&uuml;r absolute Adressen
vorgesehen wurden, m&uuml;ssen die fehlenden oberen 8 Bit aus dem
DP-Register erg&auml;nzt werden. Bei Adressierungen kann man aber
trotzdem die volle 24-Bit-Adresse angeben, AS pr&uuml;ft dann, ob die
oberen 8 Bit mit dem angenommenen Inhalt von DP &uuml;bereinstimmen.
Gegen&uuml;ber dem<TT> LDP</TT>-Befehl weicht<TT> ASSUME</TT> darin
ab, da&szlig; man hier nicht eine beliebige Adresse aus der
Speicherbank angeben kann, das Herausziehen der oberen Bits mu&szlig;
man also ,,zu Fu&szlig;'' machen, z.B. so:
<PRE>

        ldp     @adr
        assume  dp:adr&gt;&gt;16
        .
        .
        .
        ldi     @adr,r2

</PRE>
<P>

<H4>75K0</H4>
<P>
Da selbst mit Hilfe von Doppelregistern (8 Bit) nicht der komplette
Adre&szlig;raum von 12 Bit zu erreichen ist, mu&szlig;te NEC (wie
andere auch...) auf Banking zur&uuml;ckgreifen: Die oberen 4
Adre&szlig;bits werden aus dem<TT> MBS</TT>-Register geholt (welchem
demzufolge mit<TT> ASSUME</TT> Werte zwischen 0 und 15 zugeordnet
werden k&ouml;nnen), das aber nur beachtet wird, falls das<TT>
MBE</TT>-Flag auf 1 gesetzt wurde. Steht es (wie die Vorgabe ist) auf
0, so kann man die obersten und untersten 128 Nibbles des
Adre&szlig;raumes ohne Bankumschaltung erreichen. Da der 75402
weder<TT> MBE</TT>-Flag noch<TT> MBS</TT>-Register kennt, ist
f&uuml;r ihn der<TT> ASSUME</TT>-Befehl nicht definiert; Die
Initialwerte von<TT> MBE</TT> und<TT> MBS</TT> lassen sich daher
nicht &auml;ndern.
<P>

<H4>F&sup2;MC16L</H4>
<P>
Wie viele andere Mikrokontroller auch, leidet diese Familie etwas
unter der Knauserei seiner Entwickler: einem 24 Bit breiten
Adre&szlig;raum stehen 16 Bit breite Adre&szlig;register etwas
unterbemittelt gegen&uuml;ber. Also mu&szlig;ten wieder mal
Bank-Register her. Im einzelnen sind dies PCB f&uuml;r den
Programmcode, DTB f&uuml;r alle Datenzugriffe, ADB f&uuml;r indirekte
Zugriffe &uuml;ber RW2/RW6 und SSB/USB f&uuml;r die Stacks. Sie
k&ouml;nnen alle Werte zwischen 0 und 255 annehmen.
Defaultm&auml;&szlig;ig stehen alle Annahmen von AS auf 0, mit
Ausnahme von 0ffh f&uuml;r PCB.
<P>
Des weiteren existiert das DPR-Register, das angibt, welche Seite
innerhalb der durch DTB gegebenen 64K-Bank mit 8-Bit-Adressen
erreicht werden kann. Der Default f&uuml;r DPR ist 1, zusammen mit
dem Default f&uuml;r DTB ergibt dies also eine Default-Seite bei
0001xxh.
<P>

<H3><A NAME="sect_3_2_16_">3.2.16. EMULATED</A></H3>
<A NAME="index_EMULATED_1"></A>
<P>
<EM> G&uuml;ltigkeit: 29K</EM>
<P>
AMD hat die Ausnahmebehandlung f&uuml;r undefinierte Befehle bei der
29000-Serie so definiert, da&szlig; f&uuml;r jeden einzelnen Befehl
ein Exceptionvektor zur Verf&uuml;gung steht. Dies legt es nahe,
durch gezielte Software-Emulationen den Befehlssatz eines kleineren
Mitgliedes dieser Familie zu erweitern. Damit nun aber AS diese
zus&auml;tzlichen Befehle nicht als Fehler anmeckert, erlaubt es
der<TT> EMULATED</TT>-Befehl, AS mitzuteilen, da&szlig; bestimmte
Befehle doch erlaubt sind. Die Pr&uuml;fung, ob der momentan gesetzte
Prozessor diesen Befehl beherrscht, wird dann &uuml;bergangen. Hat
man z.B. f&uuml;r einen Prozessor ohne Gleitkommaeinheit ein Modul
geschrieben, das aber nur mit 32-Bit-IEEE-Zahlen umgehen kann, so
schreibt man
<PRE>

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS

</PRE>
<P>

<H3><A NAME="sect_3_2_17_">3.2.17. BRANCHEXT</A></H3>
<A NAME="index_BRANCHEXT_1"></A>
<P>
<EM> G&uuml;ltigkeit: XA</EM>
<P>
<TT> BRANCHEXT</TT> mit<TT> ON</TT> oder<TT> OFF</TT> als Argument
legt fest, ob AS kurze, nur mit einem 8-Bit-Displacement
verf&uuml;gbare Spr&uuml;nge automatisch ,,verl&auml;ngern'' soll,
indem z.B. aus einem einfachen
<PRE>

        bne     target

</PRE>
automatisch eine l&auml;ngere Sequenz mit gleicher Funktion wird,
falls das Sprungziel zu weit von momentanen Programmz&auml;hler
entfernt ist. F&uuml;r<TT> bne</TT> w&auml;re dies z.B. die Sequenz
<PRE>

        beq     skip
        jmp     target
skip:

</PRE>
Falls f&uuml;r eine Anweisung aber kein passendes ,,Gegenteil''
existiert, kann die Sequenz auch l&auml;nger werden, z.B.
f&uuml;r<TT> jbc</TT>:
<PRE>

        jbc     dobr
        bra     skip
dobr:   jmp     target
skip:

</PRE>
Durch dieses Feature gibt es bei Spr&uuml;ngen keine eineindeutige
Zuordnung von Maschinen- und Assemblercode mehr, und bei
Vorw&auml;rtsreferenzen handelt man sich m&ouml;glicherweise
zus&auml;tzliche Passes ein. Man sollte dieses Feature daher mit
Vorsicht einsetzen!
<P>

<H2><A NAME="sect_3_3_">3.3. Datendefinitionen</A></H2>
<P>
Die hier beschriebenen Befehle &uuml;berschneiden sich teilweise in
ihrer Funktionalit&auml;t, jedoch definiert jede Prozessorfamilie
andere Namen f&uuml;r die gleiche Funktion. Um mit den
Standardassemblern konform zu bleiben, wurde diese Form der
Implementierung gew&auml;hlt.
<P>
Sofern nicht ausdr&uuml;cklich anders erw&auml;hnt, kann bei allen
Befehlen zur Datenablage (nicht bei denen zur Speicherreservierung!)
eine beliebige Zahl von Parametern angegeben werden, die der Reihe
nach abgearbeitet werden.
<P>

<H3><A NAME="sect_3_3_1_">3.3.1. DC[.size]</A></H3>
<A NAME="index_DC_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, M*Core, 68xx, H8, SH7000, DSP56xxx, XA,
ST7</EM>
<P>
Dieser Befehl legt eine oder mehrere Konstanten des beim durch das
Attribut bestimmten Typs im Speicher ab. Die Attribute entsprechen
den in Abschnitt <A HREF="#ref_AttrTypes">2.5</A> definierten,
zus&auml;tzlich ist f&uuml;r Byte-Konstanten die M&ouml;glichkeit
vorhanden, Stringausdr&uuml;cke im Speicher abzulegen, wie z.B.
<PRE>

String  dc.b    "Hello world!\0"

</PRE>
Die Parameterzahl darf zwischen 1 und 20 liegen, zus&auml;tzlich darf
jedem Parameter ein in eckigen Klammern eingeschlossener
Wiederholungsfaktor vorausgehen, z.B. kann man mit
<PRE>

        dc.b    [(*+255)&$ffffff00-*]0

</PRE>
den Bereich bis zur n&auml;chsten Seitengrenze mit Nullen
f&uuml;llen.<B> Vorsicht!</B> Mit dieser Funktion kann man sehr
leicht die Grenze von 1 Kbyte erzeugten Codes pro Zeile Quellcode
&uuml;berschreiten!
<P>
Sollte die Byte-Summe ungerade sein, so kann vom Assembler
automatisch ein weiteres Byte angef&uuml;gt werden, um die
Wortausrichtung von Daten zu erhalten. Dieses Verhalten kann mit
dem<TT> PADDING</TT>-Befehl ein- und ausgeschaltet werden.
<P>
Mit diesem Befehl abgelegte Dezimalgleitkommazahlen (<TT>DC.P</TT>
...) k&ouml;nnen zwar den ganzen Bereich der extended precision
&uuml;berstreichen, zu beachten ist dabei allerdings, da&szlig; die
von Motorola verf&uuml;gbaren Koprozessoren 68881/68882 beim Einlesen
solcher Konstanten die Tausenderstelle des Exponenten ignorieren!
<P>
Default-Attribut ist<TT> W</TT>, also 16-Bit-Integerzahlen.
<P>
Beim DSP56xxx ist der Datentyp auf Integerzahlen festgelegt (ein
Attribut ist deshalb weder n&ouml;tig noch erlaubt), die im Bereich
-8M..16M-1 liegen d&uuml;rfen. Stringkonstanten sind ebenfalls
erlaubt, wobei jeweils drei Zeichen in ein Wort gepackt werden.
<P>
Es ist im Gegensatz zum Original Motorola-Assembler auch erlaubt, mit
diesem Kommando Speicher zu reservieren, indem man als Argument ein
Fragezeichen angibt. Diese Erweiterung haben wohl einige
Drittanbieter von 68K-Assemblern eingebaut, in Anlehnung an das, was
Intel-Assembler machen. Wer dies benutzt, sollte sich aber im klaren
sein, da&szlig; dies zu Problemen beim Portieren von Code auf andere
Assembler f&uuml;hren kann. Des weiteren d&uuml;rfen Fragenzeichen
als Operanden nicht mit 'normalen' Konstanten in einer Anweisung
gemischt werden.
<P>

<H3><A NAME="sect_3_3_2_">3.3.2. DS[.size]</A></H3>
<A NAME="index_DS_1"></A>
<P>
<EM> G&uuml;ltigkeit: 680x0, M*Core, 68xx, H8, SH7x00, DSP56xxx, XA,
ST7</EM>
<P>
Mit diesem Befehl l&auml;&szlig;t sich zum einen Speicherplatz
f&uuml;r die angegebene Zahl im Attribut beschriebener Zahlen
reservieren. So reserviert
<PRE>

        DS.B    20

</PRE>
z.B. 20 Bytes Speicher,
<PRE>

        DS.X    20

</PRE>
aber 240 Byte !
<P>
Die andere Bedeutung ist die Ausrichtung des Programmz&auml;hlers,
die mit der Wertangabe 0 erreicht wird. So wird mit
<PRE>

        DS.W    0

</PRE>
der Programmz&auml;hler auf die n&auml;chste gerade Adresse
aufgerundet, mit
<PRE>

        DS.D    0

</PRE>
dagegen auf die n&auml;chste Langwortgrenze. Eventuell dabei
freibleibende Speicherzellen sind nicht etwa mit Nullen oder NOPs
gef&uuml;llt, sondern undefiniert.
<P>
Vorgabe f&uuml;r die Operandengr&ouml;&szlig;e ist --- wie
&uuml;blich --- W, also 16 Bit.
<P>
Beim 56xxx ist die Operandengr&ouml;&szlig;e auf Worte (a 24 Bit)
festgelegt, Attribute gibt es deswegen wie bei<TT> DC</TT> auch hier
nicht.
<P>

<H3><A NAME="sect_3_3_3_">3.3.3. DB,DW,DD,DQ &amp; DT</A></H3>
<A NAME="index_DB_1"></A><A NAME="index_DW_1"></A><A
NAME="index_DD_1"></A><A NAME="index_DQ_1"></A><A
NAME="index_DT_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, M16(C),</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> MELPS7700/65816, National, ST9, TMS7000, &micro;PD77230,</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> Fairchild, Intersil</EM></TD></TR>
</TABLE></EM>
<P>
Diese Befehle stellen sozusagen das Intel-Gegenst&uuml;ck zu<TT>
DS</TT> und<TT> DC</TT> dar, und wie nicht anders zu erwarten, ist
die Logik etwas anders:
<P>
Zum einen wird die Kennung der Operandengr&ouml;&szlig;e in das
Mnemonic verlegt:
<UL>
<LI> <TT>DB</TT>: Byte oder ASCII-String wie bei<TT> DC.B</TT></LI>
<LI> <TT>DW</TT>: 16-Bit-Integer</LI>
<LI> <TT>DD</TT>: 32-Bit-Integer oder single precision</LI>
<LI> <TT>DQ</TT>: double precision (64 Bit)</LI>
<LI> <TT>DT</TT>: extended precision (80 Bit)</LI>
</UL>
Zum anderen erfolgt die Unterscheidung, ob Konstantendefinition oder
Speicherreservierung, im Operanden. Eine Reservierung von Speicher
wird durch ein<TT> ?</TT> gekennzeichnet:
<PRE>

        db  ?   ; reserviert ein Byte 
        dw  ?,? ; reserviert Speicher fuer 2 Worte (=4 Byte) 
        dd  -1  ; legt die Konstante -1 (FFFFFFFFH) ab ! 

</PRE>
Speicherreservierung und Konstantendefinition d&uuml;rfen<B> nicht in
einer Anweisung</B> gemischt werden:
<PRE>

        db  "Hallo",?  ; --&gt;Fehlermeldung 

</PRE>
<A NAME="index_DUP_1"></A> Zus&auml;tzlich ist noch der<TT>
DUP</TT>-Operator erlaubt, der die mehrfache Ablage von
Konstantenfolgen oder die Reservierung ganzer Speicherbl&ouml;cke
erlaubt:
<PRE>

        db  3 dup (1,2) ; --&gt; 1 2 1 2 1 2 
        dw  20 dup (?)  ; reserviert 40 Byte Speicher. 

</PRE>
Wie man sehen kann, mu&szlig; das<TT> DUP</TT>-Argument geklammert
werden, darf daf&uuml;r aber auch wieder aus mehreren Teilen
bestehen, die selber auch wieder<TT> DUP</TT>s sein k&ouml;nnen...das
ganze funktioniert also rekursiv.
<P>
<TT> DUP</TT> ist aber auch eine Stelle, an der man mit einer anderen
Grenze des Assemblers in Ber&uuml;hrung kommen kann: maximal
k&ouml;nnen 1024 Byte Code oder Daten in einer Zeile erzeugt werden.
Dies bezieht sich<B> nicht</B> auf die Reservierung von Speicher, nur
auf die Definition von Konstantenfeldern!
<P>
<A NAME="index_DEFB_1"></A><A NAME="index_DEFW_1"></A> Um mit dem M80
vertr&auml;glich zu sein, darf im Z80-Modus anstelle von<TT>
DB</TT>/<TT>DW</TT> auch<TT> DEFB</TT>/<TT>DEFW</TT> geschrieben
werden.
<P>
<A NAME="index_BYTE_1"></A><A NAME="index_WORD_1"></A><A
NAME="index_ADDR_1"></A><A NAME="index_ADDRW_1"></A> Analog
stellen<TT> BYTE/ADDR</TT> bzw.<TT> WORD/ADDRW</TT> beim COP4/8 einen
Alias f&uuml;r<TT> DB</TT> bzw.<TT> DW</TT> dar, wobei die beiden
Paare sich jedoch in der Byte-Order unterscheiden: Die Befehle, die
von National zur Adre&szlig;ablage vorgesehen waren, benutzen
Big-Endian,<TT> BYTE</TT> bzw.<TT> WORD</TT> jedoch Little-Endian.
<P>
Der NEC 77230 nimmt mit seiner<TT> DW</TT>-Anweisung eine
Sonderstellung ein: Sie funktioniert eher wie<TT> DATA</TT> bei
seinen kleineren Br&uuml;dern, akzeptiert aber neben String- und
Integerargumenten auch Gleitkommawerte (und legt sie
prozessorspezifischen 32-Bit-Format ab).<TT> DUP</TT> gibt es<EM>
nicht</EM>!
<P>

<H3><A NAME="sect_3_3_4_">3.3.4. DS, DS8</A></H3>
<A NAME="index_DS_2"></A><A NAME="index_DS8_1"></A>
<P>
<EM>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><EM> G&uuml;ltigkeit:</EM></TD><TD NOWRAP><EM> Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, M16(C),</EM></TD></TR>
<TR><TD NOWRAP><EM></EM></TD><TD NOWRAP><EM> National, ST9, TMS7000, Intersil</EM></TD></TR>
</TABLE></EM>
<P>
Dieser Befehl stellt eine Kurzschreibweise dar, um Speicherbereiche
zu reservieren:
<BLOCKQUOTE>
    <TT> DS &lt;Anzahl&gt;</TT>
</BLOCKQUOTE>
ist eine Kurzschreibweise f&uuml;r
<BLOCKQUOTE>
    <TT> DB &lt;Anzahl&gt; DUP (?)</TT>
</BLOCKQUOTE>
dar, lie&szlig;e sich also prinzipiell auch einfach &uuml;ber ein
Makro realisieren, nur scheint dieser Befehl in den K&ouml;pfen
einiger mit Motorola-CPUs gro&szlig; gewordener Leute (gell,
Michael?) so fest verdrahtet zu sein, da&szlig; sie ihn als
eingebauten Befehl erwarten...hoffentlich sind selbige jetzt
zufrieden<TT> ;-)</TT>
<P>
<TT> DS8</TT> ist beim National SC14xxx als Alias f&uuml;r<TT>
DS</TT> definiert. Achten Sie aber darauf, da&szlig; der Speicher
dieser Prozessoren in Worten zu 16 Bit organisiert ist, d.h. es ist
unm&ouml;glich, einzelne Bytes zu reservieren. Falls das Argument
von<TT> DS</TT> ungerade ist, wird es auf die
n&auml;chstgr&ouml;&szlig;ere gerade Zahl aufgerundet.
<P>

<H3><A NAME="sect_3_3_5_">3.3.5. BYT oder FCB</A></H3>
<A NAME="index_BYT_1"></A><A NAME="index_FCB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus Byte-Konstanten oder
ASCII-Strings abgelegt, er entspricht also<TT> DC.B</TT> beim 68000
oder<TT> DB</TT> bei Intel. Ein Wiederholungsfaktor darf analog
zu<TT> DC</TT> jedem einzelnen Parameter in eckigen Klammern
vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_6_">3.3.6. BYTE</A></H3>
<A NAME="index_BYTE_2"></A>
<P>
<EM> G&uuml;ltigkeit: ST6, 320C2(0)x, 320C5x, MSP, TMS9900</EM>
<P>
Dito. Ein im 320C2(0)x/5x-Modus vor dem Befehl stehendes Label wird
als untypisiert gespeichert, d.h. keinem Adre&szlig;raum zugeordnet.
Der Sinn dieses Verhaltens wird bei den prozessorspezifischen
Hinweisen erl&auml;utert.
<P>
Ob beim MSP bzw. TMS9900 ungerade Mengen von Bytes automatisch um ein
Null-Byte erg&auml;nzt werden sollen, kann mit dem PADDING-Befehl
eingestellt werden.
<P>

<H3><A NAME="sect_3_3_7_">3.3.7. DC8</A></H3>
<A NAME="index_DC8_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Dieser Befehl ist ein Alias f&uuml;r<TT> DB</TT>, d.h. mit ihm
k&ouml;nnen Byte-Konstanten oder Strings im Speicher abgelegt werden.
<P>

<H3><A NAME="sect_3_3_8_">3.3.8. ADR oder FDB</A></H3>
<A NAME="index_ADR_1"></A><A NAME="index_FDB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus Wortkonstanten abgelegt,
er entspricht also<TT> DC.W</TT> beim 68000 oder<TT> DW</TT> bei
Intel. Ein Wiederholungsfaktor darf analog zu<TT> DC</TT> jedem
einzelnen Parameter in eckigen Klammern vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_9_">3.3.9. WORD</A></H3>
<A NAME="index_WORD_2"></A>
<P>
<EM> G&uuml;ltigkeit: ST6, i960, 320C2(0)x, 320C3x, 320C5x, MSP</EM>
<P>
F&uuml;r den 320C3x und i960 werden hiermit 32-Bit-Worte abgelegt,
f&uuml;r die alle anderen Familien 16-Bit-Worte. Ein im
320C2(0)x/5x-Modus vor dem Befehl stehendes Label wird als
untypisiert gespeichert, d.h. keinem Adre&szlig;raum zugeordnet. Der
Sinn dieses Verhaltens wird bei den prozessorspezifischen Hinweisen
erl&auml;utert.
<P>

<H3><A NAME="sect_3_3_10_">3.3.10. DW16</A></H3>
<A NAME="index_DW16_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Diser Befehl ist beim SC144xx der Weg, Konstanten mit Wortl&auml;nge
(16 Bit) im Speicher abzulegen und damit ein ALIAS f&uuml;r DW.
<P>

<H3><A NAME="sect_3_3_11_">3.3.11. LONG</A></H3>
<A NAME="index_LONG_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Hiermit werden 32-Bit-Integer im Speicher abgelegt, und zwar in der
Reihenfolge LoWord-HiWord. Ein eventuell vor dem Befehl stehendes
Label wird dabei wieder als untypisiert abgelegt (der Sinn dieser
Ma&szlig;nahme ist in den prozessorspezifischen Hinweisen
erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_12_">3.3.12. SINGLE, DOUBLE und EXTENDED</A></H3>
<A NAME="index_SINGLE_1"></A><A NAME="index_DOUBLE_1"></A><A
NAME="index_EXTENDED_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C3x (nicht<TT> DOUBLE</TT>), 320C6x
(nicht<TT> EXTENDED</TT>)</EM>
<P>
Mit diesen Befehlen werden Gleitkomma-Konstanten im Speicher
abgelegt, jedoch beim 320C3x nicht im IEEE-Format, sondern in den vom
Prozessor verwendeten 32- und 40-Bit-Formaten. Da 40 Bit nicht mehr
in eine Speicherzelle hineinpassen, werden im Falle von<TT>
EXTENDED</TT> immer derer 2 pro Wert belegt. Im ersten Wort finden
sich die oberen 8 Bit (der Exponent), der Rest (Vorzeichen und
Mantisse) in zweiten Wort.
<P>

<H3><A NAME="sect_3_3_13_">3.3.13. FLOAT und DOUBLE</A></H3>
<A NAME="index_FLOAT_1"></A><A NAME="index_DOUBLE_2"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Mit diesen Befehlen k&ouml;nnen 32- bzw. 64-Bit-Gleitkommazahlen im
IEEE-Format im Speicher abgelegt werden. Dabei wird das
niederwertigste Byte jeweils auf der ersten Speicherstelle abgelegt.
Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert (der Sinn dieser Ma&szlig;nahme ist in den
prozessorspezifischen Hinweisen erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_14_">3.3.14. EFLOAT, BFLOAT, TFLOAT</A></H3>
<A NAME="index_EFLOAT_1"></A><A NAME="index_BFLOAT_1"></A><A
NAME="index_TFLOAT_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Auch diese Befehle legen Gleitkommazahlen im Speicher ab, jedoch in
einem nicht-IEEE-Format, das evtl. leichter von Signalprozessoren zu
verarbeiten ist:
<UL>
<LI> <TT>EFLOAT</TT>: Mantisse mit 16 Bit, Exponent mit 16 Bit</LI>
<LI> <TT>BFLOAT</TT>: Mantisse mit 32 Bit, Exponent mit 16 Bit</LI>
<LI> <TT>DFLOAT</TT>: Mantisse mit 64 Bit, Exponent mit 32 Bit</LI>
</UL>
Gemeinsam ist den Befehlen, da&szlig; die Mantisse vor dem Exponenten
abgelegt wird (Lo-Word jeweils zuerst) und beide im Zweierkomplement
dargestellt werden. Ein eventuell vor dem Befehl stehendes Label wird
wieder als untypisiert gespeichert (der Sinn dieser Ma&szlig;nahme
ist in den prozessorspezifischen Hinweisen erl&auml;utert).
<P>

<H3><A NAME="sect_3_3_15_">3.3.15. Qxx und LQxx</A></H3>
<A NAME="index_Qxx_1"></A><A NAME="index_LQxx_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Mit diesen Befehlen k&ouml;nnen Gleitkommazahlen in einem
Festkommaformat abgelegt werden.<TT> xx</TT> ist dabei eine
zweistellige Zahl, mit deren Zweierpotenz der Gleitkommawert vor der
Umwandlung in eine ganze Zahl multipliziert werden soll. Er bestimmt
also praktisch, wieviele Bits f&uuml;r die Nachkommastellen
reserviert werden sollen. W&auml;hrend aber<TT> Qxx</TT> nur ein Wort
(16 Bit) ablegt, wird das Ergebnis bei<TT> LQxx</TT> in 2 Worten
(LoWord zuerst) abgelegt. Das sieht dann z.B. so aus:
<PRE>

        q05     2.5      ; --&gt; 0050h
        lq20    ConstPI  ; --&gt; 43F7h 0032h

</PRE>
Mich m&ouml;ge niemand steinigen, wenn ich mich auf meinem HP28
verrechnet haben sollte...
<P>

<H3><A NAME="sect_3_3_16_">3.3.16. DATA</A></H3>
<A NAME="index_DATA_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC, 320xx, AVR, MELPS-4500, 4004/4040,
&micro;PD772x</EM>
<P>
Mit diesem Befehl werden Daten im aktuellen Segment abgelegt, wobei
sowohl Integer- als auch Stringwerte zul&auml;ssig sind. Bei Strings
belegt beim 16C5x/16C8x, 17C4x im Datensegment und 4500er ein Zeichen
ein Wort, bei AVR, 17C4x im Codesegment, &micro;PD772x in den
Datensegmenten und 3201x/3202x passen zwei Zeichen in ein Wort (LSB
zuerst), beim &micro;PD7725 drei und beim 320C3x sogar derer 4 (MSB
zuerst). Im Gegensatz dazu mu&szlig; im Datensegment des 4500ers ein
Zeichen auf zwei Speicherstellen verteilt werden, ebenso wie beim
4004. Der Wertebereich f&uuml;r Integers entspricht der Wortbreite
des jeweiligen Prozessors im jeweiligen Segment. Das bedeutet,
da&szlig;<TT> DATA</TT> beim 320C3x die Funktion von<TT> WORD</TT>
mit einschlie&szlig;t (die von<TT> SINGLE</TT> &uuml;brigens auch,
wenn AS das Argument als Gleitkommazahl erkennt).
<P>

<H3><A NAME="sect_3_3_17_">3.3.17. ZERO</A></H3>
<A NAME="index_ZERO_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC</EM>
<P>
Dieser Befehl legt einen durch den Parameter spezifizierte Zahl von
Nullworten (=NOPs) im Speicher ab. Es k&ouml;nnen maximal 512 Nullen
mit einem Befehl abgelegt werden.
<P>

<H3><A NAME="sect_3_3_18_">3.3.18. FB und FW</A></H3>
<A NAME="index_FB_1"></A><A NAME="index_FW_1"></A>
<P>
<EM> G&uuml;ltigkeit: COP4/8</EM>
<P>
Mit diesen Befehlen kann ein gr&ouml;&szlig;erer Block von Speicher
(dessen L&auml;nge in Bytes bzw. Worten der erste Parameter angibt)
mit einer Byte- bzw. Wortkonstanten gef&uuml;llt werden, die durch
den zweiten Parameter angegeben wird. Die Maximalgr&ouml;&szlig;e des
Blocks betr&auml;gt 1024 Elemente f&uuml;r<TT> FB</TT> bzw. 512
Elemente f&uuml;r<TT> FW</TT>.
<P>

<H3><A NAME="sect_3_3_19_">3.3.19. ASCII und ASCIZ</A></H3>
<A NAME="index_ASCII_1"></A><A NAME="index_ASCIZ_1"></A>
<P>
<EM> G&uuml;ltigkeit: ST6</EM>
<P>
Mit diesen beiden Befehlen k&ouml;nnen Stringkonstanten im Speicher
abgelegt werden. W&auml;hrend ASCII nur die reinen Daten im Speicher
ablegt, versieht<TT> ASCIZ</TT> automatisch<I> jeden</I> angegebenen
String mit einem NUL-Zeichen am Ende.
<P>

<H3><A NAME="sect_3_3_20_">3.3.20. STRING und RSTRING</A></H3>
<A NAME="index_STRING_1"></A><A NAME="index_RSTRING_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C5x</EM>
<P>
Diese Anweisungen funktionieren analog zu<TT> DATA</TT>, jedoch
werden hier Integer-Ausdr&uuml;cke grunds&auml;tzlich als<I>
Bytes</I> mit einem entsprechend eingeschr&auml;nkten Wertebereich
betrachtet, wodurch es m&ouml;gliich wird, die Zahlen zusammen mit
anderen Zahlen oder Zeichen paarweise in Worte zu verpacken. Die
beiden Befehle unterscheiden sich lediglich in der Reihenfolge der
Bytes in einem Wort: Bei<TT> STRING</TT> wird zuerst das obere und
danach das untere gef&uuml;llt, bei<TT> RSTRING</TT> ist es genau
umgekehrt.
<P>
Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert. Der Sinn dieser Ma&szlig;nahme ist im
entsprechenden Kapitel mit den prozessorspezifischen Befehlen
erl&auml;utert.
<P>

<H3><A NAME="sect_3_3_21_">3.3.21. FCC</A></H3>
<A NAME="index_FCC_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Mit diesem Befehl werden im 65xx/68xx-Modus String-Konstanten
abgelegt. Beachten Sie jedoch, da&szlig; im Gegensatz zum
Originalassembler AS11 von Motorola (dessentwegen dieser Befehl
existiert, bei AS ist diese Funktion im<TT> BYT</TT>-Befehl
enthalten), String-Argumente nur in G&auml;nsef&uuml;&szlig;chen und
nicht in Hochkommas oder Schr&auml;gstrichen eingeschlossen werden
d&uuml;rfen! Ein Wiederholungsfaktor darf analog zu<TT> DC</TT> jedem
einzelnen Parameter in eckigen Klammern vorangestellt werden.
<P>

<H3><A NAME="sect_3_3_22_">3.3.22. DFS oder RMB</A></H3>
<A NAME="index_DFS_1"></A><A NAME="index_RMB_1"></A>
<P>
<EM> G&uuml;ltigkeit: 6502, 68xx</EM>
<P>
Dieser Befehl dient im 65xx/68xx-Modus zur Reservierung von Speicher,
er entspricht<TT> DS.B</TT> beim 68000 oder<TT> DB ?</TT> bei Intel.
<P>

<H3><A NAME="sect_3_3_23_">3.3.23. BLOCK</A></H3>
<A NAME="index_BLOCK_1"></A>
<P>
<EM> G&uuml;ltigkeit: ST6</EM>
<P>
Dito.
<P>

<H3><A NAME="sect_3_3_24_">3.3.24. SPACE</A></H3>
<A NAME="index_SPACE_1"></A><EM> G&uuml;ltigkeit: i960</EM> Dito.
<P>

<H3><A NAME="sect_3_3_25_">3.3.25. RES</A></H3>
<A NAME="index_RES_1"></A>
<P>
<EM> G&uuml;ltigkeit: PIC, MELPS-4500, 3201x, 320C2(0)x, 320C5x, AVR,
&micro;PD772x</EM>
<P>
Dieser Befehl dient zur Reservierung von Speicher. Er reserviert im
Codesegment immer W&ouml;rter (10/12/14/16 Bit), im Datensegment bei
den PICs Bytes, beim 4500er Nibbles sowie bei Texas ebenfalls
W&ouml;rter.
<P>

<H3><A NAME="sect_3_3_26_">3.3.26. BSS</A></H3>
<A NAME="index_BSS_1"></A>
<P>
<EM> G&uuml;ltigkeit: 320C2(0)x, 320C3x, 320C5x, 320C6x, MSP</EM>
<P>
<TT> BSS</TT> arbeitet analog zu<TT> RES</TT>, lediglich ein
eventuell vor dem Befehl stehendes Symbol wird beim 320C2(0)x/5x als
untypisiert gespeichert. Der Sinn dieser Ma&szlig;nahme kann im
Kapitel mit den prozessorspezifischen Hinweisen nachgelesen werden.
<P>

<H3><A NAME="sect_3_3_27_">3.3.27. DSB und DSW</A></H3>
<A NAME="index_DSB_1"></A><A NAME="index_DSW_1"></A>
<P>
<EM> G&uuml;ltigkeit: COP4/8</EM>
<P>
Diese beiden Befehle stellen im COP4/8-Modus die zum ASMCOP von
National kompatible Methode dar, Speicher zu reservieren.
W&auml;hrend<TT> DSB</TT> nur einzelne Bytes freih&auml;lt,
reserviert<TT> DSW</TT> W&ouml;rter und damit effektiv doppelt soviel
Bytes wie<TT> DSB</TT>.
<P>

<H3><A NAME="sect_3_3_28_">3.3.28. DS16</A></H3>
<A NAME="index_DS16_1"></A>
<P>
<EM> G&uuml;ltigkeit: SC144xx</EM>
<P>
Dieser Befehl reserviert Speicher in Schritten von vollst&auml;ndigen
Worten, d.h. 16 Bit. Er stellt einen Alias zu<TT> DW</TT> dar.
<P>

<H3><A NAME="sect_3_3_29_">3.3.29. ALIGN</A></H3>
<A NAME="index_ALIGN_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> ALIGN</TT> mit einem Integerausdruck als Argument erlaubt es,
den Programmz&auml;hler auf eine bestimmte Adresse auszurichten. Die
Ausrichtung erfolgt dergestalt, da&szlig; der Programmz&auml;hler so
weit erh&ouml;ht wird, da&szlig; er ein ganzzahliges mehrfaches des
Argumentes wird. In seiner Funktion entspricht<TT> ALIGN</TT>
also<TT> DS.x 0</TT> beim den 680x0ern, nur ist die Ausrichtung noch
flexibler.
<P>
Beispiel:
<PRE>

        align 2

</PRE>
macht den Programmz&auml;hler gerade. Wie auch bei<TT> DS.x 0</TT>
ist der freibleibende Speicherraum undefiniert.
<P>

<H3><A NAME="sect_3_3_30_">3.3.30. LTORG</A></H3>
<A NAME="index_LTORG_1"></A>
<P>
<EM> G&uuml;ltigkeit: SH7x00</EM>
<P>
Da der SH7000-Prozessor seine Register immediate nur mit 8-Bit-Werten
laden kann, AS dem Programmierer jedoch vorgaukelt, da&szlig; es eine
solche Einschr&auml;nkung nicht g&auml;be, mu&szlig; er die dabei
entstehenden Konstanten irgendwo im Speicher ablegen. Da es nicht
sinnvoll w&auml;re, dies einzeln zu tun (wobei jedes Mal
Sprungbefehle anfallen w&uuml;rden...), werden die Literale gesammelt
und k&ouml;nnen vom Programmierer mit diesem Befehl gezielt
blockweise (z.B. am Ende eines Unterprogrammes) abgelegt werden. Zu
den zu beachtenden Details und Fallen sei auf das Kapitel mit den
SH7000-spezifischen Dingen hingewiesen.
<P>

<H2><A NAME="sect_3_4_">3.4. Makrobefehle</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Kommen wir nun zu dem, was einen Makroassembler vom normalen
Assembler unterscheidet: der M&ouml;glichkeit, Makros zu definieren
(ach was ?!).
<P>
Unter Makros verstehe ich hier erst einmal eine Menge von Anweisungen
(normal oder Pseudo), die mit bestimmten Befehlen zu einem Block
zusammengefa&szlig;t werden und dann auf bestimmte Weise bearbeitet
werden k&ouml;nnen. Zur Bearbeitung solcher Bl&ouml;cke kennt der
Assembler folgende Befehle:
<P>

<H3><A NAME="sect_3_4_1_">3.4.1. MACRO</A></H3>
<A NAME="index_MACRO_1"></A><A NAME="index_ENDM_1"></A>
<P>
ist der wohl wichtigste Befehl zur Makroprogrammierung. Mit der
Befehlsfolge
<PRE>

&lt;Name&gt;  MACRO   [Parameterliste]
        &lt;Befehle&gt;
        ENDM

</PRE>
wird das Makro<TT> &lt;Name: &gt;</TT> als die eingeschlossene
Befehlsfolge definiert. Diese Definition alleine erzeugt noch keinen
Code! Daf&uuml;r kann fortan die Befehlsfolge einfach durch den Namen
abgerufen werden, das Ganze stellt also eine Schreiberleichterung
dar. Um die ganze Sache etwas n&uuml;tzlicher zu machen, kann man der
Makrodefinition eine Parameterliste mitgeben. Die Parameternamen
werden wie &uuml;blich durch Kommas getrennt und m&uuml;ssen --- wie
der Makroname selber --- den Konventionen f&uuml;r Symbolnamen (<A
HREF="#ref_SectSymConv">2.7</A>) gen&uuml;gen.
<P>
Sowohl Makronamen als auch -parameter sind von einer Umschaltung von
AS in den case-sensitiven Modus betroffen.
<P>
Makros sind &auml;hnlich wie Symbole lokal, d.h. bei Definition in
einer Sektion sind sie nur in dieser Sektion und ihren Untersektionen
bekannt. Dieses Verhalten l&auml;&szlig;t sich aber durch die weiter
unten beschriebenen Optionen<TT> PUBLIC</TT> und<TT> GLOBAL</TT> in
weiten Grenzen steuern.
<P>
Neben den eigentlichen Makroparametern k&ouml;nnen in der
Parameterliste auch Steuerparameter enthalten sein, die die
Abarbeitung des betroffenen Makros beeinflussen; diese Parameter
werden von normalen Parametern dadurch unterschieden, da&szlig; sie
in geschweifte Klammern eingeschlossen sind. Es sind folgende
Steuerparameter definiert:
<UL>
<LI> <TT>EXPAND/NOEXPAND</TT> : legen fest, ob bei der sp&auml;teren
    Verwendung diese Makros der expandierte Code mit angezeigt werden
    soll. Default ist der durch den Pseudobefehl<TT> MACEXP</TT>
    festgelegte Wert.</LI>
<LI> <TT>PUBLIC[:Sektionsname]</TT> : ordnet das Makro nicht der
    aktuellen, sondern einer ihr &uuml;bergeordneten Sektion zu. Auf
    diese Weise kann eine Sektion Makros f&uuml;r die
    ,,Au&szlig;enwelt'' zur Verf&uuml;gung stellen. Fehlt eine
    Sektionsangabe, so wird das Makro v&ouml;llig global, d.h. ist
    &uuml;berall benutzbar.</LI>
<LI> <TT>GLOBAL[:Sektionsname]</TT> : legt fest, da&szlig; neben diesem
    Makro noch ein weiteres Makro abgelegt werden soll, das zwar den
    gleichen Inhalt hat, dessen Name aber zus&auml;tzlich mit dem
    Namen der Sektion versehen ist, in der es definiert wurde und das
    der spezifizierten Sektion zugeordnet werden soll. Bei dieser
    mu&szlig; es sich um eine Obersektion zu der aktuellen Sektion
    handeln; fehlt die Angabe, so wird das zus&auml;tzliche Makro
    global sichtbar. Wird z.B. ein Makro<TT> A</TT> in der
    Sektion<TT> B</TT> definiert, die wiederum eine Untersektion der
    Sektion<TT> C</TT> ist, so w&uuml;rde neben z.B. dem Makro A ein
    weiteres globales mit dem Namen<TT> C_B_A</TT> erzeugt.
    W&uuml;rde dagegen<TT> C</TT> als Zielsektion angegeben, so
    w&uuml;rde das Makro<TT> B_A</TT> hei&szlig;en und der
    Sektion<TT> C</TT> zugeordnet. Diese Option ist
    defaultm&auml;&szlig;ig ausgeschaltet und hat auch nur einen
    Effekt, falls sie innerhalb einer Sektion benutzt wird. Das lokal
    bekannte Originalmakro wird von ihr nicht beeinflu&szlig;t.</LI>
<LI> <TT>EXPORT/NOEXPORT</TT> : legen fest, ob die Definition dieses
    Makros in einer getrennten Datei abgelegt werden soll, falls die
    Kommandozeilenoption<TT> -M</TT> gegeben wurde. Auf diese Weise
    k&ouml;nnen einzelne Definitionen ,,privater'' Makros selektiv
    ausgeblendet werden. Der Default ist FALSE, d.h. die Definition
    wird nicht in der Datei abgelegt. Ist zus&auml;tzlich die<TT>
    GLOBAL</TT>-Option gegeben worden, so wird das Makro mit dem
    modifizierten Namen abgelegt.</LI>
<LI> <TT>INTLABEL/NOINTLABEL</TT> : legen fest, ob ein in der Zeile mit
    dem Makroaufruf definiertes Label innerhalb des Rumpfes als
    zus&auml;tzlicher Parameter verwendet werden soll, als einfach
    nur die Adresse dieser Zeile zu 'labeln'.</LI>
</UL>
Diese eben beschriebenen Steuerparameter werden von AS aus der
Parameterliste ausgefiltert, haben also keine weitere Wirkung in der
folgenden Verarbeitung und Benutzung.
<P>
Beim Aufruf eines Makros werden die beim Aufruf angegebenen
Parameternamen &uuml;berall textuell im Befehlsblock eingesetzt und
der sich so ergebene Assemblercode wird normal assembliert. Sollten
beim Aufruf zu wenige Parameter angegeben werden, werden Nullstrings
eingef&uuml;gt. Wichtig ist zu wissen, da&szlig; bei der
Makroexpansion keine R&uuml;cksicht auf eventuell in der Zeile
enthaltene Stringkonstanten genommen wird. Zu diesem Detail gilt die
alte IBM-Regel:
<BLOCKQUOTE>
    <I> It's not a bug, it's a feature!</I>
</BLOCKQUOTE>
Diese L&uuml;cke kann man bewu&szlig;t ausnutzen, um Parameter
mittels Stringvergleichen abzupr&uuml;fen. So kann man auf folgende
Weise z.B. pr&uuml;fen, wie ein Makroparameter aussieht:
<PRE>

mul     MACRO   para,parb
        IF      UpString("PARA")&lt;&gt;"A"
         MOV    a,para
        ENDIF
        IF      UpString("PARB")&lt;&gt;"B"
         MOV    b,parb
        ENDIF
        mul     ab
        ENDM

</PRE>
Wichtig ist bei obigem Beispiel, da&szlig; der Assembler alle
Parameternamen im case-sensitiven Modus in Gro&szlig;buchstaben
umsetzt, in Strings aber nie eine Umwandlung in Gro&szlig;buchstaben
erfolgt. Die Makroparameternamen m&uuml;ssen in den Stringkonstanten
daher gro&szlig; geschrieben werden.
<P>
F&uuml;r die Makroparameter gelten die gleichen Konventionen wie bei
normalen Symbolen, mit der Ausnahme, da&szlig; hier nur Buchstaben
und Ziffern zugelassen sind, also weder Punkte noch Unterstriche.
Diese Einschr&auml;nkung hat ihren Grund in einem verstecktem
Feature: Der Unterstrich erlaubt es, einzelne Makroparameternamen zu
einem Symbol zusammenzuketten, z.B. in folgendem Beispiel:
<PRE>

concat  MACRO   part1,part2
        CALL    part1_part2
        ENDM

</PRE>
Der Aufruf
<PRE>

        concat  Modul,Funktion

</PRE>
ergibt also
<PRE>

        CALL    Modul_Funktion

</PRE>
<P>
Neben den am Makro selber angegebenen Parametern existieren vier
weitere 'implizite' Parameter, die immer vorhanden sind und daher
nicht als eigene Makroparameter verwendet werden sollten:
<UL>
<LI> <TT> ATTRIBUTE</TT> bezeichnet bei Architekturen, die Attribute
    f&uuml;r Prozessorbefehle zulassen, das bei einem Makroaufruf
    angeh&auml;ngte Argument. F&uuml;r ein Beispiel siehe z.B.
    unten!</LI>
<LI> <TT> ALLARGS</TT> bezeichnet eine kommaseparierte Liste aller
    Makroargumente, z.B., um sie an eine<TT> IRP</TT>-Anweisung
    weiterzureichen.</LI>
<LI> <TT> ARGCOUNT</TT> bezeichnet die tat&auml;chlich &uuml;bergebene
    Anzahl der an das Makro &uuml;bergebenen Argumente. Zu beachten
    ist allerdings, da&szlig; diese Zahl niemals geringer als die
    Zahl der formalen Parameter ist, da AS fehlende Argumente mit
    Leerstrings auff&uuml;llt!</LI>
<LI> <TT> __LABEL__</TT> bezeichnet das Label, das in der das Makro
    aufrufenden Zeile stand. Diese Ersetzung findet nur statt, wenn
    f&uuml;r dieses Makro die<TT> INTLABEL</TT>-Option gesetzt
    wurde!</LI>
</UL>
<P>
Der Zweck, ein Label 'intern' im Makro verwenden zu k&ouml;nnen, ist
sicher nicht unmittelbar einleuchtend. Den einen oder anderen Fall
mag es ja geben, in dem es sinnvoll ist, den Einsprungpunkt in ein
Makro irgendwo in seinen Rumpf zu verschieben. Der wichtigste
Anwendungsfall sind aber TI-Signalprozessoren, die eine
Parallelisierung von Befehlen durch einen doppelten senkrechten
Strich in der Label-Spalte kennzeichnen, etwa so:
<PRE>

    instr1
||  instr2

</PRE>
(da die beiden Instruktionen im Maschinencode in ein Wort
verschmelzen, kann man die zweite Instruktion &uuml;brigens gar nicht
separat anspringen - man verliert also durch das Belegen der
Label-Position nichts). Das Problem ist aber, da&szlig; einige
'Bequemlichkeits-Befehle' durch Makros realisiert werden. Ein vor das
Makro geschriebenes Parallelisierungssymbol w&uuml;rde normalerweise
dem Makro selber zugeordnet,<I> nicht dem ersten Befehl im Makro
selber</I>. Aber mit diesem Trick funktioniert's:
<PRE>

myinstr    macro {INTLABEL}
__LABEL__  instr2
           endm

           instr1
||         myinstr

</PRE>
Das Ergebnis nach der Expansion von<TT> myinstr</TT> ist identisch zu
dem vorherigen Beispiel ohne Makro.
<P>
Rekursion von Makros, also das wiederholte Aufrufen eines Makros
innerhalb seines Rumpfes oder indirekt &uuml;ber andere von ihm
aufgerufene Makros ist vollkommen legal. Wie bei jeder Rekusion
mu&szlig; man dabei nat&uuml;rlich sicherstellen, da&szlig; sie
irgendwann ein Ende findet. F&uuml;r den Fall, da&szlig; man dies
vergessen hat, f&uuml;hrt AS in jedem definierten Makro einen
Z&auml;hler mit, der bei Beginn einer Makroexpansion inkrementiert
und an deren Ende wieder dekrementiert wird. Bei rekursiven Aufrufen
eines Makros erreicht dieser Z&auml;hler also immer h&ouml;here
Werte, und bei einem per<TT> NESTMAX</TT> einstellbaren Wert bricht
AS ab. Vorsicht, wenn man diese Bremse abschaltet: der Speicherbedarf
auf dem Heap kann so beliebig steigen und selbst ein Unix-System in
die Knie zwingen...
<P>
Um alle Klarheiten auszur&auml;umen, ein einfaches Beispiel: Ein
intelverbl&ouml;deter Programmierer m&ouml;chte die Befehle<TT>
PUSH/POP</TT> unbedingt auch auf dem 68000 haben. Er l&ouml;st das
,,Problem'' folgenderma&szlig;en:
<PRE>

push    MACRO   op
        MOVE.ATTRIBUTE op,-(sp)
        ENDM

pop     MACRO   op
        MOVE.ATTRIBUTE (sp)+,op
        ENDM

</PRE>
Schreibt man nun im Code
<PRE>

        push    d0
        pop.l   a2        ,

</PRE>
so wird daraus
<PRE>

        MOVE.   d0,-(sp)
        MOVE.L  (sp)+,a2

</PRE>
Eine Makrodefinition darf nicht &uuml;ber Includefilegrenzen
hinausgehen.
<P>
In Makror&uuml;mpfen definierte Labels werden immer als lokal
betrachtet, ein expliziter<TT> LOCAL</TT>-Befehl ist also nicht
erforderlich (und ist auch nicht definiert). Ist es aus irgendwelchen
Gr&uuml;nden erforderlich, so kann man es mit<TT> LABEL</TT>
definieren, dessen Anwendung (wie bei<TT> BIT,SFR</TT>...) immer
globale Symbole ergibt :
<PRE>

&lt;Name&gt;  LABEL   *

</PRE>
Da der Assembler beim Parsing einer Zeile zuerst die Makroliste und
danach die Prozessorbefehle abklappert, lassen sich auch
Prozessorbefehle neu definieren. Die Definition sollte dann aber vor
der ersten Benutzung des Befehles durchgef&uuml;hrt werden, um
Phasenfehler wie im folgenden Beispiel zu vermeiden:
<PRE>

        BSR     ziel

bsr     MACRO   target
        JSR     ziel
        ENDM

        BSR     ziel

</PRE>
Im ersten Pass ist bei der Assemblierung des<TT> BSR</TT>-Befehles
das Makro noch nicht bekannt, es wird ein 4 Byte langer Befehl
erzeugt. Im zweiten Pass jedoch steht die Makrodefinition sofort (aus
dem ersten Pass) zur Verf&uuml;gung, es wird also ein 6 Byte
langer<TT> JSR</TT> kodiert. Infolgedessen sind alle darauffolgenden
Labels um zwei zu niedrig, bei allen weiteren Labels sind
Phasenfehler die Folge, und ein weiterer Pass ist erforderlich.
<P>
Da durch die Definition eines Makros ein gleichnamiger Maschinen-
oder Pseudobefehl nicht mehr zugreifbar ist, gibt es eine
Hintert&uuml;r, die Originalbedeutung zu erreichen: Stellt man dem
Mnemonic ein<TT> !</TT> voran, so wird das Durchsuchen der Makroliste
unterdr&uuml;ckt. Das kann beispielsweise n&uuml;tzlich sein, um
Befehle in ihrer M&auml;chtigkeit zu erweitern, z.B. die
Schiebebefehle beim TLCS-90:
<PRE>

srl     macro   op,n      ; Schieben um n Stellen
        rept    n         ; n einfache Befehle
         !srl   op
        endm
        endm

</PRE>
Fortan hat der<TT> SRL</TT>-Befehl einen weiteren Parameter...
<P>

<H3><A NAME="sect_3_4_2_">3.4.2. IRP</A></H3>
<A NAME="index_IRP_1"></A>
<P>
ist die eine vereinfachte Form von Makrodefinitionen f&uuml;r den
Fall, da&szlig; eine Befehlsfolge einmal auf mehrere Operanden
angewendet werden soll und danach nicht mehr gebraucht wird.<TT>
IRP</TT> ben&ouml;tigt als ersten Parameter ein Symbol f&uuml;r den
Operanden, und danach eine (fast) beliebige Menge von Parametern, die
nacheinander in den Befehlsblock eingesetzt werden. Um eine Menge von
Registern auf den Stack zu schieben, kann man z.B. schreiben
<PRE>

        IRP     op, acc,b,dpl,dph
        PUSH    op
        ENDM

</PRE>
was in folgendem resultiert:
<PRE>

        PUSH    acc
        PUSH    b
        PUSH    dpl
        PUSH    dph

</PRE>
Benutzte Labels sind wieder f&uuml;r jeden Durchgang automatisch
lokal.
<P>

<H3><A NAME="sect_3_4_3_">3.4.3. IRPC</A></H3>
<A NAME="index_IRPC_1"></A>
<P>
<TT> IRPC</TT> ist eine Variante von<TT> IRP</TT>, bei der das erste
Argument in den bis<TT> ENDM</TT> folgenden Zeilen nicht sukzessiv
durch die weiteren Parameter, sondern durch die Zeichen eines Strings
ersetzt wird. Einen String kann man z.B. also auch ganz
umst&auml;ndlich so im Speicher ablegen:
<PRE>

        irpc    char,"Hello World"
        db      'CHAR'
        endm

</PRE>
<B>ACHTUNG!</B> Wie das Beispiel schon zeigt, setzt<TT> IRPC</TT> nur
das Zeichen selber ein, da&szlig; daraus ein g&uuml;ltiger Ausdruck
entsteht (also hier durch die Hochkommas, inklusive des Details,
da&szlig; hier keine automatische Umwandlung in Gro&szlig;buchstaben
vorgenommen wird), mu&szlig; man selber sicherstellen.
<P>

<H3><A NAME="sect_3_4_4_">3.4.4. REPT</A></H3>
<A NAME="index_REPT_1"></A>
<P>
ist die einfachste Form der Makrobenutzung. Der im Rumpf angegebene
Code wird einfach sooft assembliert, wie der Integerparameter von<TT>
REPT</TT> angibt. Dieser Befehl wird h&auml;ufig in kleinen Schleifen
anstelle einer programmierten Schleife verwendet, um den
Schleifenoverhead zu sparen.
<P>
Der Vollst&auml;ndigkeit halber ein Beispiel:
<PRE>

        REPT    3
        RR      a
        ENDM

</PRE>
rotiert den Akku um 3 Stellen nach rechts.
<P>
Symbole sind wiederum f&uuml;r jede einzelne Repetition lokal.
<P>
Ist das Argument von<TT> REPT</TT> kleiner oder gleich Null, so wird
&uuml;berhaupt keine Expansion durchgef&uuml;hrt. Dies ist ein
Unterschied zu fr&uuml;heren Versionen von AS, die hier etwas
,,schlampig'' waren und immer mindestens eine Expansion
ausf&uuml;hrten.
<P>

<H3><A NAME="sect_3_4_5_">3.4.5. WHILE</A></H3>
<A NAME="index_WHILE_1"></A>
<P>
<TT> WHILE</TT> arbeitet analog zu<TT> REPT</TT>, allerdings tritt an
die Stelle einer festen Anzahl als Argument ein boolescher Ausdruck,
und der zwischen<TT> WHILE</TT> und<TT> ENDM</TT> eingeschlossene
Code wird sooft assenbliert, bis der Ausdruck logisch falsch wird. Im
Extremfall kann dies bedeuten, da&szlig; der Code &uuml;berhaupt
nicht assembliert wird, falls die Bedingung bereits beim Eintritt in
das Konstrukt falsch ist. Andererseits kann es nat&uuml;rlich auch
passieren, da&szlig; die Bedingung immer wahr bleibt, und AS
l&auml;uft bis an das Ende aller Tage...hier sollte man also etwas
Umsicht walten lassen, d.h. im Rumpf mu&szlig; eine Anweisung stehen,
die die Bedingung auch beeinflu&szlig;t, z.B. so:
<PRE>

cnt     set     1
sq      set     cnt*cnt
        while   sq&lt;=1000
         dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

</PRE>
Dieses Beispiel legt alle Quadratzahlen bis 1000 im Speicher ab.
<P>
Ein unsch&ouml;nes Detail bei<TT> WHILE</TT> ist im Augenblick leider
noch, da&szlig; am Ende der Expansion eine zus&auml;tzliche
Leerzeile, die im Quellrumpf nicht vorhanden war, eingef&uuml;gt
wird. Dies ist ein ,,Dreckeffekt'', der auf einer Schw&auml;che des
Makroprozessors beruht und leider nicht so einfach zu beheben ist.
Hoffentlich st&ouml;rt es nicht allzusehr....
<P>

<H3><A NAME="sect_3_4_6_">3.4.6. EXITM</A></H3>
<A NAME="index_EXITM_1"></A>
<P>
<TT> EXITM</TT> stellt einen Weg dar, um eine Makroexpansion oder
einen der Befehle<TT> REPT</TT>,<TT> IRP</TT> oder<TT> WHILE</TT>
vorzeitig abzubrechen. Eine solche M&ouml;glichkeit hilft zum
Beispiel, umfangreichere Klammerungen mit<TT> IF-ENDIF</TT>-Sequenzen
in Makros &uuml;bersichtlicher zu gestalten. Sinnvollerweise ist
ein<TT> EXITM</TT> aber selber auch immer bedingt, was zu einem
wichtigen Detail f&uuml;hrt: Der Stack, der &uuml;ber momentan
offene<TT> IF</TT>- oder<TT> SWITCH</TT>-Konstrukte Buch f&uuml;hrt,
wird auf den Stand vor Beginn der Makroexpansion zur&uuml;ckgesetzt.
Dies ist f&uuml;r bedingte<TT> EXITM</TT>'s zwingend notwendig, da
das den<TT> EXITM</TT>-Befehl in irgendeiner Form
einschlie&szlig;ende<TT> ENDIF</TT> oder<TT> ENDCASE</TT> nicht mehr
erreicht wird und AS ohne einen solchen Trick eine Fehlermeldung
erzeugen w&uuml;rde. Weiterhin ist es f&uuml;r verschachtelte
Makrokonstruktionen wichtig, zu beachten, da&szlig;<TT> EXITM</TT>
immer nur das momentan innerste Konstrukt abbricht! Wer aus seiner
geschachtelten Konstruktion vollst&auml;ndig ,,ausbrechen'' will,
mu&szlig; auf den h&ouml;heren Ebenen ebenfalls<TT> EXITM</TT>'s
vorsehen!
<P>

<H3><A NAME="sect_3_4_7_">3.4.7. SHIFT</A></H3>
<A NAME="index_SHIFT_1"></A>
<P>
<TT> SHIFT</TT> ist ein Mittel, um Makros mit variablen
Argumentlisten abzuarbeiten: Es verwirft den ersten Parameter, so
da&szlig; der zweite Parameter seinen Platz einnimmt usw. Auf diese
Weise k&ouml;nnte man sich durch eine variable Argumentliste
durcharbeiten...wenn man es richtig macht. Folgendes funktioniert zum
Beispiel<EM> nicht</EM>...
<PRE>

pushlist  macro reg
          rept  ARGCOUNT
          push  reg
          shift
          endm
          endm

</PRE>
...weil das Makro<EM> einmal</EM> expandiert wird, seine Ausgabe
von<TT> REPT</TT> aufgenommen und dann n-fach ausgef&uuml;hrt wird.
Das erste Argument wird also n-fach gesichert...besser geht es schon
so:
<PRE>

pushlist  macro reg
          if      "ARG"&lt;&gt;""
           push    arg
           shift
           pushlist ALLARGS
          endif
          endm

</PRE>
Also eine Rekursion, in der pro Schritt die Argumentliste (<TT>
ALLARGS</TT>) um eins verk&uuml;zt wird. Der wichtige Trick ist,
da&szlig; jedes Mal eine neue Expansion gestartet wird...
<P>

<H3><A NAME="sect_3_4_8_">3.4.8. MAXNEST</A></H3>
<A NAME="index_MAXNEST_1"></A>
<P>
Mit<TT> MAXNEST</TT> kann man einstellen, wie oft ein Makro maximal
rekursiv aufgerufen werden kann, bevor AS mit einer Fehlermeldung
abbricht. Dies darf ein beliebiger ganzer, positiver Wert sein, wobei
der Sonderwert 0 diese Sicherheitsbremse komplett abschaltet
(vorsicht damit...). Der Vorgabewert f&uuml;r die maximale
Verschachtelungstiefe ist 256; die momentante Einstellung kann aus
ener gleichnamigen Variablen gelesen werden.
<P>

<H3><A NAME="sect_3_4_9_">3.4.9. FUNCTION</A></H3>
<A NAME="index_FUNCTION_1"></A><A NAME="ref_SectFUNCTION"></A>
<P>
<TT> FUNCTION</TT> ist zwar kein Makrobefehl im engeren Sinne, da
hierbei aber &auml;hnliche Mechanismen wie bei Makroersetzungen
angewendet werden, soll er hier beschrieben werden.
<P>
Dieser Befehl dient dazu, neue Funktionen zu definieren, die in
Formelausdr&uuml;cken wie die vordefinierten Funktionen verwendet
werden k&ouml;nnen. Die Definition mu&szlig; in folgender Form
erfolgen:
<PRE>

&lt;Name&gt;  FUNCTION &lt;Arg&gt;,..,&lt;Arg&gt;,&lt;Ausdruck&gt;

</PRE>
Die Argumente sind die Werte, die sozusagen in die Funktion
,,hineingesteckt'' werden. In der Definition werden f&uuml;r die
Argumente symbolische Namen gebraucht, damit der Assembler bei der
Benutzung der Funktion wei&szlig;, an welchen Stellen die aktuellen
Werte einzusetzen sind. Dies kann man an folgendem Beispiel sehen:
<PRE>

isgit   FUNCTION ch,(ch&gt;='0')&&(ch&lt;='9')

</PRE>
Diese Funktion &uuml;berpr&uuml;ft, ob es sich bei dem Argument (wenn
man es als Zeichen interpretiert) um eine Ziffer im momentan
g&uuml;ltigen Zeichencode handelt (der momentane Zeichencode ist
mittels<TT> CHARSET</TT> ver&auml;nderbar, daher die vorsichtige
Formulierung).
<P>
Die Argumentnamen (in diesem Falle<TT> CH</TT>) m&uuml;ssen den
gleichen h&auml;rteren Symbolkonventionen gen&uuml;gen wie Parameter
bei einer Makrodefinition, d.h. die Sonderzeichen . und _ sind nicht
erlaubt.
<P>
Selbstdefinierte Funktionen werden genauso benutzt wie eingebaute,
d.h. mit einer durch Kommas getrennten, geklammerten Argumentliste:
<PRE>

        IF isdigit(Zeichen)
         message "\{Zeichen} ist eine Ziffer"
        ELSEIF
         message "\{Zeichen} ist keine Ziffer"
        ENDIF

</PRE>
<P>
Bei dem Aufruf der Funktion werden die Argumente nur einmal berechnet
und danach an allen Stellen der Formel eingesetzt, um den
Rechenaufwand zu reduzieren und Seiteneffekte zu vermeiden. Bei
Funktionen mit mehreren Argumenten m&uuml;ssen die einzelnen
Argumente bei der Benutzung durch Kommata getrennt werden.
<P>
<B> ACHTUNG!</B> Analog wie bei Makros kann man mit der Definition
von Funktionen bestehende Funktionen umdefinieren. Damit lassen sich
auch wieder Phasenfehler provozieren. Solche Definitionen sollten
daher auf jeden Fall vor der ersten Benutzung erfolgen!
<P>
Da die Berechnung des Funktionsergebnisses anhand des
Formelausdruckes auf textueller Ebene erfolgt, kann der Ergebnistyp
von dem Typ des Eingangsargumentes abh&auml;ngen. So kann bei
folgender Funktion
<PRE>

double  function x,x+x

</PRE>
das Ergebnis ein Integer, eine Gleitkommazahl oder sogar ein String
sein, je nach Typ des Arguments!
<P>
Bei der Definition und Ansprache von Funktionen wird im
case-sensitiven Modus zwischen Gro&szlig;- und Kleinschreibung
unterschieden, im Gegensatz zu eingebauten Funktionen!
<P>

<H2><A NAME="sect_3_5_">3.5. Strukturen</A></H2>
<A NAME="index_STRUCT_1"></A><A NAME="index_ENDSTRUCT_1"></A><A
NAME="index_UNION_1"></A><A NAME="index_STRUC_1"></A><A
NAME="index_ENDS_1"></A><A NAME="index_DOTTEDSTRUCTS_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Auch in Assemblerprogrammen ergibt sich dann und wann die
Notwendigkeit, analog zu Hochsprachen zusammengesetzte
Datenstrukturen zu definieren. AS unterst&uuml;tzt sowohl die
Definition als auch die Nutzung von Strukturen mit einer Reihe von
Konstrukten und Anweisungen, die im folgenden erl&auml;utert werden
sollen:
<P>

<H3><A NAME="sect_3_5_1_">3.5.1. Definition</A></H3>
<P>
Die Definition einer Struktur wird duch den Befehl<TT> STRUCT</TT>
eingeleitet und durch<TT> ENDSTRUCT</TT> abgeschlossen (schreibfaule
Zeitgenossen d&uuml;rfen aber auch stattdessen<TT> STRUC</TT>
bzw.<TT> ENDS</TT> schreiben). Ein diesen Befehlen voranstehendes
Label wird als Name der zu definierenden Struktur genommen; am Ende
der Definition ist der Name optional und kann von zur Festlegung des
L&auml;ngennamens (s.u.) genutzt werden. Das restliche Verfahren ist
simpel: Mit einem<TT> STRUCT</TT> wird der momentane
Programmz&auml;hler gesichert und auf Null zur&uuml;ckgesetzt. Alle
zwischen<TT> STRUCT</TT> und<TT> ENDSTRUCT</TT> definierten Labels
ergeben mithin die Offsets der einzelnen Datenfelder in der Struktur.
Die Reservierung des Platzes f&uuml;r die einzelnen Felder erfolgt
mit den f&uuml;r den jeweils aktiven Zielprozessor zul&auml;ssigen
Befehlen zur Speicherplatzreservierung, also z.B.<TT> DS.x</TT>
f&uuml;r die Motorolas oder<TT> DB</TT> &amp; Co. f&uuml;r Intels. Es
gelten hier auch gleichfalls die Regeln f&uuml;r das Aufrunden von
L&auml;ngen, um Alignments zu erhalten - wer also 'gepackte'
Strukturen definieren will, mu&szlig; eventuell ein<TT> PADDING
OFF</TT> voranstellen. Umgekehrt lassen sich Ausrichtungen
nat&uuml;rlich mit Befehlen wie<TT> ALIGN</TT> erzwingen.
<P>
Da eine solche Definition nur eine Art 'Prototypen' darstellt,
k&ouml;nnen nur Befehle benutzt werden, die Speicherplatz
reservieren, aber keine solchen, die Konstanten im Speicher ablegen
oder Code erzeugen.
<P>
Innerhalb von Strukturen definierte Labels (also die Namen der
Elemente) werden nicht direkt abgespeichert, sondern es wird ihnen
der Name der Struktur vorangestellt, durch ein Trennzeichen
verbunden, bei dem es sich defaultm&auml;&szlig;ig um den Unterstrich
(_) handelt. Dieses Verhalten l&auml;&szlig;t sich aber durch dem<TT>
STRUCT</TT>-Befehl mitgegebene Argumente steuern:
<UL>
<LI> <TT>NOEXTNAMES</TT> unterdr&uuml;ckt das Voranstellen des
    Strukturnamens. Der Programmierer ist in diesem Falle selber
    daf&uuml;r verantworlich, da&szlig; Feldnamen nicht mehrfach
    verwendet werden.</LI>
<LI> <TT>DOTS</TT> weist AS an, als verbindendes Zeichen einen Punkt
    anstelle des Unterstriches zu verwenden. Es sei jedoch
    ausdr&uuml;cklich darauf hingewiesen, da&szlig; der Punkt bei
    vielen Zielprozessoren ein Sonderfunktion zur Bitadressierung hat
    und diese zu Problemen f&uuml;hren kann!</LI>
</UL>
Des weiteren ist es m&ouml;glich, die Verwendung des Punktes durch
den Befehl
<PRE>

        dottedstructs &lt;on|off&gt;

</PRE>
dauerhaft ein- bzw. auszuschalten.
<P>
Neben den Namen der Elemente definiert AS beim Abschlu&szlig; der
Definition ein weiteres Symbol mit dem Namen<TT> LEN</TT>, das nach
dem gleichen Regeln um den Namen der Struktur erweitert wird - oder
um den Label-Namen, der optional bei<TT> ENDSTRUCT</TT> angegeben
werden kann.
<P>
Das ganze sieht dan in der Praxis z.B. so aus:
<PRE>

Rec     STRUCT
Ident   db      ?
Pad     db      ?
Pointer dd      ?
Rec     ENDSTRUCT

</PRE>
Hier w&uuml;rde z.B. dem Symbol<TT> REC_LEN</TT> der Wert 6
zugewiesen.
<P>

<H3><A NAME="sect_3_5_2_">3.5.2. Nutzung</A></H3>
<P>
Ist eine Struktur einmal definiert, ist die Nutzung denkbar einfach
und &auml;hnlich wie ein Makro: ein einfaches
<PRE>

thisrec Rec

</PRE>
reserviert Speicher in der Menge, wie er von der Struktur belegt
wird, und definiert gleichzeitig f&uuml;r jedes Element der Struktur
ein passendes Symbol mit dessen Adresse, in diesem Falle also<TT>
THISREC_IDENT, THISREC_PAD</TT> und<TT> THISREC_POINTER</TT>. Das
Label darf bei dem Aufruf einer Struktur naturgem&auml;&szlig; nicht
fehlen; wenn doch, gibt's eine Fehlermeldung.
<P>
<B> ACHTUNG!</B> Obwohl AS keine Argumente bei der Definition einer
Struktur erwartet, werden gegebene Argumente nicht als Fehler
gemeldet, sondern schlicht ignoriert. Dies ist vorgesehen, um in
Zukunft einer deklarierten Struktur direkt Werte zuweisen zu
k&ouml;nnen.
<P>

<H3><A NAME="sect_3_5_3_">3.5.3. geschachtelte Strukturen</A></H3>
<P>
Es ist ohne weiteres erlaubt, eine bereits definierte Struktur in
einer anderen Struktur aufzurufen. Das dabei ablaufende Verfahren ist
eine Kombination aus den beiden vorigen Punkten: Elemente der
Substruktur werden definiert, mit dem Namen dieser Instanz
vorangestellt, und vor diese zusammengesetzten Namen wird wieder der
Name der Struktur bzw. sp&auml;ter bei einer Benutzung gesetzt. Das
sieht dann z.B. so aus:
<PRE>

TreeRec struct
left    dd         ?
right   dd         ?
data    Rec
TreeRec endstruct

</PRE>
<P>

<H3><A NAME="sect_3_5_4_">3.5.4. Unions</A></H3>
<P>
Eine Union ist eine Sonderform einer Struktur, bei der die einzelnen
Elemente nicht hintereinander, sondern<EM> &uuml;bereinander</EM>
liegen, d.h. alle Elemente liegen an Startadresse 0 innerhalb der
Struktur und belegen den gleichen Speicherplatz.
Naturgem&auml;&szlig; tut so eine Definition nicht mehr, als einer
Reihe von Symbolen den Wert Null zuzuweisen, sie kann aber sinnvoll
sein, um programmtechnisch die &Uuml;berlappung der Elemente zu
verdeutlichen und den Code so etwas 'lesbarer' zu gestalten. Die
Gr&ouml;&szlig;e einer Struktur ist das Maximum der Gr&ouml;&szlig;en
aller Elemente.
<P>

<H3><A NAME="sect_3_5_5_">3.5.5. Strukturen und Sektionen</A></H3>
<P>
Im Verlaufe der Definition oder der Nutzung von Strukturen definierte
Symbole werden genauso behandelt wie normale Symbole, d.h. bei der
Nutzung innerhalb einer Sektion werden diese Symbole als lokal zu
dieser Sektion definiert. Analoges gilt aber auch f&uuml;r die
Strukturen selber, d.h. eine innerhalb einer Sektion definierte
Struktur kann nicht au&euml;rhalb der Sektion benutzt werden.
<P>

<H2><A NAME="sect_3_6_">3.6. bedingte Assemblierung</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Der Assembler unterst&uuml;tzt die bedingte Assemblierung mit Hilfe
der Konstrukte<TT> IF</TT>... sowie<TT> SWITCH</TT>... . Diese
Befehle wirken zur Assemblierzeit, indem entsprechend der Bedingung
Teile &uuml;bersetzt oder &uuml;bersprungen werden. Diese Befehle
sind also<I> nicht</I> mit den IF-Statements h&ouml;herer
Programmiersprachen zu vergleichen (obwohl es sehr verlockend
w&auml;re, den Assembler um die Strukturierungsbefehle h&ouml;herer
Sprachen zu erweitern...).
<P>
Die folgenden Konstrukte d&uuml;rfen beliebig (bis zum
Speicher&uuml;berlauf) geschachtelt werden.
<P>

<H3><A NAME="sect_3_6_1_">3.6.1. IF / ELSEIF / ENDIF</A></H3>
<A NAME="index_IF_1"></A><A NAME="index_ELSEIF_1"></A><A
NAME="index_ELSE_1"></A><A NAME="index_ENDIF_1"></A>
<P>
<TT> IF</TT> ist das gebr&auml;uchlichere und allgemeiner verwendbare
Konstrukt. Die allgemeine Form eines<TT> IF</TT>-Befehles lautet
folgenderma&szlig;en:
<PRE>

       IF       &lt;Ausdruck 1&gt;
        &lt;Block 1&gt;
       ELSEIF   &lt;Ausdruck 2&gt;
        &lt;Block 2&gt;
       (evtl. weitere ELSEIFs)
       ELSEIF
        &lt;Block n&gt;
       ENDIF

</PRE>
<TT>IF</TT> dient als Einleitung und wertet den ersten Ausdruck aus
und assembliert Block 1, falls der Ausdruck wahr (d.h. ungleich 0)
ist. Alle weiteren<TT> ELSEIF</TT>-Teile werden dann ignoriert. Falls
der Ausdruck aber nicht wahr ist, wird Block 1 &uuml;bersprungen und
Ausdruck 2 ausgewertet. Sollte dieser nun wahr sein, wird Block 2
assembliert. Die Zahl der<TT> ELSEIF</TT>-Teile ist variabel und
ergibt eine<TT> IF-THEN-ELSE</TT>-Leiter beliebiger L&auml;nge. Der
dem letzten<TT> ELSEIF</TT> (ohne Parameter) zugeordnete Block wird
nur assembliert, falls alle vorigen Ausdr&uuml;cke falsch ergaben und
bildet sozusagen einen ,,Default-Zweig''. Wichtig ist, da&szlig; von
den Bl&ouml;cken immer nur<I> einer</I> assembliert wird, und zwar
der erste, dessen zugeordnetes<TT> IF/ELSEIF</TT> einen wahren
Ausdruck hatte.
<P>
Die<TT> ELSEIF</TT>-Teile sind optional, d.h. auf<TT> IF</TT> darf
auch direkt<TT> ENDIF</TT> folgen, ein parameterloses<TT> ELSEIF</TT>
bildet aber immer den letzten Zweig. Ein<TT> ELSEIF</TT> bezieht sich
immer auf das letzte, noch nicht abgeschlossene<TT> IF</TT>.
<P>
Neben<TT> IF</TT> sind noch folgende weitere bedingte Befehle
definiert:<A NAME="index_IFDEF_1"></A><A NAME="index_IFNDEF_1"></A><A
NAME="index_IFUSED_1"></A><A NAME="index_IFNUSED_1"></A><A
NAME="index_IFEXIST_1"></A><A NAME="index_IFNEXIST_1"></A><A
NAME="index_IFB_1"></A><A NAME="index_IFNB_1"></A>
<UL>
<LI> <TT>IFDEF</TT> &lt;Symbol&gt; : wahr, falls das Symbol definiert
    wurde. Die Definition mu&szlig; vor<TT> IFDEF</TT> erfolgt
    sein.</LI>
<LI> <TT>IFNDEF</TT> &lt;Symbol&gt; : Umkehrung zu<TT> IFDEF</TT></LI>
<LI> <TT>IFUSED</TT> &lt;Symbol&gt; : wahr, falls das Symbol bisher
    mindestens einmal benutzt wurde.</LI>
<LI> <TT>IFNUSED</TT> &lt;Symbol&gt; : Umkehrung zu<TT> IFUSED</TT></LI>
<LI> <TT>IFEXIST</TT> &lt;Name: &gt; : wahr, falls die angegebene Datei
    existiert. F&uuml;r Schreibweise und Suchpfade gelten gleiche
    Regeln wie beim<TT> INCLUDE</TT>-Befehl (siehe Abschnitt <A
    HREF="#ref_SectInclude">3.9.2</A>).</LI>
<LI> <TT>IFNEXIST</TT> &lt;Name: &gt; : Umkehrung zu<TT>
    IFEXIST</TT></LI>
<LI> <TT>IFB</TT> &lt;Arg-Liste&gt; : wahr, falls alle Argumente der
    Parameterliste leer sind.</LI>
<LI> <TT>IFNB</TT> &lt;Arg-Liste&gt; : Umkehrung zu IFB.</LI>
</UL>
<P>
Anstelle von<TT> ELSEIF</TT> darf auch<TT> ELSE</TT> geschrieben
werden, weil das wohl alle so gewohnt sind....
<P>
Zu jeder<TT> IF...</TT>-Anweisung geh&ouml;rt ein entsprechendes<TT>
ENDIF</TT>, 'offene' Konstrukte f&uuml;hren zu einer Fehlermeldung am
Ende des Assemblierungslaufes. Die Zuordnung, welches<TT> ENDIF</TT>
AS mit welchem<TT> IF...</TT> 'gepaart' hat, l&auml;&szlig;t sich im
Listing erkennen: dort wird die Zeilennummer des entsprechenden<TT>
IF</TT>s angezeigt.
<P>

<H3><A NAME="sect_3_6_2_">3.6.2. SWITCH / CASE / ELSECASE / ENDCASE</A></H3>
<A NAME="index_SWITCH_1"></A><A NAME="index_CASE_1"></A><A
NAME="index_ELSECASE_1"></A><A NAME="index_ENDCASE_1"></A>
<P>
<TT> SWITCH</TT> ist ein Spezialfall von<TT> IF</TT> und f&uuml;r den
Fall gedacht, da&szlig; ein Ausdruck mit einer Reihe von Werten
verglichen werden soll. Dies ist nat&uuml;rlich auch mit<TT> IF</TT>
und einer Reihe von<TT> ELSEIF</TT>s machbar, die folgende Form
<PRE>

       SWITCH   &lt;Ausdruck&gt;
       ...
       CASE     &lt;Wert 1&gt;
       ...
       &lt;Block 1&gt;
       ...
       CASE &lt;Wert 2&gt;
       ...
       &lt;Block 2&gt;
       ...
       (weitere CASE-Konstrukte)
       ...
       CASE &lt;Wert n-1&gt;
       ...
       &lt;Block n-1&gt;
       ...
       ELSECASE
       ...
       &lt;Block n&gt;
       ...
       ENDCASE

</PRE>
bietet aber den Vorteil, da&szlig; der zu pr&uuml;fende Ausdruck nur
einmal hingeschrieben und berechnet werden mu&szlig;, er ist also
weniger fehleranf&auml;llig und etwas schneller als eine<TT>
IF</TT>-Kette, daf&uuml;r nat&uuml;rlich auch nicht so flexibel.
<P>
Es ist m&ouml;glich, bei den<TT> CASE</TT>-Anweisungen mehrere, durch
Kommata getrennte Werte anzugeben, um den entsprechenden Block in
mehreren F&auml;llen assemblieren zu lassen. Der<TT>
ELSECASE</TT>-Zweig dient wiederum als ,,Auffangstelle'' f&uuml;r den
Fall, da&szlig; keine der<TT> CASE</TT>-Bedingungen greift. Fehlt er
und fallen alle Pr&uuml;fungen negativ aus, so gibt AS eine Warnung
aus.
<P>
Auch wenn die Wertelisten der<TT> CASE</TT>-Teile sich
&uuml;berlappen, so wird immer nur<I> ein</I> Zweig ausgef&uuml;hrt,
und zwar bei Mehrdeutigkeiten der erste.
<P>
<TT> SWITCH</TT> dient nur der Einleitung des ganzen Konstruktes;
zwischen ihm und dem ersten<TT> CASE</TT> darf beliebiger Code stehen
(andere<TT> IF</TT>s d&uuml;rfen aber nicht offen bleiben!), im Sinne
eines durchschaubaren Codes sollte davon aber kein Gebrauch gemacht
werden.
<P>
&Auml;hnlich wie bei<TT> IF...</TT>-Konstrukten, mu&szlig; es
f&uuml;r jedes<TT> SWITCH</TT> genau ein<TT> ENDCASE</TT> geben.
Analog zu<TT> ENDIF</TT> wird bei<TT> ENDCASE</TT> im Listing die
Zeilennummer des korrespondierenden<TT> SWITCH</TT> angezeigt.
<P>

<H2><A NAME="sect_3_7_">3.7. Listing-Steuerung</A></H2>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>

<H3><A NAME="sect_3_7_1_">3.7.1. PAGE</A></H3>
<A NAME="index_PAGE_1"></A>
<P>
Mit<TT> PAGE</TT> kann man AS die Dimensionen des Papiers, auf dem
das Listing ausgedruckt werden soll, mitteilen. Als erster Parameter
wird dabei die Anzahl von Zeilen angegeben, nach der AS automatisch
einen Zeilenvorschub ausgeben soll. Zu ber&uuml;cksichtigen ist
allerdings, da&szlig; bei dieser Angabe die Kopfzeilen inklusive
einer evtl. mit<TT> TITLE</TT> spezifizierten Zeile nicht
mitgerechnet werden. Der Minimalwert f&uuml;r die Zeilenzahl ist 5,
der Maximalwert 255. Eine Angabe von 0 f&uuml;hrt dazu, da&szlig; AS
&uuml;berhaupt keine automatischen Seitenvorsch&uuml;be
ausf&uuml;hrt, sondern nur noch solche, die explizit durch<TT>
NEWPAGE</TT>-Befehle oder implizit am Ende des Listings (z.B. vor der
Symboltabelle) von AS ausgel&ouml;st wurden.
<P>
Die Angabe der Breite des Listings in Zeichen kann als optionaler
zweiter Parameter erfolgen und erf&uuml;llt zwei Zwecke: Zum einen
l&auml;uft der Zeilenz&auml;hler von AS korrekt weiter, wenn eine
Quell-Zeile &uuml;ber mehrere Listing-Zeilen geht, zum anderen gibt
es Drucker (wie z.B. Laserdrucker), die beim &Uuml;berschreiten des
rechten Randes nicht automatisch in eine neue Zeile umbrechen,
sondern den Rest einfach ,,verschlucken''. Aus diesem Grund
f&uuml;hrt AS auch den Zeilenumbruch selbstst&auml;ndig durch, d.h.
zu lange Zeilen werden in Bruchst&uuml;cke zerlegt, die eine
L&auml;nge kleiner oder gleich der eingestellten L&auml;nge haben. In
Zusammenhang mit Druckern, die einen automatischen Zeilenumbruch
besitzen, kann das aber zu doppelten Zeilenvorsch&uuml;ben
f&uuml;hren, wenn man als Breite exakt die Zeilenbreite des Druckers
angibt. Die L&ouml;sung in einem solchen Fall ist, als Zeilenbreite
ein Zeichen weniger anzugeben. Die eingestellte Zeilenbreite darf
zwischen 5 und 255 Zeichen liegen; analog zur Seitenl&auml;nge
bedeutet ein Wert von 0, da&szlig; AS keine Splittung der
Listing-Zeilen vornehmen soll; eine Ber&uuml;cksichtigung von zu
langen Zeilen im Listing beim Seitenumbruch kann dann nat&uuml;rlich
auch nicht mehr erfolgen.
<P>
Die Defaulteinstellung f&uuml;r die Seitenl&auml;nge ist 60 Zeilen,
f&uuml;r die Zeilenbreite 0; letztere Wert wird auch angenommen,
wenn<TT> PAGE</TT> nur mit einem Argument aufgerufen wird.
<P>
<B> ACHTUNG!</B> AS hat keine M&ouml;glichkeit, zu
&uuml;berpr&uuml;fen, ob die eingestellte Listing-L&auml;nge und
Breite mit der Wirklichkeit &uuml;bereinstimmen!
<P>

<H3><A NAME="sect_3_7_2_">3.7.2. NEWPAGE</A></H3>
<A NAME="index_NEWPAGE_1"></A>
<P>
<TT> NEWPAGE</TT> kann dazu benutzt werden, einen Seitenvorschub zu
erzwingen, obwohl die Seite noch gar nicht voll ist. Dies kann z.B.
sinnvoll sein, um logisch voneinander getrennte Teile im
Assemblerprogramm auch seitenm&auml;&szlig;ig zu trennen. Der
programminterne Zeilenz&auml;hler wird zur&uuml;ckgesetzt, der
Seitenz&auml;hler um Eins heraufgez&auml;hlt. Der optionale Parameter
steht in Zusammenhang mit einer hierarchischen Seitennumerierung, die
AS bis zu einer Kapiteltiefe von 4 unterst&uuml;tzt. 0 bedeutet dabei
immer die tiefste Kapitelebene, der Maximalwert kann sich
w&auml;hrend des Laufes ver&auml;ndern, wenn das auch verwirrend
wirken kann, wie folgendes Beispiel zeigt:
<BLOCKQUOTE>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
    <TR><TD NOWRAP> Seite 1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 0</TT></TD><TD NOWRAP> -> Seite 2</TD></TR>
    <TR><TD NOWRAP> Seite 2,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 1</TT></TD><TD NOWRAP> -> Seite 2.1</TD></TR>
    <TR><TD NOWRAP> Seite 2.1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 1</TT></TD><TD NOWRAP> -> Seite 3.1</TD></TR>
    <TR><TD NOWRAP> Seite 3.1,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 0</TT></TD><TD NOWRAP> -> Seite 3.2</TD></TR>
    <TR><TD NOWRAP> Seite 3.2,</TD><TD NOWRAP> Angabe<TT> NEWPAGE 2</TT></TD><TD NOWRAP> -> Seite 4.1.1</TD></TR>
    <TR><TD NOWRAP></TD></TR>
</TABLE></BLOCKQUOTE>
Je nach momentan vorhandener Kapiteltiefe kann<TT> NEWPAGE
&lt;Nummer&gt;</TT> also an verschiedenen Stellen eine Erh&ouml;hung
bedeuten. Ein automatischer Seitenvorschub wegen Zeilen&uuml;berlauf
oder ein fehlender Parameter ist gleichbedeutend mit<TT> NEWPAGE
0</TT>. Am Ende des Listings wird vor Ausgabe der Symboltabelle ein
implizites<TT> NEWPAGE &lt;bish. Maximum&gt;</TT> durchgef&uuml;hrt,
um sozusagen ein neues Hauptkapitel zu beginnen.
<P>

<H3><A NAME="sect_3_7_3_">3.7.3. MACEXP</A></H3>
<A NAME="index_MACEXP_1"></A>
<P>
Mit dem Befehl
<PRE>

        MACEXP  off

</PRE>
kann man erreichen, da&szlig; bei Makroexpansionen nur noch der
Makroaufruf und nicht der expandierte Text ausgegeben wird. Die ist
bei makrointensivem Code sinnvoll, um das Listing nicht ins Uferlose
wachsen zu lassen. Mit
<PRE>

        MACEXP  on

</PRE>
wird die vollst&auml;ndige Listingform wieder eingeschaltet, dies ist
auch die Default-Vorgabe.
<P>
Zwischen der Bedeutung von<TT> MACEXP</TT> f&uuml;r Makros und der
f&uuml;r alle anderen makroartigen Konstrukte (z.B.<TT> REPT</TT>)
besteht ein subtiler Unterschied: W&auml;hrend Makros intern ein Flag
besitzen, das anzeigt, ob Expansionen dieses Makros ausgegeben werden
sollen oder nicht, wirkt<TT> MACEXP</TT> direkt auf alle anderen
Konstrukte, die ,,vor Ort'' aufgel&ouml;st werden. Der Sinn dieser
Differenzierung besteht darin, da&szlig; es Makros geben kann, die
ausgetestet sind und die man nicht mehr sehen will, andere aber sehr
wohl noch.<TT> MACEXP</TT> dient hier als Default f&uuml;r das bei
der Definition des Makros zu setzende Flag, der mit den
Steuerparametern<TT> NOEXPAND/EXPAND</TT> &uuml;bersteuert werden
kann.
<P>
Die momentane Einstellung l&auml;&szlig;t sich aus dem Symbol<TT>
MACEXP</TT> auslesen.
<P>

<H3><A NAME="sect_3_7_4_">3.7.4. LISTING</A></H3>
<A NAME="index_LISTING_1"></A>
<P>
funktioniert wie<TT> MACEXP</TT> und akzeptiert die gleichen
Parameter, arbeitet aber wesentlich radikaler: Mit
<PRE>

        LISTING off

</PRE>
wird<I> &uuml;berhaupt</I> nichts mehr im Listing ausgegeben. Diese
Anweisung macht Sinn f&uuml;r erprobte Codeteile oder Includefiles,
um den Papierverbrauch nicht ins Unerme&szlig;liche zu steigern.<B>
ACHTUNG!</B> Wer sp&auml;ter das Gegenst&uuml;ck vergi&szlig;t,
bekommt auch keine Symboltabelle mehr zu sehen! Zus&auml;tzlich
zu<TT> ON</TT> und<TT> OFF</TT> akzeptiert<TT> LISTING</TT> auch<TT>
NOSKIPPED</TT> und<TT> PURECODE</TT> als Argument. Mit der<TT>
NOSKIPPED</TT>-Einstellung werden aufgrund bedingter Assemblierung
nicht assemblierte Teile nicht im Listing aufgef&uuml;hrt,
w&auml;hrend<TT> PURECODE</TT> - wie der Name schon erahnen
l&auml;&szlig;t - auch die<TT> IF</TT>-Konstrukte selber nicht mehr
im Listing auff&uuml;hrt. Diese Einstellungen sind n&uuml;tzlich,
wenn man Makros, die anhand von Parametern verschiedene Aktionen
ausf&uuml;hren, benutzt, und im Listing nur noch die jeweils
benutzten Teile sehen m&ouml;chte.
<P>
Die momentane Einstellung l&auml;&szlig;t sich aus dem Symbol<TT>
LISTING</TT> (0=<TT>OFF</TT>, 1=<TT>ON</TT>, 2=<TT>NOSKIPPED</TT>,
3=<TT>PURECODE</TT>) auslesen.
<P>

<H3><A NAME="sect_3_7_5_">3.7.5. PRTINIT und PRTEXIT</A></H3>
<A NAME="index_PRTINIT_1"></A><A NAME="index_PRTEXIT_1"></A>
<P>
Bei der Listingausgabe auf Druckern ist es oftmals sinnvoll, den
Drucker in eine andere Betriebsart (z.B. Schmalschrift) umzuschalten
und am Ende des Listings diese Betriebsart wieder zu deaktivieren.
Mit diesen Befehlen kann die Ausgabe dieser Steuerfolgen
automatisiert werden, indem man mit
<PRE>

        PRTINIT &lt;String&gt;

</PRE>
die Zeichenfolge angibt, die vor Listingbeginn an das
Ausgabeger&auml;t geschickt werden soll und mit
<PRE>

        PRTEXIT &lt;String&gt;

</PRE>
analog den Deinitialisierungsstring. In beiden F&auml;llen
mu&szlig;<TT> &lt;String&gt;</TT> ein Stringausdruck sein. Die
Syntaxregeln f&uuml;r Stringkonstanten erm&ouml;glichen es, ohne
Verrenkungen Steuerzeichen in den String einzubauen.
<P>
Bei der Ausgabe dieser Strings unterscheidet der Assembler<B>
nicht</B>, wohin das Listing geschickt wird, d.h.
Druckersteuerzeichen werden r&uuml;cksichtslos auch auf den
Bildschirm geschickt!
<P>
Beispiel :
<P>
Bei Epson-Druckern ist es sinnvoll, f&uuml;r die breiten Listings in
den Kompre&szlig;druck zu schalten. Die beiden Zeilen
<PRE>

        PRTINIT "\15"
        PRTEXIT "\18"

</PRE>
sorgen daf&uuml;r, da&szlig; der Kompre&szlig;druck ein- und nach dem
Druck wieder ausgeschaltet wird.
<P>

<H3><A NAME="sect_3_7_6_">3.7.6. TITLE</A></H3>
<A NAME="index_TITLE_1"></A>
<P>
Normalerweise versieht der Assembler bereits jede Listingseite mit
einer Titelzeile, die Quelldatei, Datum und Uhrzeit enth&auml;lt. Mit
diesem Befehl kann man den Seitenkopf um eine beliebige
zus&auml;tzliche Zeile erweitern. Der anzugebende String ist dabei
ein beliebiger Stringausdruck.
<P>
Beispiel:
<P>
Bei dem bereits oben angesprochenenen Epson-Drucker soll eine
Titelzeile im Breitdruck ausgegeben werden, wozu vorher der
Kompre&szlig;modus abgeschaltet werden mu&szlig;:
<PRE>

        TITLE   "\18\14Breiter Titel\15"

</PRE>
(Epson-Drucker schalten den Breitdruck automatisch am Zeilenende
aus.)
<P>

<H3><A NAME="sect_3_7_7_">3.7.7. RADIX</A></H3>
<A NAME="index_RADIX_1"></A>
<P>
<TT> RADIX</TT> mit einem numerischen Argument zwischen 2 und 36 legt
das Default-Zahlensystem f&uuml;r Integer-Konstanten fest, d.h. das
Zahlensystem, das angenommen wird, wenn man nichts ausdr&uuml;cklich
anderes angegeben hat. Defaultm&auml;&szlig;ig ist dies 10, und bei
der Ver&auml;nderung dieses Wertes sind einige Fallstricke zu
beachten, die in Abschnitt <A HREF="#ref_SectIntConsts">2.9.1</A>
beschrieben sind.
<P>
Unabh&auml;ngig von der momentanen Einstellung ist das Argument
von<TT> RADIX</TT><EM> immer dezimal</EM>; weiterhin d&uuml;rfen
keine symbolischen oder Formelausdr&uuml;cke verwendet werden,
sondern nur einfache Zahlenkonstanten!
<P>

<H3><A NAME="sect_3_7_8_">3.7.8. OUTRADIX</A></H3>
<A NAME="index_OUTRADIX_1"></A>
<P>
<TT> OUTRADIX</TT> is gewisserma&szlig;en das Gegenst&uuml;ck zu<TT>
RADIX</TT>: Mit ihm kann man festlegen, in welchem Zahlensystem
berechnete Integer-Ausdr&uuml;cke in Strings eingesetzt werden
sollen, wenn man \{...}-Konstrukte in Stringkonstanten verwendet
(siehe Abschnitt <A HREF="#ref_SectStringConsts">2.9.3</A>). Als
Argument sind wieder Werte zwischen 2 und 36 erlaubt; der Default ist
16.
<P>

<H2><A NAME="sect_3_8_">3.8. lokale Symbole</A></H2>
<A NAME="ref_ChapLocSyms"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Bei den lokalen Labels und den dazu eingef&uuml;hrten Sektionen
handelt es sich um eine grundlegend neue Funktion, die mit Version
1.39 eingef&uuml;hrt wird. Da dieser Teil sozusagen ,,1.0'' ist, ist
er sicherlich noch nicht der Weisheit letzter Schlu&szlig;.
Anregungen und (konstruktive) Kritik sind daher besonders
erw&uuml;nscht. Insbesondere habe ich die Verwendung von Sektionen
hier so dargestellt, wie ich sie mir vorstelle. Es kann dadurch
passiert sein, da&szlig; die Realit&auml;t nicht ganz meinem Modell
im Kopf entspricht. F&uuml;r den Fall von Diskrepanzen verspreche
ich, da&szlig; die Realit&auml;t der Dokumentation angepa&szlig;t
wird, und nicht umgekehrt, wie es bei gr&ouml;&szlig;eren Firmen
schon einmal vorgekommen sein soll...
<P>
AS erzeugt keinen linkf&auml;higen Code (und wird es wohl auch nicht
in n&auml;herer Zukunft tun<TT> :-(</TT> ). Diese Tatsache zwingt
dazu, ein Programm immer im ganzen zu &uuml;bersetzen. Dieser Technik
gegen&uuml;ber h&auml;tte eine Aufteilung in Linker-Module einige
Vorteile:
<UL>
<LI> k&uuml;rzere &Uuml;bersetzungszeiten, da lediglich die
    ge&auml;nderten Module neu &uuml;bersetzt werden
    m&uuml;ssen;</LI>
<LI> die M&ouml;glichkeit, durch Definition &ouml;ffentlicher und
    privater Symbole definierte Schnittstellen zwischen den Modulen
    festzulegen;</LI>
<LI> Durch die geringere L&auml;nge der einzelnen Module reduziert sich
    die Anzahl der Symbole im einzelnen Modul, so da&szlig;
    k&uuml;rzere und trotzdem eindeutige Symbolnamen benutzt werden
    k&ouml;nnen.</LI>
</UL>
Insbesondere der letzte Punkt hat mich pers&ouml;nlich immer etwas
gest&ouml;rt: War ein Label-Name einmal am Anfang eines 2000 Zeilen
langen Programmes benutzt, so durfte er nirgendwo wieder verwendet
werden --- auch nicht am anderen Ende des Quelltextes, wo Routinen
mit ganz anderem Kontext standen. Ich war dadurch gezwungen,
zusammengesetzte Namen der Form
<PRE>

&lt;Unterprogrammname&gt;_&lt;Symbolname&gt;

</PRE>
zu verwenden, die dann L&auml;ngen zwischen 15 und 25 Zeichen hatten
und das Programm un&uuml;bersichlich machten. Das im folgenden
eingehender beschriebene Sektionen-Konzept sollte zumindest den
beiden letzten genannten Punkten abhelfen. Es ist vollst&auml;ndig
optional: Wollen Sie keine Sektionen verwenden, so lassen Sie es
einfach bleiben und arbeiten weiter wie unter den &auml;lteren
AS-Versionen.
<P>

<H3><A NAME="sect_3_8_1_">3.8.1. Grunddefinition (SECTION/ENDSECTION)</A></H3>
<P>
Eine<I> Sektion</I> stellt einen durch spezielle Befehle eingerahmten
Teil des Assembler-Programmes dar und hat einen vom Programmierer
festlegbaren, eindeutigen Namen:
<PRE>

        ...
        &lt;anderer Code&gt;
        ...
        SECTION &lt;Sektionsname&gt;
        ...
        &lt;Code in der Sektion&gt;
        ...
        ENDSECTION [Sektionsname]
        ...
        &lt;anderer Code&gt;
        ...

</PRE>
Der Name f&uuml;r eine Sektion mu&szlig; den Konventionen f&uuml;r
einen Symbolnamen entsprechen; da AS Sektions-und Symbolnamen in
getrennten Tabellen speichert, darf ein Name sowohl f&uuml;r ein
Symbol als auch eine Sektion verwendet werden. Sektionsnamen
m&uuml;ssen in dem Sinne eindeutig sein, da&szlig; auf einer Ebene
nicht zwei Sektionen den gleichen Namen haben d&uuml;rfen (was es mit
den ,,Ebenen'' auf sich hat, erl&auml;utere ich im n&auml;chsten
Abschnitt). Das Argument zu<TT> ENDSECTION</TT> ist optional, es darf
auch weggelassen werden; Falls es weggelassen wird, zeigt AS den
Namen der Sektion an, der er das<TT> ENDSECTION</TT> zugeordnet hat.
Code in einer Sektion wird von AS genauso behandelt wie
au&szlig;erhalb, lediglich mit drei entscheidenden Unterschieden:
<UL>
<LI> Innerhalb der Sektion definierte Symbole (z.B. Labels,<TT>
    EQU</TT>s...) werden mit einer von AS intern vergebenen, der
    Sektion zugeordneten Nummer versehen. Diese Symbole sind von Code
    au&szlig;erhalb der Sektion nicht ansprechbar (das
    l&auml;&szlig;t sich nat&uuml;rlich durch Pseudobefehle
    variieren, aber dazu sp&auml;ter mehr).</LI>
<LI> Durch das zus&auml;tzliche Attribut kann ein Symbolname sowohl
    au&szlig;erhalb der Sektion als auch innerhalb definiert werden,
    das Attribut erlaubt also, Symbolnamen mehrfach zu benutzen, ohne
    da&szlig; AS Protest anmeldet.</LI>
<LI> Falls ein Symbol sowohl au&szlig;erhalb als auch innerhalb definiert
    ist, wird innerhalb der Sektion das ,,lokale'' verwendet, d.h. AS
    sucht in der Symboltabelle zuerst nach einem Symbol des
    gew&uuml;nschten Namens, das auch gleichzeitig der Sektion
    zugeordnet wurde. Erst danach wird nach einem globalen Symbol
    dieses Namens gefahndet.</LI>
</UL>
Mit diesem Mechanismus kann man z.B. den Code in Module aufteilen,
wie man es mit einem Linker getan h&auml;tte. Eine feinere Aufteilung
w&auml;re dagegen, alle Routinen in getrennte Sektionen zu verpacken.
Je nach L&auml;nge der Routinen k&ouml;nnen die nur intern
ben&ouml;tigten Symbole dann sehr kurze Namen haben.
<P>
Defaultm&auml;&szlig;ig unterscheidet AS Gro&szlig;-und
Kleinschreibung in Sektions- namen nicht; schaltet man jedoch in den
case-sensitiven Modus um, so wird die Schreibweise genauso wie bei
Symbolnamen ber&uuml;cksichtigt.
<P>
Die bisher beschriebene Aufteilung w&uuml;rde in etwa der Sprache C
entsprechen, in der alle Funktionen auf gleicher Ebene nebeneinander
stehen. Da mein ,,hochsprachliches'' Vorbild aber Pascal ist, bin ich
noch einen Schritt weiter gegangen:
<P>

<H3><A NAME="sect_3_8_2_">3.8.2. Verschachtelung und Sichtbarkeitsregeln</A></H3>
<P>
Es ist erlaubt, in einer Sektion weitere Sektionen zu definieren,
analog zu der M&ouml;glichkeit in Pascal, in einer Prozedur/Funktion
weitere Prozeduren zu definieren. Dies zeigt folgendes Beispiel:
<PRE>

sym     EQU        0

        SECTION    ModulA
         SECTION    ProcA1
sym       EQU        5
         ENDSECTION ProcA1
         SECTION    ProcA2
sym       EQU        10
         ENDSECTION ProcA2
        ENDSECTION ModulA

        SECTION    ModulB
sym      EQU        15
         SECTION    ProcB
         ENDSECTION ProcB
        ENDSECTION ModulB

</PRE>
Bei der Suche nach einem Symbol sucht AS zuerst ein Symbol, das der
aktuellen Sektion zugeordnet ist, und geht danach die ganze ,,Liste''
der Vatersektionen durch, bis er bei den globalen Symbolen angekommen
ist. Im Beispiel sehen die Sektionen die in Tabelle <A
HREF="#ref_TabSymErg">3.5</A> angegebenen Werte f&uuml;r das
Symbol<TT> sym</TT>.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sektion</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Wert</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>aus Sektion...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulA</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Global</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA1</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>5</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA1</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA2</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>10</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcA2</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>15</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ProcB</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>15</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ModulB</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 3.5: F&uuml;r die einzelnen Sektionen g&uuml;ltigen Werte<A
             NAME="ref_TabSymErg"></A>
</CENTER><P>

Diese Regel kann man durchbrechen, indem man explizit an den
Symbolnamen die Sektion anh&auml;ngt, aus der man das Symbol holen
will, und zwar in eckigen Klammern am Ende des Symbolnamens:
<PRE>

        move.l  #sym[ModulB],d0

</PRE>
Es d&uuml;rfen dabei nur Sektionsnamen verwendet werden, die eine
Obersektion zur aktuellen Sektion darstellen. Als Sonderwert sind die
Namen<TT> PARENT0..PARENT9</TT> erlaubt, mit denen man die n-ten
,,Vatersektionen'' relativ zur momentanen Sektion ansprechen
kann;<TT> PARENT0</TT> entspricht also der momentanen Sektion
selber,<TT> PARENT1</TT> der direkt &uuml;bergeordneten usw.
Anstelle<TT> PARENT1</TT> kann man auch kurz nur<TT> PARENT</TT>
schreiben. L&auml;&szlig;t man dagegen den Platz zwischen den
Klammern komplett frei, also etwa so
<PRE>

        move.l  #sym[],d0 ,

</PRE>
so erreicht man das globale Symbol.<B> ACHTUNG!</B> Wenn man explizit
ein Symbol aus einer Sektion anspricht, so wird auch nur noch bei den
Symbolen dieser Sektion gesucht, der Sektionsbaum wird nicht mehr bis
nach oben durchgegangen!
<P>
Analog zu Pascal ist es erlaubt, da&szlig; verschiedene Sektionen
Untersektionen gleichen Namens haben d&uuml;rfen, das Prinzip der
Lokalit&auml;t verhindert hier Irritationen. M.E. sollte man davon
aber trotzdem sparsamen Gebrauch machen, da in Symbol-und
Querverweisliste Symbole zwar mit der Sektion, in der sie definiert
wurden, gekennzeichnet werden, aber nicht mit der &uuml;ber dieser
Sektion evtl. liegenden ,,Sektionshierarchie'' (das h&auml;tte
einfach den Platz in der Zeile gesprengt); Unterscheidungen sind
dadurch nicht erkennbar.
<P>
Da ein<TT> SECTION</TT>-Befehl von selber kein Label definiert,
besteht hier ein wichtiger Unterschied zu Pascal: Eine
Pascal-Prozedur kann ihre Unterprozeduren/funktionen automatisch
,,sehen'', unter AS mu&szlig; man noch einen Einsprungpunkt extra
definieren. Das kann man z.B. mit folgendem Makro-P&auml;rchen tun:
<PRE>

proc    MACRO   name
        SECTION name
name    LABEL   $
        ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

</PRE>
Diese Beispiel zeigt gleichzeitig, da&szlig; die Lokalit&auml;t von
Labels in Makros nicht von den Sektionen beeinflu&szlig;t wird,
deshalb der Trick mit dem<TT> LABEL</TT>-Befehl.
<P>
Nat&uuml;rlich ist mit dieser Definition das Problen noch nicht ganz
gel&ouml;st, bisher ist das Einsprung-Label ja noch lokal und von
au&szlig;en nicht zu erreichen. Wer nun meint, man h&auml;tte das
Label einfach nur vor der SECTION-Anweisung plazieren m&uuml;ssen,
sei jetzt bitte ruhig, denn er verdirbt mir den &Uuml;bergang auf das
n&auml;chste Thema:
<P>

<H3><A NAME="sect_3_8_3_">3.8.3. PUBLIC und GLOBAL</A></H3>
<P>
Die<TT> PUBLIC</TT>-Anweisung erlaubt es, die Zugeh&ouml;rigkeit
eines Symbols zu einer bestimmten Sektion zu ver&auml;ndern. Es ist
m&ouml;glich, mit einem<TT> PUBLIC</TT>-Befehl mehrere Symbole zu
bearbeiten, ohne Beschr&auml;nkung der Allgemeinheit will ich aber
ein Beispiel mit nur einer Variable verwenden: Im einfachsten Falle
erkl&auml;rt man ein Symbol als vollst&auml;ndig global, d.h. es ist
von allen Stellen des Programmes ansprechbar:
<PRE>

        PUBLIC  &lt;Name&gt;

</PRE>
Da ein Symbol bei seiner Definition endg&uuml;ltig in der
Symboltabelle einsortiert wird, mu&szlig; diese Anweisung<B> vor</B>
der Definition des Symbols erfolgen. Alle<TT> PUBLIC</TT>s werden von
AS in einer Liste vermerkt und bei ihrer Definition aus dieser Liste
wieder entfernt. Bei Beendigung einer Sektion gibt AS Fehlermeldungen
f&uuml;r alle nicht aufgel&ouml;sten ,,Vorw&auml;rtsreferenzen'' aus.
<P>
Angesichts des hierarchischen Sektionenkonzepts erscheint die
Methode, ein Symbol als vollst&auml;ndig global zu definieren,
reichlich brachial. Es geht aber auch etwas differenzierter, indem
man zus&auml;tzlich einen Sektionsnamen angibt:
<PRE>

        PUBLIC  &lt;Name&gt;:&lt;Sektion&gt;

</PRE>
Damit wird das Symbol der genannten Sektion zugeordnet und damit auch
allen ihren Untersektionen zug&auml;nglich (es sei denn, diese
definieren wiederum ein Symbol gleichen Namens, das dann das
,,globalere'' &uuml;bersteuert). Naturgem&auml;&szlig; protestiert
AS, falls mehrere Untersektionen ein Symbol gleichen Namens auf die
gleiche Ebene exportieren wollen. Als Spezialwert f&uuml;r<TT>
&lt;Sektion&gt;</TT> sind die im vorigen Abschnitt genannten<TT>
PARENTx</TT>-Namen zugelassen, um das Symbol genau n Ebenen
hinaufzuexportieren. Es sind als Sektionen nur der momentanen Sektion
&uuml;bergeordnete Sektionen zugelassen, also keine, die im Baum
aller Sektionen in einem anderen Zweig stehen. Sollten dabei mehrere
Sektionen den gleichen Namen haben (dies ist legal), so wird die
tiefste gew&auml;hlt.
<P>
Mit diesem Werkzeug kann das obige Prozedurmakro nun Sinn ergeben:
<PRE>

proc    MACRO   name
        SECTION name
        PUBLIC  name:PARENT
name    LABEL   $
        ENDM

</PRE>
Diese Einstellung entspricht dem Modell von Pascal, in der eine
Unterprozedur auch nur von ihrem ,,Vater'' gesehen werden kann,
jedoch nicht vom ,,Gro&szlig;vater''.
<P>
Falls mehrere Untersektionen versuchen, ein Symbol gleichen Namens in
die gleiche Obersektion zu exportieren, meckert AS &uuml;ber doppelt
definierte Symbole, was an sich ja korrekt ist. War das gewollt, so
mu&szlig; man die Symbole in irgendeiner Weise ,,qualifizieren'',
damit sie voneinander unterschieden werden k&ouml;nnen. Dies ist mit
der<TT> GLOBAL</TT>-Anweisung m&ouml;glich. Die Syntax von<TT>
GLOBAL</TT> ist der von<TT> PUBLIC</TT> identisch, das Symbol bleibt
aber lokal, anstatt einer h&ouml;heren Sektion zugeordnet zu werden.
Stattdessen wird ein weiteres Symbol gleichen Werts erzeugt, dem
jedoch der Untersektionsname mit einem Unterstrich vorangestellt
wird, und nur dieses Symbol wird der Sektionsangabe entsprechend
&ouml;ffentlich gemacht. Definieren z.B. zwei Sektionen<TT> A</TT>
und<TT> B</TT> ein Symbol<TT> SYM</TT> und exportieren es mit<TT>
GLOBAL</TT> zu ihrer Vatersektion, so werden dort die Symbole unter
den Namen<TT> A_SYM</TT> und<TT> B_SYM</TT> eingeordnet.
<P>
Falls zwischen Quell- und Zielsektion mehrere Stufen stehen sollten,
so wird entsprechend der komplette Namenszweig von der Ziel- bis zur
Quellsektion dem Symbolnamen vorangestellt.
<P>

<H3><A NAME="sect_3_8_4_">3.8.4. FORWARD</A></H3>
<P>
So sch&ouml;n das bisher besprochene Modell ist, ein bei Pascal nicht
auftauchendes Detail macht &Auml;rger: die bei Assembler
m&ouml;glichen Vorw&auml;rtsreferenzen. Bei Vorw&auml;rtsreferenzen
kann es sein, da&szlig; AS im ersten Pass auf ein Symbol einer
h&ouml;heren Sektion zugreift. Dies ist an sich nicht weiter
tragisch, solange im zweiten Pass das richtige Symbol genommen wird,
es k&ouml;nnen aber Unf&auml;lle der folgenden Art passieren:
<PRE>

loop:   .
        &lt;Code&gt;
        ..
        SECTION sub
        ..              ; ***
        bra.s   loop
        ..
loop:   ..
        ENDSECTION
        ..
        jmp     loop    ; Hauptschleife

</PRE>
AS wird im ersten Pass das globale Label<TT> loop</TT> verwenden,
sofern das Programmst&uuml;ck bei<TT> &lt;Code&gt;</TT> hinreichend
lang ist, wird er sich &uuml;ber eine zu gro&szlig;e Sprungdistanz
beklagen und den zweiten Pass erst gar nicht versuchen. Um die
Uneindeutigkeit zu vermeiden, kann man den Symbolnamen mit einem
expliziten Bezug versehen:
<PRE>

        bra.s   loop[sub]

</PRE>
Falls ein lokales Symbol h&auml;ufig referenziert wird, k&ouml;nnen
die vielen Klammern mit dem<TT> FORWARD</TT>-Befehl eingespart
werden. Das Symbol wird damit explizit als lokal angek&uuml;ndigt. AS
wird dann bei Zugriffen auf dieses Symbol automatisch nur im lokalen
Symbolbereich suchen. In diesem Falle m&uuml;&szlig;te an der mit<TT>
***</TT> gekennzeichneten Stelle daf&uuml;r der Befehl
<PRE>

        FORWARD loop

</PRE>
stehen. Damit<TT> FORWARD</TT> Sinn macht, mu&szlig; es nicht nur vor
der Definition des Symbols, sondern vor seiner ersten Benutzung in
der Sektion gegeben werden. Ein Symbol gleichzeitig privat und
&ouml;ffentlich zu definieren, ergibt keinen Sinn und wird von AS
auch angemahnt.
<P>

<H3><A NAME="sect_3_8_5_">3.8.5. Geschwindigkeitsaspekte</A></H3>
<P>
Die mehrstufige Suche in der Symboltabelle und die Entscheidung, mit
welchem Attribut ein Symbol eingetragen werden soll, kosten
naturgem&auml;&szlig; etwas Rechenzeit. Ein 1800 Zeilen langes
8086-Programm z.B. wurde nach der Umstellung auf Sektionen statt in
33 in 34,5 Sekunden assembliert (80386 SX, 16MHz, 3 Durchg&auml;nge).
Der Overhead h&auml;lt sich also in Grenzen: Ob man ihn in Kauf
nehmen will, ist (wie am Anfang erw&auml;hnt) eine Frage des
Geschmacks; man kann AS genauso gut ohne Sektionen verwenden.
<P>

<H2><A NAME="sect_3_9_">3.9. Diverses</A></H2>
<P>

<H3><A NAME="sect_3_9_1_">3.9.1. SHARED</A></H3>
<A NAME="ref_ChapShareOrder"></A><A NAME="index_SHARED_3"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Mit diesem Befehl weist man den AS an, die in der Parameterliste
angegebenen Symbole (egal ob Integer, Gleitkomma oder String) im
Sharefile mit ihren Werten abzulegen. Ob eine solche Datei
&uuml;berhaupt und in welchem Format erzeugt wird, h&auml;ngt von den
in <A HREF="#ref_SectCallConvention">2.4</A> beschriebenen
Kommandozeilenschaltern ab. Findet AS diesen Befehl und es wird keine
Datei erzeugt, f&uuml;hrt das zu einer Warnung.
<P>
<B> VORSICHT!</B> Ein eventuell der Befehlszeile anh&auml;ngender
Kommentar wird in die erste, ausgegebene Zeile mit &uuml;bertragen
(sofern die Argumentliste von<TT> SHARED</TT> leer ist, wird nur der
Kommentar ausgegeben). Falls die Share-Datei f&uuml;r C oder Pascal
erzeugt wird, sind einen C/Pascal-Kommentar schlie&szlig;ende
Zeichenfolgen (*/ bzw. *)) im Kommentar zu vermeiden. AS pr&uuml;ft
dies<I> nicht</I>!
<P>

<H3><A NAME="sect_3_9_2_">3.9.2. INCLUDE</A></H3>
<A NAME="index_INCLUDE_1"></A><A NAME="ref_SectInclude"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Dieser Befehl f&uuml;gt die im Parameter angegebene Datei (die
optional in G&auml;nsef&uuml;&szlig;chen eingeschlossen sein darf) so
im Text ein, als ob sie dort stehen w&uuml;rde. Dieser Befehl ist
sinnvoll, um Quelldateien aufzuspalten, die alleine nicht in den
Speicher passen w&uuml;rden oder um sich ''Toolboxen'' zu erzeugen.
<P>
Falls der angegebene Dateiname keine Endung hat, wird er automatisch
um die Endung<TT> INC</TT> erweitert.
<P>
Mit der Kommandozeilenoption
<PRE>

   -i &lt;Pfadliste&gt;

</PRE>
l&auml;&szlig;t sich eine Liste von Verzeichnissen angeben, in denen
automatisch zus&auml;tzlich nach der Includedatei gesucht werden
soll. Wird die Datei nicht gefunden, so ist dies ein<I> fataler</I>
Fehler, d.h. der Assembler bricht sofort ab.
<P>
Aus Kompatibilit&auml;tsgr&uuml;nden ist es erlaubt, den Namen in
G&auml;nsef&uuml;&szlig;chen zu schreiben,
<PRE>

        INCLUDE stddef51

</PRE>
und
<PRE>

        INCLUDE "stddef51.inc"

</PRE>
sind also &auml;quivalent.<B> ACHTUNG!</B> Wegen dieser Wahlfreiheit
ist hier nur eine Stringkonstante, aber kein Stringausdruck
zul&auml;ssig!
<P>
Sollte der Dateiname eine Pfadangabe enthalten, so wird die Suchliste
ignoriert.
<P>

<H3><A NAME="sect_3_9_3_">3.9.3. BINCLUDE</A></H3>
<A NAME="index_BINCLUDE_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> BINCLUDE</TT> dient dazu, in den von AS erzeugten Code
Bin&auml;rdaten einzubetten, die von einem anderen Programm erzeugt
wurden (das kann nat&uuml;rlich theoretisch auch von AS selber
erzeugter Code sein...).<TT> BINCLUDE</TT> hat drei Formen:
<PRE>

   BINCLUDE &lt;Datei&gt;

</PRE>
In dieser Form wird die Datei komplett eingebunden.
<PRE>
 
   BINCLUDE &lt;Datei&gt;,&lt;Offset&gt;

</PRE>
In dieser Form wird der Inhalt der Datei ab &lt;Offset&gt; bis zum
Ende der Datei eingebunden.
<PRE>

   BINCLUDE &lt;Datei&gt;,&lt;Offset&gt;,&lt;Len&gt;

</PRE>
In dieser Form werden &lt;Len&gt; Bytes ab Offset &lt;Offset&gt;
eingebunden.
<P>
Es gelten die gleichen Regeln bez&uuml;glich Suchpfaden wie bei<TT>
INCLUDE</TT>.
<P>

<H3><A NAME="sect_3_9_4_">3.9.4. MESSAGE, WARNING, ERROR und FATAL</A></H3>
<A NAME="index_MESSAGE_1"></A><A NAME="index_WARNING_1"></A><A
NAME="index_ERROR_1"></A><A NAME="index_FATAL_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Der Assembler pr&uuml;ft zwar die Quelltexte so streng wie
m&ouml;glich und liefert diffenzierte Fehlermeldungen, je nach
Anwendung kann es aber sinnvoll sein, unter bestimmten Bedingungen
zus&auml;tzliche Fehlermeldungen auszul&ouml;sen, mit denen sich
logische Fehler automatisch pr&uuml;fen lassen. Der Assembler
unterscheidet drei Typen von Fehlermeldungen, die &uuml;ber die drei
Befehle auch dem Programmierer zug&auml;nglich sind:
<UL>
<LI> <TT>WARNING</TT>: Fehler, die auf m&ouml;glicherweise falschen oder
    ineffizienten Code hinweisen. Die Assemblierung l&auml;uft
    weiter, eine Codedatei wird erzeugt.</LI>
<LI> <TT>ERROR</TT>: echte Fehler im Programm. Die Assemblierung
    l&auml;uft weiter, um m&ouml;gliche weitere Fehler in einem
    Durchgang entdecken und korrigieren zu k&ouml;nnen. Eine
    Codedatei wird nicht erzeugt.</LI>
<LI> <TT>FATAL</TT>: schwerwiegende Fehler, die einen sofortigen Abbruch
    des Assemblers bedingen. Eine Codedatei kann m&ouml;glicherweise
    entstehen, ist aber unvollst&auml;ndig.</LI>
</UL>
Allen drei Befehlen ist das Format gemeinsam, in dem die
Fehlermeldung angegeben werden mu&szlig;: Ein beliebig
(berechneter?!) Stringausdruck, der damit sowohl eine Konstante als
auch variabel sein darf.
<P>
Diese Anweisungen ergeben nur in Zusammenhang mit bedingter
Assemblierung Sinn. Ist f&uuml;r ein Programm z.B. nur ein begrenzter
Adre&szlig;raum vorhanden, so kann man den &Uuml;berlauf
folgenderma&szlig;en testen:
<PRE>

ROMSize equ     8000h   ; 27256-EPROM

ProgStart: ..
        &lt;das eigentliche Programm&gt;
           ..
ProgEnd:
        if      ProgEnd-ProgStart&gt;ROMSize
         error   "\aDas Programm ist zu lang!"
        endif

</PRE>
Neben diesen fehlererzeugenden Befehlen gibt es noch den Befehl<TT>
MESSAGE</TT>, der einfach nur eine Meldung auf der Konsole bzw. im
Listing erzeugt. Seine Benutzung ist den anderen drei Befehlen
gleich.
<P>

<H3><A NAME="sect_3_9_5_">3.9.5. READ</A></H3>
<A NAME="index_READ_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> READ</TT> ist sozusagen das Gegenst&uuml;ck zu der vorigen
Befehlsgruppe: mit ihm ist es m&ouml;glich,<I> w&auml;hrend</I> der
Assemblierung Werte von der Tastatur einzulesen. Wozu das gut sein
soll? Um das darzulegen, soll hier ausnahmsweise einmal das Beispiel
vor die genauere Erl&auml;uterung gezogen werden:
<P>
Ein Programm ben&ouml;tigt zum Datentransfer einen Puffer mit einer
zur &Uuml;bersetzungszeit festzulegenden Gr&ouml;&szlig;e. Um die
Gr&ouml;&szlig;e des Puffers festzulegen, k&ouml;nnte man sie einmal
mit<TT> EQU</TT> in einem Symbol ablegen, es geht aber auch
interaktiv mit<TT> READ</TT> :
<PRE>

        IF      MomPass=1
         READ    "Puffer (Bytes)",BufferSize
        ENDIF

</PRE>
Auf diese Weise k&ouml;nnen Programme sich w&auml;hrend der
&Uuml;bersetzung interaktiv konfigurieren, man kann sein Programm
z.B. jemandem geben, der es mit seinen Parametern &uuml;bersetzen
kann, ohne im Quellcode ,,herumstochern'' zu m&uuml;ssen. Die im
Beispiel gezeigte<TT> IF-</TT> Abfrage sollte &uuml;brigens immer
verwendet werden, damit der Anwender nur einmal mit der Abfrage
bel&auml;stigt wird.
<P>
<TT> READ</TT> &auml;hnelt sehr stark dem<TT> SET-</TT> Befehl, nur
da&szlig; der dem Symbol zuzuweisende Wert nicht rechts vom
Schl&uuml;sselwort steht, sondern von der Tastatur eingelesen wird.
Dies bedeutet z.B. auch, da&szlig; AS anhand der Eingabe automatisch
festlegt, ob es sich um eine Integer- oder Gleitkommazahl oder einen
String handelt und anstelle einzelner Konstanten auch ganze
Formelausdr&uuml;cke eingegeben werden k&ouml;nnen.
<P>
<TT> READ</TT> darf entweder nur einen Parameter oder zwei Parameter
haben, denn die Meldung zur Eingabeaufforderung ist optional. Fehlt
sie, so gibt AS eine aus dem Symbolnamen konstruierte Meldung aus.
<P>

<H3><A NAME="sect_3_9_6_">3.9.6. RELAXED</A></H3>
<A NAME="ref_SectRELAXED"></A><A NAME="index_RELAXED_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
Defaultm&auml;&szlig;ig ist einer Prozessorfamilie eine bestimmte
Schreibweise von Integer-Konstanten zugeordnet (die i.a. der
Herstellervorgabe entspricht, solange der nicht eine allzu
abgefahrene Syntax benutzt...). Nun hat aber jeder seine
pers&ouml;nlichen Vorlieben f&uuml;r die eine oder andere
Schreibweise und kann gut damit leben, da&szlig; sich seine Programme
nicht mehr mit dem Standard-Assembler &uuml;bersetzen lassen. Setzt
man ein
<PRE>

        RELAXED ON

</PRE>
an den Programmanfang, so kann man fortan alle Schreibweisen beliebig
gemischt und durcheinander verwenden; bei jedem Ausdruck versucht AS
automatisch zu ermitteln, welche Schreibweise verwendet wurde.
Da&szlig; diese Automatik nicht immer das Ergebnis liefert, das man
sich vorgestellt hat, ist auch der Grund, weshalb diese Option
explizit eingeschaltet werden mu&szlig; (und man sich davor
h&uuml;ten sollte, sie einfach in einem existierenden Programm
dazuzusetzen): Ist nicht durch vor- oder nachgestellte Zeichen zu
erkennen, da&szlig; es sich um Intel- oder Motorola-Konstanten
handelt, wird im C-Modus gearbeitet. Eventuell vorangestellte,
eigentlich &uuml;berfl&uuml;ssige Nullen haben in diesem Modus
durchaus eine Bedeutung:
<PRE>

        move.b  #08,d0

</PRE>
Diese Konstante w&uuml;rde als Oktalkonstante verstanden werden, und
weil Oktalzahlen nur Ziffern von 0..7 enthalten k&ouml;nnen,
f&uuml;hrt das zu einem Fehler. Dabei h&auml;tte man in diesem Fall
noch Gl&uuml;ck gehabt, bei der Zahl<TT> 077</TT> z.B. h&auml;tte man
ohne Meldung Probleme bekommen. Ohne<TT> RELAXED</TT>-Modus w&auml;re
in beiden F&auml;llen klar gewesen, da&szlig; es sich um dezimale
Konstanten handelt.
<P>
Die momentane Einstellung kann aus dem gleichnamigen Symbol
ausgelesen werden.
<P>

<H3><A NAME="sect_3_9_7_">3.9.7. END</A></H3>
<A NAME="index_END_1"></A>
<P>
<EM> G&uuml;ltigkeit: alle Prozessoren</EM>
<P>
<TT> END</TT> kennzeichnet das Ende des Assemblerprogrammes. Danach
noch in der Quelldatei stehende Zeilen werden ignoriert.<B>
WICHTIG:</B><TT> END</TT> darf zwar aus einem Makro heraus aufgerufen
werden, der Stapel der bedingten Assemblierung wird aber nicht
automatisch abger&auml;umt. Das folgende Konstrukt f&uuml;hrt daher
zu einer Fehlermeldung:
<PRE>

        IF      KeineLustMehr
         END
        ENDIF

</PRE>
Optional darf<TT> END</TT> auch einen Integer-Ausdruck als Argument
haben, der den Startpunkt des Programmes vermerkt. Dieser wird von AS
in einem speziellen Record der Datei vermerkt und kann z.B. von P2HEX
weiterverarbeitet werden.
<P>
<TT> END</TT> war eigentlich schon immer in AS definiert, nur war es
bei fr&uuml;heren Versionen von AS aus Kompatibilit&auml;t zu anderen
Assemblern vorhanden und hatte keine Wirkung.
<P>

<H1><A NAME="sect_4_">4. Prozessorspezifische Hinweise</A></H1>
<P>
Ich habe mich bem&uuml;ht, die einzelnen Codegeneratoren
m&ouml;glichst kompatibel zu den Originalassemblern zu halten, jedoch
nur soweit, wie es keinen unvertretbaren Mehraufwand bedeutete.
Wichtige Unterschiede, Details und Fallstricke habe ich im folgenden
aufgelistet.
<P>

<H2><A NAME="sect_4_1_">4.1. 6811</A></H2>
<P>
,,Wo gibt es denn das zu kaufen, den HC11 in NMOS?'', fragt jetzt
vielleicht der eine oder andere. Gibt es nat&uuml;rlich nicht, aber
ein H l&auml;&szlig;t sich nun einmal nicht in einer Hexzahl
darstellen (&auml;ltere Versionen von AS h&auml;tten solche Namen
deswegen nicht akzeptiert), und dann habe ich die Buchstaben gleich
ganz weggelassen...
<P>
<BLOCKQUOTE>
    <I> ,,Jemand, der sagt, etwas sei unm&ouml;glich,sollte
    wenigstens so kooperativ sein, denjenigen, der es gerade tut,
    nicht am Arbeiten zu hindern.''</I>
</BLOCKQUOTE>
Ab und zu ist man gezwungen, seine Meinung zu revidieren. Vor einigen
Versionen hatte ich an dieser Stelle noch behauptet, ich k&ouml;nne
es im Parser von AS nicht realisieren, da&szlig; man die Argumente
von<TT> BSET/BCLR</TT> bzw.<TT> BRSET/BRCLR</TT> auch mit Leerzeichen
trennen kann. Offensichtlich kann selbiger aber mehr, als ich
vermutet habe...nach der soundsovielten Anfrage habe ich mich noch
einmal drangesetzt, und jetzt scheint es zu laufen. Man darf sowohl
Leerzeichen als auch Kommas verwenden, aber nicht in allen Varianten,
um es nicht uneindeutig zu machen: Es gibt zu jeder Befehlsvariante
zwei M&ouml;glichkeiten; eine, die nur Kommas verwendet, sowie eine,
wie sie von Motorola wohl definiert wurde (leider sind die
Datenb&uuml;cher nicht immer so gut wie die zugeh&ouml;rige
Hardware...):
<PRE>

   Bxxx  abs8 #mask         entspricht    Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      entspricht    Bxxx  disp8,X,#mask
   BRxxx abs8 #mask adr     entspricht    BRxxx abs8,#mask,adr
   BRxxx disp8,X #mask adr  entspricht    BRxxx disp8,X,#mask,adr

</PRE>
Dabei steht<TT> xxx</TT> entweder f&uuml;r<TT> SET</TT> oder<TT>
CLR</TT> und<TT> #mask</TT> f&uuml;r die zu verwendende Bitmaske; der
Lattenzaun ist dabei optional. Anstelle des X-Registers darf
nat&uuml;rlich auch Y verwendet werden.
<P>
Mit der K4-Version des HC11 hat Motorola ein Banking-Schema
eingef&uuml;hrt, mit dem man zwar einerseits eine zu klein gewordene
Architektur noch einmal aufbohren kann, den Software- und
Tool-Entwicklern aber nicht unbedingt das Leben einfacher macht...wie
stellt man so etwas vern&uuml;nftig dar?
<P>
Die K4-Architektur<EM> erweitert</EM> den Adre&szlig;raum des HC11 um
2x512 Kbyte, so da&szlig; jetzt insgesamt 64+1024=1088 Kbyte zur
Verf&uuml;gung stehen. AS tut so, als ob es sich dabei um einen
Adre&szlig;raum handeln w&uuml;rde, der folgenderma&szlig;en
organisiert ist:
<UL>
<LI> $000000...$00ffff: der alte HC11-Adre&szlig;raum</LI>
<LI> $010000...$08ffff: Fenster 1</LI>
<LI> $090000...$10ffff: Fenster 2</LI>
</UL>
&Uuml;ber den<TT> ASSUME</TT>-Befehl teilt man AS mit, wie die
Banking-Register eingestellt sind und damit, wie und wo die
erweiterten Bereiche eingeblendet werden. Bei absoluten
Adressierungen mit Adressen jenseits $10000 berechnet AS dann
automatisch, welche Adresse innerhalb der ersten 64K anzusprechen
ist. Das kann nat&uuml;rlich wieder nur f&uuml;r direkte
Adressierungsarten funktionieren, bei indizierten/indirekten
Adre&auml;usdr&uuml;cken ist der Programmierer daf&uuml;r
verantwortlich, &uuml;ber die momentan aktiven Banks den
&Uuml;berblick zu behalten!
<P>
Wer sich nicht ganz sicher ist, ob die momentane Einstellung korrekt
ist, kann den Pseudobefehl<TT> PRWINS</TT> benutzen, der dann z.B.
<PRE>

MMSIZ e1 MMWBR 84 MM1CR 00 MM2CR 80
Window 1: 10000...12000 --&gt; 4000...6000
Window 1: 90000...94000 --&gt; 8000...c000

</PRE>
ausgibt. Ein z.B. an Stelle $10000 liegender Befehl
<PRE>

        jmp     *+3

</PRE>
w&uuml;rde effektiv einen Sprung auf Adresse $4003 ausl&ouml;sen.
<P>

<H2><A NAME="sect_4_2_">4.2. PowerPC</A></H2>
<P>
Sicher hat es ein bi&szlig;chen den Anflug einer Schnapsidee, einen
Prozessor, der eher f&uuml;r den Einsatz in Workstations konzipiert
wurde, in AS einzubauen, der sich ja eher an Programmierer von
Einplatinencomputern wendet. Aber was heute noch das Hei&szlig;este
vom Hei&szlig;en ist, ist es morgen schon nicht mehr, und sowohl der
Z80 als auch der 8088 haben ja inzwischen die Mutation von der
Personal Computer-CPU zum sog. ,,Mikrocontroller'' vollzogen. Mit dem
Erscheinen von MPC505 und PPC403 hat sich die Vermutung dann auch
best&auml;tigt, da&szlig; IBM und Motorola diese Prozessorserie auf
allen Ebenen durchdr&uuml;cken wollen.
<P>
Die Unterst&uuml;tzung ist momentan noch nicht vollst&auml;ndig: Als
Pseudobefehle zur Datenablage werden momentan provisorisch die
Intel-Mnemonics unterst&uuml;tzt und es fehlen die etwas
ungew&ouml;hnlicheren, in <A HREF="#cite_Mot601">[57]</A> genannten
RS6000-Befehle (die aber hoffentlich keiner vermi&szlig;t...). Das
wird aber nachgeholt, sobald Informationen verf&uuml;gbar sind!
<P>

<H2><A NAME="sect_4_3_">4.3. DSP56xxx</A></H2>
<P>
Motorola, was ist nur in Dich gefahren! Wer bei Dir ist nur auf das
schmale Brett gekommen, die einzelnen parallelen Datentransfers
ausgerechnet durch Leerzeichen zu trennen! Wer immer nun seine Codes
etwas &uuml;bersichtlicher formatieren will, z.B. so:
<PRE>

        move    x:var9 ,r0
        move    y:var10,r3   ,

</PRE>
der ist gekniffen, weil das Leerzeichen als Trennung paralleler
Datentransfers erkannt wird!
<P>
Sei's drum; Motorola hat es so definiert, und ich kann es nicht
&auml;ndern. Als Trennung der Operationen sind statt Leerzeichen auch
Tabulatoren zugelassen, und die einzelnen Teile sind ja wieder ganz
normal mit Kommas getrennt.
<P>
In <A HREF="#cite_Mot56">[52]</A> steht, da&szlig; bei den
Befehlen<TT> MOVEC, MOVEM, ANDI</TT> und<TT> ORI</TT> auch die
allgemeineren Mnemonics<TT> MOVE, AND</TT> und<TT> OR</TT> verwendet
werden k&ouml;nnen. Bei AS geht das (noch) nicht.
<P>

<H2><A NAME="sect_4_4_">4.4. H8/300</A></H2>
<P>
Bei der Assemblersyntax dieser Prozessoren hat Hitachi reichlich bei
Motorola abgekupfert (was so verkehrt ja nun auch nicht war...), nur
leider wollte die Firma unbedingt ihr eigenes Format f&uuml;r
Hexadezimalzahlen einf&uuml;hren, und dazu noch eines, das
&auml;hnlich wie bei Microchip Hochkommas verwendet. Das konnte (und
wollte) ich bei AS nicht nachvollziehen, bei dem Hochkommas zur
Einrahmung von ASCII-Sequenzen benutzt werden. Anstelledessen werden
Zahlen in der &uuml;blichen Motorola-Syntax geschrieben, d.h. mit
einem Dollarzeichen.
<P>

<H2><A NAME="sect_4_5_">4.5. SH7000/7600/7700</A></H2>
<P>
Leider hat Hitachi auch hier wieder das Extrawurst-Format f&uuml;r
Hexadezimalzahlen verwendet, und wieder habe ich in AS das nicht
nachvollzogen...bitte Motorola-Syntax benutzen!
<P>
Bei der Verwendung von Literalen und dem<TT> LTORG</TT>-Befehl sind
einige Details zu beachten, wenn man nicht auf einmal mit
eigenartigen Fehlermeldungen konfrontiert werden will:
<P>
Literale existieren, weil der Prozessor nicht in der Lage ist,
Konstanten au&szlig;erhalb des Bereiches von -128 bis 127 mit
immediate-Adressierung zu laden. AS (und der Hitachi-Assembler)
verstecken diese Unzul&auml;nglichkeit, indem sie automatisch
entsprechende Konstanten im Speicher ablegen, die dann mittels
PC-relativer Adressierung angesprochen werden. Die Frage, die sich
nun erhebt, ist die, wo diese Konstanten im Speicher abgelegt werden
sollen. AS legt sie nicht sofort ab, sondern sammelt sie so lange
auf, bis im Programm eine<TT> LTORG</TT>-Anweisung auftritt. Dort
werden alle Konstanten abgelegt, wobei deren Adressen mit ganz
normalen Labels versehen werden, die man auch in der Symboltabelle
sehen kann. Ein Label hat die Form
<PRE>

   LITERAL_s_xxxx_n   .

</PRE>
Dabei repr&auml;sentiert<TT> s</TT> den Typ des Literals.
Unterschieden werden Literale, die 16-Bit-Konstanten (<TT>s=W</TT>),
32-Bit-Konstanten (<TT>s=L</TT>) oder Vorw&auml;rtsreferenzen, bei
denen AS die Operandengr&ouml;&szlig;e nicht im voraus erkennen kann
(<TT>s=F</TT>), enthalten. F&uuml;r<TT> W</TT> oder<TT> L</TT>
bedeutet<TT> xxxx</TT> den hexadezimal geschriebenen Wert der
Konstante, bei Vorw&auml;rtsreferenzen, bei denen man den Literalwert
ja noch nicht kennt, bezeichnet<TT> xxxx</TT> eine einfache
Durchnumerierung.<TT> n</TT> kennzeichnet das wievielte Auftreten
dieses Literals in dieser Sektion. Literale machen ganz normal die
Lokalisierung durch Sektionen mit, es ist daher zwingend
erforderlich, in einer Sektion entstandene Literale mit<TT>
LTORG</TT> auch dort abzulegen!
<P>
Die Durchnumerierung mit<TT> n</TT> ist erforderlich, weil ein
Literal in einer Sektion mehrfach auftreten kann. Dies ist einmal
bedingt dadurch, da&szlig; die PC-relative Adressierung nur positive
Displacements erlaubt, einmal mit<TT> LTORG</TT> abgelegte Literale
also im folgenden Code nicht mitbenutzt werden k&ouml;nnen,
andererseits auch, weil die Reichweite der Displacements
beschr&auml;nkt ist (512 bzw. 1024 Byte). Ein automatisches<TT>
LTORG</TT> am Ende des Programmes oder beim Umschalten zu einer
anderen CPU erfolgt nicht; findet AS in einer solchen Situation noch
abzulegende Literale, so wird eine Fehlermeldung ausgegeben.
<P>
Da bei der PC-relativen Adressierung der zur Adressierung
herangezogene PC-Wert der Instruktionsadresse+4 entspricht, ist es
nicht m&ouml;glich, ein Literal zu benutzen, welches direkt hinter
dem betroffenen Befehl abgelegt wird, also z.B. so:
<PRE>

        mov     #$1234,r6
        ltorg

</PRE>
Da der Prozessor dann aber sowieso versuchen w&uuml;rde, Daten als
Code auszuf&uuml;hren, sollte diese Situation in realen Programmen
nicht auftreten. Wesentlich realer ist aber ein anderer Fallstrick:
Wird hinter einem verz&ouml;gerten Sprung PC-relativ zugegriffen, so
ist der Programmz&auml;hler bereits auf die Sprungzieladresse
gesetzt, und das Displacement wird relativ zum Sprungziel+2
berechnet. Im folgenden Beispiel kann daher das Literal nicht
erreicht werden:
<PRE>

        bra     Target
        mov	#$12345678,r4        ; wird noch ausgefuehrt
        .
        .
        ltorg                        ; hier liegt das Literal
        .
        .
Target: mov     r4,r7                ; hier geht es weiter

</PRE>
Da Target+2 hinter dem Literal liegt, w&uuml;rde sich ein negatives
Displacement ergeben. Besonders haarig wird es, wenn mit den
Befehlen<TT> JMP, JSR, BRAF</TT> oder<TT> BSRF</TT> verzweigt wird:
Da AS die Zieladresse hier nicht ermitteln kann (sie ergibt sich erst
zur Laufzeit aus dem Registerinhalt), nimmt AS hier eine Adresse an,
die nach M&ouml;glichkeit nie pa&szlig;t, so da&szlig; PC-relative
Adressierung g&auml;nzlich unm&ouml;glich wird.
<P>
Es ist nicht direkt m&ouml;glich, aus der Zahl und Gr&ouml;&szlig;e
der Literale auf den belegten Speicher zu schlie&szlig;en. U.u.
mu&szlig; AS ein F&uuml;llwort einbauen, um einen Langwort-Wert auf
eine durch 4 teilbare Adresse auszurichten, andererseits kann er
m&ouml;glicherweise Teile eines 32-bittigen Literals f&uuml;r
16-Bit-Literale mitbenutzten. Mehrfach auftretende Literale erzeugen
nat&uuml;rlich nur einen Eintrag. Solche Optimierungen werden
f&uuml;r Vorw&auml;rtsreferenzen allerdings ganz unterdr&uuml;ckt, da
AS den Wert dieser Literale noch nicht kennt.
<P>
Da Literale die PC-relative Adressierung ausnutzen, die nur beim<TT>
MOV</TT>-Befehl erlaubt sind, beschr&auml;nken sich Literale
ebenfalls auf die Verwendung in<TT> MOV</TT>. Etwas trickreich ist
hier die Art und Weise, in der AS die Operandengr&ouml;&szlig;e
auswertet. Eine Angabe von Byte oder Wort bedeutet, da&szlig; AS
einen m&ouml;glichst kurzen<TT> MOV</TT>-Befehl erzeugt, der den
angegebenen Wert in den unteren 8 oder 16 Bit erzeugt, d.h. die
oberen 24 oder 16 Bit werden als don't care behandelt. Gibt man
dagegen Langwort oder gar nichts an, so sagt dies aus, da&szlig; das
komplette 32-Bit-Register den angegebenen Wert enthalten soll. Das
hat z.B. den Effekt, da&szlig; in folgendem Beispiel
<PRE>

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0

</PRE>
der erste Befehl echte immediate-Adressierung erzeugt, der zweite und
dritte jedoch ein Wort-Literal benutzen: Da das Bit 7 in der Zahl
gesetzt ist, erzeugt der Byte-Befehl effektiv $FFFFFFC0 im Register,
was nach der Konvention nicht das w&auml;re, was man im zweiten und
dritten Fall haben m&ouml;chte. Im dritten Fall reicht auch ein
Wort-Literal, weil das gel&ouml;schte Bit 15 des Operanden vom
Prozessor in Bit 16..31 fortgesetzt wird.
<P>
Wie man sieht, ist dieses ganze Literal-Konzept reichlich
kompliziert; einfacher ging's aber wirklich nicht. Es liegt leider in
der Natur der Sache, da&szlig; man manchmal Fehlermeldungen &uuml;ber
nicht gefundene Literale bekommt, die eigentlich logisch nicht
auftreten k&ouml;nnten, weil AS die Literale ja komplett in eigener
Regie verwaltet. Treten aber bei der Assemblierung Fehler erst im
zweiten Pass auf, so verschieben sich z.B. hinter der Fehlerstelle
liegende Labels gegen&uuml;ber dem ersten Pass, weil AS f&uuml;r die
jetzt als fehlerhaft erkannten Befehle keinen Code mehr erzeugt. Da
aber Literalnamen u.a. aus den Werten von Symbolen erzeugt werden,
werden als Folgefehler davon eventuell andere Literalnamen
nachgefragt, als im ersten Pass abgelegt wurden und AS beschwert sich
&uuml;ber nicht gefundene Symbole...sollten also neben anderen
Fehlern solche Literal-Fehler auftreten, beseitigen Sie erst die
anderen Fehler, bevor Sie mich und alle Literale verfluchen...
<P>
Wer aus der Motorola-Ecke kommt und PC-relative Adressierung explizit
benutzen will (z.B. um Variablen lageunabh&auml;ngig zu erreichen),
sollte wissen, da&szlig; beim Ausschreiben der Adressierung nach
Programmierhandbuch, also z.B. so:
<PRE>

        mov.l   @(Var,PC),r8

</PRE>
<I> keine</I> implizite Umrechnung der Adresse auf ein Displacement
erfolgt, d.h. der Operand wird so eingesetzt, wie er ist (und
w&uuml;rde in diesen Beispiel wohl mit hoher Wahrscheinlichkeit eine
Fehlermeldung hervorrufen...). Will man beim SH7x00 PC-relativ
adressieren, so tut man das einfach mit ,,absoluter'' Adressierung,
die auf Maschinenebene ja gar nicht existiert:
<PRE>

        mov.l   Var,r8

</PRE>
Hier wird das Displacement korrekt berechnet (es gelten
nat&uuml;rlich die gleichen Einschr&auml;nkungen f&uuml;r das
Displacement wie bei Literalen).
<P>

<H2><A NAME="sect_4_6_">4.6. MELPS-4500</A></H2>
<P>
Der Programmspeicher dieser Mikrokontroller ist in Seiten zu 128
Worten eingeteilt. Diese Einteilung existiert eigentlich nur
deswegen, weil es Sprungbefehle gibt, deren Ziel innerhalb der
gleichen Seite liegen darf, und andererseits ,,lange'' Exemplare, die
den ganzen Adre&szlig;bereich erreichen k&ouml;nnen. Die
Standard-Syntax von Mitsubishi verlangt eigentlich, da&szlig; Seite
und Offset als getrennte Argument geschrieben werden m&uuml;ssen. Da
das aber reichlich unpraktisch ist (ansonsten hat man als
Programmierer keine Veranlassung, sich um Seiten zu k&uuml;mmern, mit
der Ausnahme von indirekten Spr&uuml;ngen), erlaubt es AS auch
wahlweise, die Zieladresse linear zu schreiben, also z.B.
<PRE>

      bl        $1234

</PRE>
anstelle
<PRE>

      bl        $24,$34  .

</PRE>
<P>

<H2><A NAME="sect_4_7_">4.7. 6502UNDOC</A></H2>
<P>
Da die undokumentierten Befehle des 6502 sich naturgem&auml;&szlig;
in keinem Datenbuch finden, sollen sie an dieser Stelle kurz
aufgelistet werden. Die Verwendung erfolgt naturgem&auml;&szlig; auf
eigene Gefahr, da es keine Gew&auml;hr gibt, da&szlig; alle
Maskenversionen alle Varianten unterst&uuml;tzen! Bei den
CMOS-Nachfolgern des 6502 funktionieren sie sowieso nicht mehr, da
diese die ensprechenden Bitkombinationen mit offiziellen Befehlen
belegen...
<P>
<P>
Es bedeuten:
<P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> &amp;</TD><TD NOWRAP> bin&auml;res UND</TD></TR>
<TR><TD NOWRAP> |</TD><TD NOWRAP> bin&auml;res ODER</TD></TR>
<TR><TD NOWRAP> ^</TD><TD NOWRAP> bin&auml;res EXOR</TD></TR>
<TR><TD NOWRAP> &lt;&lt;</TD><TD NOWRAP> logischer Linksshift</TD></TR>
<TR><TD NOWRAP> &gt;&gt;</TD><TD NOWRAP> logischer Rechtsshift</TD></TR>
<TR><TD NOWRAP> &lt;&lt;&lt;</TD><TD NOWRAP> Linksrotation</TD></TR>
<TR><TD NOWRAP> &gt;&gt;&gt;</TD><TD NOWRAP> Rechtsrotation</TD></TR>
<TR><TD NOWRAP> <-</TD><TD NOWRAP> Zuweisung</TD></TR>
<TR><TD NOWRAP> (..)</TD><TD NOWRAP> Inhalt von ..</TD></TR>
<TR><TD NOWRAP>..</TD><TD NOWRAP> Bits ..</TD></TR>
<TR><TD NOWRAP> A</TD><TD NOWRAP> Akkumulator</TD></TR>
<TR><TD NOWRAP> X,Y</TD><TD NOWRAP> Indexregister X,Y</TD></TR>
<TR><TD NOWRAP> S</TD><TD NOWRAP> Stapelzeiger</TD></TR>
<TR><TD NOWRAP> An</TD><TD NOWRAP> Akkumulatorbit n</TD></TR>
<TR><TD NOWRAP> M</TD><TD NOWRAP> Operand</TD></TR>
<TR><TD NOWRAP> C</TD><TD NOWRAP> Carry</TD></TR>
<TR><TD NOWRAP> PCH</TD><TD NOWRAP> obere H&auml;lfte Programmz&auml;hler</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JAM, KIL</TT> oder<TT> CRS</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> keine, Prozessor wird angehalten</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> implizit</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SLO</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-((M)&lt;&lt;1)|(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ANC</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A<-(A)&amp;(M), C<- A7</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RLA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-((M)&lt;&lt;1)&amp;(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SRE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-((M)&gt;&gt;1)^(A)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ASR</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A<-((A)&amp;(M))&gt;&gt;1</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RRA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-((M)&gt;&gt;&gt;1)+(A)+(C)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ARR</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A<-((A)&amp;(M))&gt;&gt;&gt;1</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SAX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-(A)&amp;(X)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, Y-indiziert kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ANE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-((A)&amp;$ee)|((X)&amp;(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-(A)&amp;(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> X/Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHS</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X<-(A)&amp;(X), S<-(X), M<-(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHY</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-(Y)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-(X)&amp;(PCH+1)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> X-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LAX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> A,X<-(M)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, Y-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LXA</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X04<-(X)04 &amp; (M)04,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> A04<-(A)04 &amp; (M)04</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LAE</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X,S,A<-((S)&amp;(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> Y-indiziert lang</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> DCP</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M <-(M)-1, Flags<-((A)-(M))</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SBX</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> X<-((X)&amp;(A))-(M)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> immediate</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ISB</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> M<-(M)+1, A<-(A)-(M)-(C)</TD></TR>
<TR><TD NOWRAP> Adressierungsmodi</TD><TD NOWRAP> :</TD><TD NOWRAP> absolut lang/kurz, X-indiziert lang/kurz,</TD></TR>
<TR><TD NOWRAP></TD><TD NOWRAP></TD><TD NOWRAP> Y-indiziert lang, X/Y-indirekt</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>

<H2><A NAME="sect_4_8_">4.8. MELPS-740</A></H2>
<P>
Die Mikrokontroller dieser Reihe haben ein sehr nettes, verstecktes
Feature: Setzt man mit dem Befehl<TT> SET</TT> das Bit 5 des
Statusregisters, so wird bei allen arithmetischen Operationen (und
Ladebefehlen) der Akkumulator durch die durch das X-Register
adressierte Speicherzelle ersetzt. Dieses Feature
syntaxm&auml;&szlig;ig sauber zu integrieren, ist bisher nicht
geschehen, d.h. es kann bisher nur im ,,Handbetrieb''
(<TT>SET</TT>...Befehle mit Akkuadressierung...<TT>CLT</TT>) genutzt
werden.
<P>
Nicht alle MELPS-740-Prozessoren implementieren alle Befehle. An
dieser Stelle mu&szlig; der Programmierer aufpassen, da&szlig; er nur
die Befehle benutzt, die auch wirklich vorhanden sind, da AS die
Prozessoren dieser Familie nicht n&auml;her unterscheidet. Die
Besonderheiten der Special-Page-Adressierung werden bei der
Erkl&auml;rung von<TT> ASSUME</TT> n&auml;her erl&auml;utert.
<P>

<H2><A NAME="sect_4_9_">4.9. MELPS-7700/65816</A></H2>
<A NAME="ref_MELPS7700Spec"></A>
<P>
Offensichtlich haben diese beiden Prozessorfamilien ausgehend vom
6502 (&uuml;ber ihre 8-bittigen Vorg&auml;nger) etwas disjunkte
Entwicklungswege hinter sich. Kurz aufgelistet, ergeben sich folgende
Unterschiede:
<UL>
<LI> der 65816 hat keinen B-Akkumulator.</LI>
<LI> beim 65816 fehlen Multiplikations- sowie Divisionsbefehle.</LI>
<LI> Die Befehle<TT> SEB</TT>,<TT> CLB</TT>,<TT> BBC</TT>,<TT>
    BBS</TT>,<TT> CLM</TT>,<TT> SEM</TT>,<TT> PSH</TT>,<TT> PUL</TT>
    und<TT> LDM</TT> fehlen beim 65816. An deren Stelle in der
    Code-Tabelle finden sich<TT> TSB</TT>,<TT> TRB</TT>,<TT>
    BIT</TT>,<TT> CLD</TT>,<TT> SED</TT>,<TT> XBA</TT>,<TT> XCE</TT>
    und<TT> STZ</TT>.</LI>
</UL>
Identische Funktion, jedoch andere Namen haben folgende Befehle:
<P>
<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>65816</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>MELPS-7700</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>65816</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>MELPS-7700</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> REP</TT><BR>
<TT> TCS</TT><BR>
<TT> TCD</TT><BR>
<TT> PHB</TT><BR>
<TT> WAI</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> CLP</TT><BR>
<TT> TAS</TT><BR>
<TT> TAD</TT><BR>
<TT> PHT</TT><BR>
<TT> WIT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> PHK</TT><BR>
<TT> TSC</TT><BR>
<TT> TDC</TT><BR>
<TT> PLB</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER><TT> PHG</TT><BR>
<TT> TSA</TT><BR>
<TT> TDA</TT><BR>
<TT> PLT</TT><BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P>
Besonders t&uuml;ckisch sind die Befehle<TT> PHB</TT>,<TT> PLB</TT>
und<TT> TSB</TT>: diese Befehle haben jeweils eine v&ouml;llig andere
Funktion und Kodierung!
<P>
Leider tun diese Prozessoren mit ihrem Speicher etwas, was f&uuml;r
mich auf der nach oben offenen Perversit&auml;tsskala noch vor der
Intel-m&auml;&szlig;igen Segmentierung rangiert: sie banken ihn!
Nunja, dies ist wohl der Preis f&uuml;r die
6502-Aufw&auml;rtskompatibilit&auml;t; wie dem auch sei, damit AS den
gew&uuml;nschten Code erzeugen kann, mu&szlig; man ihn &uuml;ber
den<TT> ASSUME</TT>-Befehl &uuml;ber den Inhalt einiger Register in
Kenntnis setzen:
<P>
Das M-Flag bestimmt, ob die Akkumulatoren A und B 8 Bit (1) oder 16
Bit (0) breit sein sollen. Analog entscheidet das Flag X &uuml;ber
die Breite der Indexregister X und Y. AS ben&ouml;tigt die
Information &uuml;ber die Registerbreite bei unmittelbarer
Adressierung (<TT>#&lt;Konstante&gt;</TT>), ob das Argument 8 oder 16
Bit breit sein soll.
<P>
Der Speicher ist in 256 B&auml;nke zu 64 Kbyte geteilt. Da alle
Register im Prozessor nur maximal 16 Bit breit sind, kommen die
obersten 8 Adre&szlig;bits aus 2 speziellen Bank-Registern: DT
liefert die oberen 8 Bits bei Datenzugriffen, PG erweitert den
16-bittigen Programmz&auml;hler auf 24 Bit. Die vom 6502 her bekannte
,,Zero-Page'' ist mittels des 16 Bit breiten Registers DPR frei
innerhalb der ersten Bank verschiebbar. Trifft AS nun im Code auf
eine Adresse (egal ob in einem absoluten, indizierten oder indirekten
Ausdruck), so versucht er der Reihe nach folgende
Adressierungsvarianten:
<OL>
<LI>Liegt die Adresse im Bereich von DPR...DPR+$ff? Falls ja, Verwendung
    von direkter Adressierung mit 8-Bit-Adresse.</LI>
<LI>Liegt die Adresse innerhalb der durch DT (bzw. PG f&uuml;r
    Sprungbefehle) festgelegten Seite? Falls ja, Verwendung von
    absoluter Adressierung mit 16-Bit-Adresse.</LI>
<LI>Falls nichts anderes hilft, Verwendung von langer Adressierung mit
    24-Bit-Adresse.</LI>
</OL>
Aus dieser Aufz&auml;hlung folgt, da&szlig; das Wissen &uuml;ber die
momentanen Werte von DT,PG und DPR f&uuml;r die Funktion von AS
essentiell ist; sind die Angaben fehlerhaft, adressiert das Programm
,,in die W&uuml;ste''. Diese Aufz&auml;hlung geht &uuml;brigens davon
aus, da&szlig; alle drei Adre&szlig;l&auml;ngen verf&uuml;gbar sind;
sollte dies einmal nicht der Fall sein, so wird die
Entscheidungskette entsprechen k&uuml;rzer.
<P>
Die oben geschilderte, automatische Festlegung der
Adre&szlig;l&auml;nge l&auml;&szlig;t sich auch durch die Verwendung
von Pr&auml;fixen &uuml;bersteuern. Stellt man der Adresse ein &lt;,
&gt; oder &gt;&gt; ohne trennendes Leerzeichen voran, so wird eine
Adresse mit 1, 2 oder 3 Bytes benutzt, unabh&auml;ngig davon, ob dies
die optimale L&auml;nge ist. Benutzt man eine f&uuml;r diesen Befehl
nicht erlaubte oder f&uuml;r die Adresse zu kurze L&auml;nge, gibt es
eine Fehlermeldung.
<P>
Um die Portierung von 6502-Programmen zu erleichtern, verwendet AS
f&uuml;r Hexadezimalkonstanten die Motorola-Syntax und nicht die von
Mitsubishi &uuml;brigens f&uuml;r die 740er favorisierte
Intel/IEEE-Schreibweise. Ich halte erstere auch f&uuml;r die bessere
Schreibweise, und die Entwickler des 65816 werden dies vermutlich
&auml;hnlich gesehen haben (da man mittels der<TT>
RELAXED</TT>-Anweisung auch Intel-Notation benutzen kann, wird durch
diese Entscheidung auch niemand festgelegt). Ein f&uuml;r die
Portierung &auml;hnlich wichtiges Detail ist, da&szlig; der
Akkumulator A als Ziel von Operationen auch weggelassen werden darf,
anstelle von<TT> LDA A,#0</TT> darf also z.B. auch einfach<TT> LDA
#0</TT> geschrieben werden.
<P>
Ein echtes Bonbon in dem Befehlssatz sind dagegen die
Blocktransferbefehle<TT> MVN</TT> und<TT> MVP</TT>. Etwas eigenartig
ist nur die Adre&szlig;angabe: Bit 0--15 im Indexregister, Bit 16--23
im Befehl. Bei AS gibt man als Argument f&uuml;r beide
Speicherbl&ouml;cke einfach die vollen Adressen an, AS fischt sich
dann die passenden Bits automatisch heraus. Dies ist ein feiner, aber
wichtiger Unterschied zum Mitsubishi-Assembler, bei dem man die
oberen 8 Bit selber herausziehen mu&szlig;. Richtig bequem wird es
aber erst mit einem Makro im folgendem Stil:
<PRE>

mvpos   macro   src,dest,len
        if      MomCPU=$7700
         lda    #len
        elseif
         lda    #(len-1)
        endif
        ldx     #(src&$ffff)
        ldy     #(dest&$ffff)
        mvp     dest,src
        endm

</PRE>
Vorsicht, Falle: Steht im Akkumulator die Zahl n, so transferiert der
Mitsubishi n Bytes, der 65816 jedoch n+1 Bytes!
<P>
Sehr nett sind auch die Befehle<TT> PSH</TT> und<TT> PUL</TT>, mit
deren Hilfe es m&ouml;glich ist, mit einem Befehl einen frei
w&auml;hlbaren Satz von Registern auf dem Stack zu sichern oder von
ihm zu laden. Nach dem Mitsubishi-Datenbuch<A
HREF="#cite_Mit16">[41]</A> mu&szlig; die Angabe der Bitmasken
immediate erfolgen, der Programmierer soll also entweder alle
Register<->Bitstellen-Zuordnungen im Kopf behalten oder sich passende
Symbole definieren. Hier habe ich die Syntax eigenm&auml;chtig
erweitert, um die Sache etwas angenehmer zu machen: Es darf eine
Liste angegeben werden, die sowohl immediate-Ausdr&uuml;cke als auch
Registernamen enthalten darf. Damit sind z.B. die Anweisungen
<PRE>

        psh     #$0f

</PRE>
und
<PRE>

        psh     a,b,#$0c

</PRE>
und
<PRE>

        psh     a,b,x,y

</PRE>
&auml;quivalent. Da die immediate-Version weiterhin erlaubt ist,
bleibt AS hier ,,aufw&auml;rtskompatibel'' zu den
Mitsubishi-Assemblern.
<P>
Nicht ganz habe ich beim Mitsubishi-Assembler die Behandlung des<TT>
PER</TT>-Befehles verstanden: Mit diesem Befehl kann man eine
16-Bit-Variable auf den Stack legen, deren Adresse relativ zum
Programmz&auml;hler angegeben wird. Es ist aus der Sicht des
Programmierers also eine absolute Adressierung einer Speicherzelle.
Nichtsdestotrotz verlangt Mitsubishi eine immediate-Adressierung, und
das Argument wird so in den Code eingesetzt, wie es im Quelltext
steht. Die Differenz mu&szlig; man selber ausrechnen, was mit der
Einf&uuml;hrung von symbolischen Assemblern ja abgeschafft werden
sollte...da ich aber auch ein bi&szlig;chen ,,kompatibel'' denken
mu&szlig;, enth&auml;lt AS eine Kompromi&szlig;l&ouml;sung:
W&auml;hlt man immediate-Adressierung (also mit Gartenzaun), so
verh&auml;lt sich AS wie das Original von Mitsubishi. L&auml;&szlig;t
man ihn jedoch weg, so berechnet AS die Differenz vom Argument zum
momentanen Programmz&auml;hler und setzt diese ein.
<P>
&Auml;hnlich sieht es beim<TT> PEI</TT>-Befehl aus, der den Inhalt
einer 16-Bit-Variablen auf der Zeropage auf den Stack legt: Obwohl
der Operand eine Adresse ist, wird wieder immediate-Adressierung
verlangt. Hier l&auml;&szlig;t AS schlicht beide Versionen zu (d.h.
mit oder ohne Gartenzaun).
<P>

<H2><A NAME="sect_4_10_">4.10. M16</A></H2>
<P>
Die M16-Familie ist eine Familie &auml;u&szlig;erst komplexer
CISC-Prozessoren mit einem entsprechend komplizierten Befehlssatz. Zu
den Eigenschaften dieses Befehlssatzes geh&ouml;rt es unter anderem,
da&szlig; bei Operationen mit zwei Operanden beide Operanden
verschiedene L&auml;ngen haben d&uuml;rfen. Die bei Motorola
&uuml;bliche und von Mitsubishi &uuml;bernommene Methode, die
Operandengr&ouml;&szlig;e als Attribut an den Befehl anzuh&auml;ngen,
mu&szlig;te daher erweitert werden: Es ist erlaubt, auch an die
Operanden selber Attribute anzuh&auml;ngen. So wird im folgenden
Beispiel
<PRE>

        mov     r0.b,r6.w

</PRE>
Register 0 8-bittig gelesen, auf 32 Bit vorzeichenerweitert und das
Ergebnis in Register 6 kopiert. Da man in 9 von 10 F&auml;llen aber
von diesen M&ouml;glichkeiten doch keinen Gebrauch macht, kann man
weiterhin die Operandengr&ouml;&szlig;e an den Befehl selber
schreiben, z.B. so:
<PRE>

        mov.w   r0,r6

</PRE>
Beide Varianten d&uuml;rfen auch gemischt verwendet werden, eine
Gr&ouml;&szlig;enangabe am Operanden &uuml;bersteuert dann den
,,Default'' am Befehl. Eine Ausnahme stellen Befehle mit zwei
Operanden dar. Bei diesen ist der Default f&uuml;r den Quelloperanden
die Gr&ouml;&szlig;e des Zieloperanden. In folgendem Beispiel
<PRE>

        mov.h   r0,r6.w

</PRE>
wird also auf Register 0 32-bittig zugegriffen, die
Gr&ouml;&szlig;enangabe am Befehl wird &uuml;berhaupt nicht mehr
benutzt. Finden sich &uuml;berhaupt keine Angaben zur
Operandengr&ouml;&szlig;e, so wird Wort(w) verwendet. Merke: im
Gegensatz zu den 68000ern bedeutet dies 32 und nicht 16 Bit!
<P>
Reichlich kompliziert sind auch die verketteten Adressierungsmodi;
dadurch, da&szlig; AS die Verteilung auf Kettenelemente automatisch
vornimmt, bleibt die Sache aber einigerma&szlig;en
&uuml;bersichtlich. Die einzige Eingriffsm&ouml;glichkeit, die bei AS
gegeben ist (der Originalassembler von Mitsubishi/Green Hills kann da
noch etwas mehr), ist die explizite Festlegung von
Displacement-L&auml;ngen mittels der Anh&auml;ngsel<TT> :4</TT>,<TT>
:16</TT> und<TT> :32</TT>.
<P>

<H2><A NAME="sect_4_11_">4.11. 4004/4040</A></H2>
<P>
John Weinrich sei dank, habe ich nun auch die offiziellen
Datenbl&auml;tter von Intel &uuml;ber diese 'Urv&auml;ter' aller
Mikroprozessoren, und die Unklarheiten &uuml;ber die Syntax von
Registerpaaren (f&uuml;r 8-Bit-Operationen) sind f&uuml;rs erste
ausger&auml;umt. Die Syntax lautet<TT> RnRm</TT>, wobei<TT> n</TT>
bzw.<TT> m</TT> gerade Integers im Bereich 0 bis E bzw. 1 bis F sind.
Dabei gilt immer<TT> m = n + 1</TT>.
<P>

<H2><A NAME="sect_4_12_">4.12. MCS-48</A></H2>
<P>
Der maximale Adre&szlig;raum dieser Prozessoren betr&auml;gt 4 Kbyte.
Dieser Raum ist jedoch nicht linear organisiert (wie k&ouml;nnte das
bei Intel auch anders sein...), sondern in 2 B&auml;nke zu 2 Kbyte
geteilt. Ein Wechsel zwischen diesen beiden B&auml;nken ist nur durch
die Befehle<TT> CALL</TT> und<TT> JMP</TT> erlaubt, indem vor dem
Sprung das h&ouml;chste Adre&szlig;bit mit den Befehlen<TT> SEL
MB0</TT> bzw.<TT> SEL MB1</TT> vorgegeben wird. Um den Wechsel
zwischen den B&auml;nken zu vereinfachen, ist eine Automatik in den
Befehlen<TT> JMP</TT> und<TT> CALL</TT> eingebaut, die einen dieser
beiden Befehle einf&uuml;gt, falls die Adresse des Sprungbefehles und
das Sprungziel in unterschiedlichen B&auml;nken liegen. Die explizite
Benutzung der<TT> SEL MBx</TT>-Befehle sollte daher nicht notwendig
sein (obwohl sie m&ouml;glich ist) und kann die Automatik auch
durcheinanderbringen, wie in dem folgenden Beispiel:
<PRE>

000:    SEL     MB1
	JMP     200h

</PRE>
AS nimmt an, da&szlig; das MB-Flag auf 0 steht und f&uuml;gt
keinen<TT> SEL MB0</TT>-Befehl vor dem Sprung ein, mit der Folge,
da&szlig; der Prozessor zur Adresse A00h springt. Weiterhin ist zu
beachten, da&szlig; ein Sprungbefehl durch diesen Mechanismus unter
Umst&auml;nden ein Byte l&auml;nger wird.
<P>

<H2><A NAME="sect_4_13_">4.13. MCS-51</A></H2>
<P>
Dem Assembler liegen die Dateien STDDEF51.INC bzw. 80C50X.INC bei, in
denen alle Bits und SFRs der Prozessoren 8051, 8052 und 80515 bzw.
80C501, 502 und 504 verzeichnet sind. Je nach Einstellung des
Prozessortyps mit dem<TT> CPU</TT>-Befehl wird dabei die korrekte
Untermenge eingebunden, die richtige Reihenfolge f&uuml;r den Anfang
eines Programmes ist daher
<PRE>

	CPU     &lt;Prozessortyp&gt;
	INCLUDE stddef51.inc   ,

</PRE>
sonst f&uuml;hren die MCS-51-Pseudobefehle in der Include-Datei zu
Fehlermeldungen.
<P>
Da der 8051 keinen Befehl kennt, um die Register 0..7 auf den Stack
zu legen, mu&szlig; mit deren absoluten Adressen gearbeitet werden.
Diese h&auml;ngen aber von der momentan aktiven Registerbank ab. Um
diesem Mi&szlig;stand etwas abzuhelfen, ist in den Include-Dateien
das Makro<TT> USING</TT> definiert, dem als Parameter die Symbole<TT>
Bank0..Bank3</TT> gegeben werden k&ouml;nnen. Das Makro belegt
daraufhin die Symbole<TT> AR0..AR7</TT> mit den passenden absoluten
Adressen der Register. Dieses Makro sollte nach jeder Bankumschaltung
benutzt werden. Es erzeugt selber<I> keinen</I> Code zur Umschaltung!
<P>
Das Makro f&uuml;hrt in der Variablen<TT> RegUsage</TT> gleichzeitig
Buch &uuml;ber alle jemals benutzten Registerb&auml;nke; Bit 0
entspricht Bank 0, Bit 1 der Bank 1 usw. . Der Inhalt kann am Ende
der Quelldatei z.B. mit folgendem Codest&uuml;ck ausgegeben werden:
<PRE>

	irp     BANK,Bank0,Bank1,Bank2,Bank3
	 if      (RegUsage&(2^BANK))&lt;&gt;0
	  message "Bank \{BANK} benutzt"
	 endif
	endm

</PRE>
Mit der Mehrpass-F&auml;higkeit ab Version 1.38 wurde es
m&ouml;glich, zus&auml;tzlich die Befehle<TT> JMP</TT> und<TT>
CALL</TT> einzuf&uuml;hren. Bei der Kodierung von Spr&uuml;ngen mit
diesen Befehlen w&auml;hlt AS je nach Adre&szlig;lage automatisch die
optimale Variante, d.h.<TT> SJMP/AJMP/LJMP</TT> f&uuml;r<TT> JMP</TT>
und<TT> ACALL/LCALL</TT> f&uuml;r<TT> CALL</TT>. Es ist
nat&uuml;rlich weiterhin m&ouml;glich, die Varianten direkt zu
verwenden, um eine bestimmte Kodierung zu erzwingen.
<P>

<H2><A NAME="sect_4_14_">4.14. MCS-251</A></H2>
<P>
Intel hat sich beim 80C251 ja bem&uuml;ht, den &Uuml;bergang f&uuml;r
den Programmierer auf die neue Familie so weich wie m&ouml;glich zu
gestalten, was darin gipfelt, da&szlig; alte Anwendungen ohne
Neu&uuml;bersetzung auf dem neuen Prozessor ablaufen k&ouml;nnen.
Sobald man jedoch den erweiterten Befehlssatz der 80C251 nutzen will,
gilt es, einige Details zu beachten, die sich als versteckte
Fu&szlig;angeln auftun.
<P>
An vorderster Stelle steht dabei die Tatsache, da&szlig; der 80C251
keinen getrennten Bitadre&szlig;raum mehr hat. Es sind nunmehr alle
SFRs unabh&auml;ngig von ihrer Adre&szlig;lage sowie die ersten 128
Speicherstellen des internen RAMs bitadressierbar. M&ouml;glich wird
dies dadurch, da&szlig; die Bitadressierung nicht mehr &uuml;ber
einen zus&auml;tzlichen virtuellen Adre&szlig;raum, der andere
Adre&szlig;r&auml;ume &uuml;berdeckt, erfolgt, sondern so wie bei
anderen Prozessoren auch durch eine zweidimensionale Adressierung,
die aus der Speicherstelle, die das Bit beinhaltet sowie der
Bitstelle im Byte besteht. Dies bedeutet zum einen, da&szlig; bei
einer Bitangabe wie z.B. PSW.7 AS die Zerlegung der Teile links und
rechts vom Punkt selber vornimmt. Es ist also nicht mehr n&ouml;tig,
mittels eines<TT> SFRB</TT>-Befehls wie noch beim 8051 explizit 8
Bitsymbole zu erzeugen. Dies bedeutet zum anderen, da&szlig; es
den<TT> SFRB</TT>-Befehl &uuml;berhaupt nicht mehr gibt. Wird er in
zu portierenden 8051-Programmen benutzt, kann er durch einen
einfachen<TT> SFR</TT>-Befehl ersetzt werden.
<P>
Weiterhin hat Intel in den unterschiedlichen Adre&szlig;r&auml;umen
des 8051 geh&ouml;rig aufger&auml;umt: Der Bereich des internen RAMs
(<TT>DATA</TT> bzw.<TT> IDATA</TT>), der<TT> XDATA</TT>-Bereich und
er bisherige<TT> CODE</TT>-Bereich wurden in einem einzigen, 16 Mbyte
gro&szlig;en<TT> CODE</TT>-Bereich vereinigt. Das interne RAM beginnt
bei Adresse 0, das interne ROM beginnt bei Adresse ff0000h, dorthin
mu&szlig; also auch der Code mittels<TT> ORG</TT> hinverlagert
werden. Ausgelagert wurden dagegen die<TT> SFRs</TT> in einen eigenen
Adre&szlig;raum (der bei AS als<TT> IO</TT>-Segment definiert ist).
In diesem neuen Adre&szlig;raum haben sie aber die gleichen Adressen
wie beim 8051. Der<TT> SFR</TT>-Befehl kennt diesen Unterschied und
legt mit ihm erzeugte Symbole je nach Zielprozessor automatisch
ins<TT> DATA</TT>- bzw.<TT> IO</TT>-Segment. Da es keinen
Bit-Adre&szlig;raum mehr gibt, funktioniert der<TT> BIT</TT>-Befehl
v&ouml;llig anders: anstelle einer linearen Adresse von 0 bis 255
beinhalten Bit-Symbole jetzt in Bit 0..7 die Adresse, in Bit 24..26
die Bitstelle. Damit ist es jetzt leider nicht mehr so einfach
m&ouml;glich, Felder von Flags mit symbolischen Namen anzulegen: Wo
man beim 8051 noch z.B.
<PRE>

        segment bitdata

bit1    db      ?
bit2    db      ?

</PRE>
oder
<PRE>

defbit	macro   name
name    bit     cnt
cnt     set     cnt+1
        endm

</PRE>
schreiben konnte, hilft jetzt nur noch die zweite Variante weiter,
z.B. so:
<PRE>

adr     set     20h     ; Startadresse Flags im internen RAM
bpos    set     0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif
        endm

</PRE>
Ein weiteres, kleines Detail: Da Intel als Kennzeichnung f&uuml;r den
Carry nun CY statt C bevorzugt, sollte man ein eventuell benutztes
Symbol umbenennen. AS versteht aber auch weiterhin die alte Variante
in den Befehlen<TT> CLR, CPL, SETB, MOV, ANL,</TT> und<TT> ORL</TT>.
Gleiches gilt sinngem&auml;&szlig; f&uuml;r die dazugekommenen
Register<TT> R8..R15, WR0..WR30, DR0..DR28, DR56, DR60, DPX</TT>
und<TT> SPX</TT>.
<P>
Intel m&ouml;chte es gerne, da&szlig; man absolute Adressen in der
Form<TT> XX:YYYY</TT> schreibt, wobei<TT> XX</TT> eine 64K-Bank im
Adre&szlig;raum angibt bzw. mit einem<TT> S</TT> Adressen im IO-Raum
kennzeichnet. Wie man sich schon denken kann, halte ich davon nicht
allzu viel, weshalb man an allen Stellen Adressen genauso gut linear
angeben kann; lediglich um das S f&uuml;r die Kennzeichnung von
I/O-Adressen kommt man nicht herum, z.B. hier:
<PRE>

Carry   bit   s:0d0h.7

</PRE>
Ohne den Pr&auml;fix w&uuml;rde AS die absolute Adresse in das
Code-Segment legen, und dort sind ja nur die ersten 128 Byte
bitadressierbar...
<P>
Wie auch schon beim 8051 gibt es die generischen Befehle<TT> JMP</TT>
und<TT> CALL</TT>, die je nach Adre&szlig;lage automatisch die
k&uuml;rzeste Variante einsetzen. W&auml;hrend<TT> JMP</TT> aber die
Variante mit 24 Bit mitber&uuml;cksichtigt, tut<TT> CALL</TT> dies
aus gutem Grund nicht: Der<TT> ECALL</TT>-Befehl legt n&auml;mlich im
Gegensatz zu<TT> ACALL</TT> und<TT> LCALL</TT> 3 Bytes auf den Stack,
und man h&auml;tte sonst einen<TT> CALL</TT>-Befehl, bei dem man
nicht mehr genau wei&szlig;, was er tut. Bei<TT> JMP</TT> tritt diese
Problem nicht auf.
<P>
Aus einer Sache bin ich nicht ganz schlau geworden: Der 80251 kann
auch immediate-Operanden auf den Stack legen, und zwar sowohl
einzelne Bytes als auch ganze W&ouml;rter. F&uuml;r beide Varianten
ist aber der gleiche Befehl<TT> PUSH</TT> vorgesehen -- und woher
soll bitte ein Assembler bei einer Anweisung wie
<PRE>

        push #10

</PRE>
wissen, ob ein Byte oder ein Wort mit dem Wert 10 auf den Stack
gelegt werden soll? Daher gilt im Augenblick die Regelung,
da&szlig;<TT> PUSH</TT> grunds&auml;tzlich ein Byte ablegt; wer ein
Wort ablegen will, schreibt einfach<TT> PUSHW</TT> anstelle<TT>
PUSH</TT>.
<P>
Noch ein gutgemeinter Ratschlag: Wer den erweiterten Befehlssatz des
80C251 nutzt, sollte den Prozessor auch tunlichst im Source-Modus
betreiben, sonst werden alle neuen Anweisungen ein Byte l&auml;nger!
Um die origin&auml;ren 8051-Anweisungem, die daf&uuml;r im
Source-Modus l&auml;nger werden, ist es nicht besonders schade: Sie
werden entweder von AS automatisch durch neue, leistungsf&auml;higere
ersetzt oder sind be- treffen veraltete Adressierungsarten (indirekte
Adressierung mit 8-Bit-Registern).
<P>

<H2><A NAME="sect_4_15_">4.15. 8085UNDOC</A></H2>
<A NAME="ref_8085Spec"></A>
<P>
&Auml;hnlich wie beim Z80 oder 6502, sind auch beim 8085 die
undokumentierten Befehle nicht n&auml;her von Intel spezifiziert
worden, weshalb es nicht undenkbar ist, da&szlig; andere Assembler
andere Mnemonics daf&uuml;r verwenden. Deshalb sollen auch diese
Befehle und ihre Funktion hier kurz aufgelistet werden. Und auch hier
wieder ist die Verwendung dieser Befehle auf eigenes Risiko - schon
der an sich zum 8085 aufw&auml;rtskompatible Z80 benutzt diese
Opcodes f&uuml;r v&ouml;llig andere Funktionen...
<P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> DSUB [reg]</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL <- HL - reg</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY, S, X5, AC, Z, V, P</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = B f&uuml;r BC (optional)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> ARHL</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL,CY <- HL &gt;&gt; 1 (arithmetisch)</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RDEL</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> CY,DE <- DE &lt;&lt; 1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> CY, V</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LDHI d8</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> DE <- HL +<TT> d8</TT></TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> d8</TT> = 8-Bit-Konstante</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LDSI d8</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> DE <- SP +<TT> d8</TT></TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> d8</TT> = 8-Bit-Konstante</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> RST flag</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> Restart zu 40h wenn<TT> flag</TT>=1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> flag</TT> = V f&uuml;r Overflow-Bit</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> SHLX [reg]</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> [reg] <- HL</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = D f&uuml;r DE (optional)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> LHLX [reg]</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> HL <-[reg]</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> reg</TT> = D f&uuml;r DE (optional)</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JNX5 adr</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> springe zu<TT> adr</TT> wenn X5=0</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> adr</TT> = absolute 16-Bit-Adresse</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP></TD></TR>
<TR><TD NOWRAP> Anweisung</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> JX5 adr</TT></TD></TR>
<TR><TD NOWRAP> Funktion</TD><TD NOWRAP> :</TD><TD NOWRAP> springe zu<TT> adr</TT> wenn X5=1</TD></TR>
<TR><TD NOWRAP> Flags</TD><TD NOWRAP> :</TD><TD NOWRAP> keine</TD></TR>
<TR><TD NOWRAP> Argumente</TD><TD NOWRAP> :</TD><TD NOWRAP><TT> adr</TT> = absolute 16-Bit-Adresse</TD></TR>
<TR><TD NOWRAP></TD></TR>
</TABLE><P>
Mit X5 ist dabei das ansonsten unbenutzte Bit 5 im PSW-Register
gemeint.
<P>

<H2><A NAME="sect_4_16_">4.16. 8086..V35</A></H2>
<P>
Eigentlich hatte ich mir geschworen, die Segmentseuche der 8086er aus
diesem Assembler herauszuhalten. Da aber nun eine Nachfrage kam und
Studenten flexiblere Menschen als die Entwickler dieses Prozessors
sind, findet sich ab sofort auch eine rudiment&auml;re
Unterst&uuml;tzung dieser Prozessoren in AS. Unter
,,rudiment&auml;r'' verstehe ich dabei nicht, da&szlig; der
Befehlssatz nicht vollst&auml;ndig abgedeckt wird, sondern da&szlig;
ich nicht den ganzen Wust an Pseudoanweisungen integriert habe, die
sich bei MASM, TASM &amp; Co. finden. AS ist auch nicht in erster
Linie geschrieben worden, um PC-Programme zu entwickeln (Gott
bewahre, das hie&szlig;e wirklich, das Rad neu zu erfinden), sondern
zur Programmentwicklung f&uuml;r Einplatinenrechner, die eben unter
anderem auch mit 8086ern best&uuml;ckt sein k&ouml;nnen.
<P>
F&uuml;r Unentwegte, die mit AS doch DOS-Programme schreiben wollen,
eine kleine Liste dessen, was zu beachten ist:
<UL>
<LI> Es k&ouml;nnen nur COM-Programme erzeugt werden.</LI>
<LI> Verwenden Sie nur das<TT> CODE</TT>-Segment, und legen Sie auch alle
    Variablen darin ab.</LI>
<LI> Alle Segmentregister werden von DOS auf das Codesegment
    vorinitialisiert. Ein<TT> ASSUME DS:CODE, SS:CODE</TT> am
    Programmanfang ist daher notwendig.</LI>
<LI> DOS l&auml;dt den Code ab Adresse 100h. Ein<TT> ORG</TT> auf diese
    Adresse ist daher zwingend.</LI>
<LI> Die Umwandlung in eine Bin&auml;rdatei erfolgt mit P2BIN (s.u.),
    wobei als als Adre&szlig;bereich<TT> $-$</TT> anzugeben ist.</LI>
</UL>
Allgemein unterst&uuml;tzt AS f&uuml;r diese Prozessoren nur ein
Small-Programmiermodell, d.h.<I> ein</I> Codesegment mit maximal 64
KByte und ein ebenfalls h&ouml;chstens 64 KByte gro&szlig;es
Datensegment mit (f&uuml;r COM-Dateien uninitialisierten) Daten.
Zwischen diesen beiden Segmenten kann mit dem<TT> SEGMENT</TT>-Befehl
hin-und hergeschaltet werden. Aus dieser Tatsache folgert, da&szlig;
Spr&uuml;nge immer intrasegment&auml;r sind, sofern sie sich auf
Adressen im Codesegment beziehen. Falls weite Spr&uuml;nge doch
einmal erforderlich sein sollten, k&ouml;nnen sie mit<TT> CALLF</TT>
und<TT> JMPF</TT> und einer Speicheradresse oder einen
Segment:Offset-Wert als Argument erreicht werden.
<P>
Ein weiteres gro&szlig;es Problem dieser Prozessoren ist deren
Assemblersyntax, deren genaue Bedeutung nur aus dem Zusammenhang
erkennbar ist. So kann im folgenden Beispiel je nach Symboltyp sowohl
unmittelbare als auch absolute Adressierung gemeint sein:
<PRE>

        mov     ax,wert

</PRE>
Bei AS ist immer unmittelbare Adressierung gemeint, wenn um den
Operanden keine eckigen Klammern stehen. Soll z.B. die Adresse oder
der Inhalt einer Variablen geladen werden, so ergeben sich die in
Tabelle <A HREF="#ref_TabMASM">4.1</A> aufgelisteten Unterschiede.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Assembler</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Adresse</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Inhalt</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>MASM<BR>
<BR>
<BR>
<BR>
AS<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> mov ax,offset vari</TT><BR>
<TT> lea ax,vari</TT><BR>
<TT> lea ax,[vari]</TT><BR>
<BR>
<TT> mov ax,vari</TT><BR>
<TT> lea ax,[vari]</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> mov ax,vari</TT><BR>
<TT> mov ax,[vari]</TT><BR>
<BR>
<BR>
<TT> mov ax,[vari]</TT><BR>
<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.1: Unterschiede in der Adressierungssyntax AS<->MASM<A
             NAME="ref_TabMASM"></A>
</CENTER><P>

<P>
Der Assembler pr&uuml;ft bei Symbolen, ob sie im Datensegment liegen
und versucht, automatisch einen passenden Segmentpr&auml;fix
einzuf&uuml;gen, z.B. falls ohne CS-Pr&auml;fix auf Symbole im Code
zugegriffen wird. Dieser Mechanismus kann jedoch nur funktionieren,
falls der<TT> ASSUME</TT>-Befehl (siehe dort) korrekt angewendet
wurde.
<P>
Die Intel-Syntax verlangt eine Abspeicherung, ob an einem Symbol
Bytes oder W&ouml;rter abgelegt wurden. AS nimmt diese Typisierung
nur vor, falls in der gleichen Zeile wie das Label ein<TT> DB</TT>
oder<TT> DW</TT> steht. F&uuml;r alle anderen F&auml;lle mu&szlig;
mit den Operatoren<TT> WORD PTR, BYTE PTR</TT> usw. explizit
angegeben werden, um was f&uuml;r eine Operandengr&ouml;&szlig;e es
sich handelt. Solange ein Register an der Operation beteiligt ist,
kann auf diese Kennzeichnung verzichtet werden, da durch den
Registernamen die Operandengr&ouml;&szlig;e eindeutig bestimmt ist.
<P>
Der Koprozessor in 8086-Systemen wird &uuml;blicherweise durch den
TEST-Eingang des Prozessors synchronisiert, indem selbiger mit dem
BUSY-Ausgang des Koprozessors verbunden wird. AS unterst&uuml;tzt
dieses Handshaking, indem vor jedem 8087-Befehl automatisch ein<TT>
WAIT</TT>-Befehl eingef&uuml;gt wird. Ist dies aus irgendwelchen
Gr&uuml;nden unerw&uuml;nscht (z.B. w&auml;hrend der
Initialisierung), so mu&szlig; im Opcode hinter dem<TT> F</TT>
ein<TT> N</TT> eingef&uuml;gt werden; aus
<PRE>

        FINIT
        FSTSW   [vari]

</PRE>
wird so z.B.
<PRE>

        FNINIT
        FNSTSW  [vari]

</PRE>
Diese Variante ist bei<I> allen</I> Koprozessorbefehlen erlaubt.
<P>

<H2><A NAME="sect_4_17_">4.17. 8X30x</A></H2>
<A NAME="ref_8X30xSpec"></A>
<P>
Die Prozessoren dieser Reihe sind auf eine einfache Manipulation von
Bitgruppen auf Peripherieadressen optimiert worden. Um mit solchen
Bitgruppen auch symbolisch umgehen zu k&ouml;nnen, existieren die
Befehle<TT> LIV</TT> und<TT> RIV</TT>, mit denen einer solchen
Bitgruppe ein symbolischer Name zugewiesen wird. Diese Befehle
arbeiten &auml;hnlich wie<TT> EQU</TT>, ben&ouml;tigen aber drei
Parameter:
<OL>
<LI>die Adresse der peripheren Speicherzelle, in der sich die Bitgruppe
    befindet (0..255);</LI>
<LI>die Bitnummer des ersten Bits in der Gruppe (0..7);</LI>
<LI>die L&auml;nge der Gruppe in Bits (1..8).</LI>
</OL>
<B> ACHTUNG!</B> Der 8X30x unterst&uuml;tzt keine Bitgruppen, die
&uuml;ber mehrere Speicherstellen hinausreichen, so da&szlig; je nach
Startposition der Wertebereich f&uuml;r die L&auml;nge
eingeschr&auml;nkt sein kann. AS nimmt hier<B> keine</B> Pr&uuml;fung
vor, man bekommt lediglich zur Laufzeit merkw&uuml;rdige Ergebnisse!
<P>
Im Maschinencode dr&uuml;cken sich L&auml;nge und Position durch ein
3-Bit-Feld im Instruktionswort sowie ein passende Registernummer
(<TT>LIVx</TT> bzw.<TT> RIVx</TT>) aus. Bei der Verwendung eines
symbolischen Objektes wird AS diese Felder automatisch richtig
besetzen, es ist aber auch erlaubt, die L&auml;nge als dritten
Operanden explizit anzugeben, wenn man nicht mit symbolischen
Busobjekten arbeitet. Trifft AS auf eine L&auml;ngenangabe trotz
eines symbolischen Operanden, so vergleicht er beide L&auml;ngen und
gibt eine Fehlermeldung bei Ungleichheit aus (das gleiche passiert
&uuml;brigens auch, wenn man bei einem<TT> MOVE</TT>-Befehl zwei
symbolische Operanden mit unterschiedlicher L&auml;nge benutzt - die
Instruktion hat einfach nur ein L&auml;ngenfeld...).
<P>
Neben den eigentlichen Maschinenbefehlen des 8X30x implementiert AS
noch &auml;hnlich wie das ,,Vorbild'' MCCAP einige
Pseudoinstruktionen, die als eingebaute Makros ausgef&uuml;hrt sind:
<UL>
<LI> <TT>NOP</TT> ist eine Kurzschreibweise f&uuml;r<TT> MOVE
    AUX,AUX</TT></LI>
<LI> <TT>HALT</TT> ist eine Kurzschreibweise f&uuml;r<TT> JMP *</TT></LI>
<LI> <TT>XML ii</TT> ist eine Kurzschreibweise f&uuml;r<TT> XMIT
    ii,R12</TT> (nur 8X305)</LI>
<LI> <TT>XMR ii</TT> ist eine Kurzschreibweise f&uuml;r<TT> XMIT
    ii,R13</TT> (nur 8X305)</LI>
<LI> <TT>SEL &lt;busobj&gt;</TT> ist eine Kurzschreibweise f&uuml;r<TT>
    XMIT &lt;adr&gt;,IVL/IVR</TT>, f&uuml;hrt also die notwendige
    Vorselektion durch, um<TT> &lt;busobj&gt;</TT> ansprechen zu
    k&ouml;nnen.</LI>
</UL>
Die bei MCCAP ebenfalls noch vorhandenen<TT> CALL-</TT> und<TT>
RTN-</TT>Instruktionen sind mangels ausreichender Dokumentation
momentan nicht implementiert. Das gleiche gilt f&uuml;r einen Satz an
Pseudoinstruktionen zur Datenablage. Kommt Zeit, kommt Rat...
<P>

<H2><A NAME="sect_4_18_">4.18. XA</A></H2>
<P>
&Auml;hnlich wie sein Vorg&auml;nger MCS/51, jedoch im Unterschied zu
seinem ,,Konkurrenten'' MCS/251 besitzt der Philips XA einen
getrennten Bitadre&szlig;raum, d.h. alle mit Bitbefehlen
manipulierbaren Bits haben eine bestimmte, eindimensionale Adresse,
die in den Maschinenbefehlen auch so abgelegt wird. Die naheliegende
M&ouml;glichkeit, diesen dritten Adre&szlig;raum (neben Code und
Daten) auch so in AS anzubieten, habe ich nicht nutzen k&ouml;nnen,
und zwar aus dem Grund, da&szlig; ein Teil der Bitadressen im
Gegensatz zum MCS/51 nicht mehr eindeutig ist: Bits mit den Adressen
256 bis 511 bezeichnen Bits der Speicherzellen 20h..3fh aus dem
aktuellen Datensegment. Dies bedeutet aber, da&szlig; diese Adressen
je nach Situation unterschiedliche Bits ansprechen k&ouml;nnen - ein
definieren von Bits mit Hilfe von<TT> DC</TT>-Befehlen, was durch ein
extra Segment m&ouml;glich geworden w&auml;re, w&uuml;rde also nicht
&uuml;berm&auml;&szlig;ig viel Sinn ergeben. Zur Definition
einzelner, symbolisch ansprechbarer Bits steht aber nach wie vor
der<TT> BIT</TT>-Befehl zur Verf&uuml;gung, mit dem beliebige
Bitadressen (Register, RAM, SFR) definiert werden k&ouml;nnen.
F&uuml;r Bitadressen im internen RAM wird auch die 64K-Bank-Adresse
gespeichert, so da&szlig; AS Zugriffe &uuml;berpr&uuml;fen kann,
sofern das DS-Register korrekt mit<TT> ASSUME</TT> vorbesetzt wurde.
<P>
Nichts drehen kann man dagegen an den Bem&uuml;hungen von AS,
potentielle Sprungziele (also Zeilen im Code mit Label) auf gerade
Adressen auszurichten. Dies macht AS genauso wie andere XA-Assembler
auch durch Einf&uuml;gen von<TT> NOP</TT>s vor dem fraglichen Befehl.
<P>

<H2><A NAME="sect_4_19_">4.19. AVR</A></H2>
<P>
Im Gegensatz zum AVR-Assembler verwendet AS defaultm&auml;&szlig;ig
das Intel-Format zur Darstellung von Hexadezimalkonstanten und nicht
die C-Syntax. OK, nicht vorher in den (freien) AVR-Assembler
hineingeschaut, aber als ich mit dem AVR-Teil anfing, gab es zum AVR
noch nicht wesentlich mehr als ein vorl&auml;ufiges Datenbuch mit
Prozessortypen, die dann doch nie kamen...mit einem<TT> RELAXED
ON</TT> schafft man dieses Problem aus der Welt.
<P>
Optional kann AS f&uuml;r die AVRs (es geht auch f&uuml;r andere
CPU's, nur macht es dort keinen Sinn...) sogenannte
,,Objekt-Dateien'' erzeugen. Das sind Dateien, die sowohl Code als
auch Quellzeileninformationen enthalten und z.B. eine schrittweise
Abarbeitung auf Quellcodeebene mit dem von Atmel gelieferten
Simulator WAVRSIM erlauben. Leider scheint dieser mit
Quelldateispezifikationen, die l&auml;nger als ca. 20 Zeichen sind,
seine liebe Not zu haben: Namen werden abgeschnitten oder um wirre
Sonderzeichen erg&auml;nzt, wenn die Maximall&auml;nge
&uuml;berschritten wird. AS speichert deshalb in den Objekt-Dateien
Dateinamen ohne Pfadangabe, so da&szlig; es eventuell Probleme geben
k&ouml;nnte, wenn Dateien (z.B. Includes) nicht im Arbeitsverzeichnis
liegen.
<P>
Eine kleine Besonderheit sind Befehle, die Atmel bereits in der
Architektur vorgesehen hat, aber noch in keinem Mitglied der Familie
implementiert wurden. Dabei handelt es sich um die Befehle<TT> MUL,
JMP</TT> und<TT> CALL</TT>. Besonders bei letzteren fragt man sich
vielleicht, wie man denn nun den 4 KWorte gro&szlig;en
Adre&szlig;raum des AT90S8515 erreichen kann, wenn die
'n&auml;chstbesten' Befehle<TT> RJMP</TT> und<TT> RCALL</TT> doch nur
2 KWorte weit springen kann. Der Kunstgriff lautet 'Abschneiden der
oberen Adre&szlig;bits' und ist n&auml;her bei der<TT>
WRAPMODE</TT>-Anweisung beschrieben.
<P>

<H2><A NAME="sect_4_20_">4.20. Z80UNDOC</A></H2>
<P>
Da es von Zilog naturgem&auml;&szlig; keine Syntaxvorgaben f&uuml;r
die undokumentierten Befehle gibt und wohl auch nicht jeder den
kompletten Satz kennt, ist es vielleicht sinnvoll, diese Befehle hier
kurz aufzuz&auml;hlen:
<P>
Wie auch beim Z380 ist es m&ouml;glich, die Byte-H&auml;lften von IX
und IY einzeln anzusprechen. Im einzelnen sind dies folgende
Varianten:
<PRE>

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx

</PRE>
Dabei stehen<TT> Rx</TT> bzw.<TT> Ry</TT> f&uuml;r<TT> IXL, IXU,
IYL</TT> oder<TT> IYU</TT>. Zu beachten ist jedoch, da&szlig; in
der<TT> LD Rx,Ry</TT>-Variante beide Register aus dem gleichen
Indexregister stammen m&uuml;ssen.
<P>
Die Kodierung von Schiebebefehlen besitzt noch eine undefinierte
Bitkombination, die als<TT> SLIA</TT>-Befehl zug&auml;nglich ist.<TT>
SLIA</TT> funktioniert wie<TT> SLA</TT>, es wird jedoch eine Eins und
nicht eine Null in Bit 0 eingeschoben. Dieser Befehl kann, wie alle
anderen Schiebebefehle auch, noch in einer weiteren Variante
geschrieben werden:
<PRE>

        SLIA    R,(XY+d)

</PRE>
Dabei steht<TT> R</TT> f&uuml;r ein beliebiges 8-Bit-Register (aber
nicht eine Indexregisterh&auml;lfte...), und<TT> (XY+d)</TT> f&uuml;r
eine normale indexregister-relative Adressierung. Das Ergebnis dieser
Operation ist, da&szlig; das Schiebeergebnis zus&auml;tzlich ins
Register geladen wird. Dies funktioniert auch bei den<TT> RES-</TT>
und<TT> SET-</TT>Befehlen:
<PRE>

        SET/RES R,n,(XY+d)

</PRE>
Des weiteren gibt es noch zwei versteckte I/O-Befehle:
<PRE>

        IN      (C) bzw. TSTI
        OUT     (C),0

</PRE>
Deren Funktionsweise sollte klar sein.<B> ACHTUNG!</B> Es gibt keine
Garantie daf&uuml;r, da&szlig; alle Z80-Masken alle diese Befehle
beherrschen, und die Z80-Nachfolger l&ouml;sen zuverl&auml;ssig Traps
aus. Anwendung daher auf eigene Gefahr...
<P>

<H2><A NAME="sect_4_21_">4.21. Z380</A></H2>
<P>
Da dieser Prozessor als Enkel des wohl immer noch beliebtesten
8-Bit-Prozessors konzipiert wurde, war es bei der Entwicklung
unabdingbar, da&szlig; dieser bestehende Z80-Programme ohne
&Auml;nderung ausf&uuml;hren kann (nat&uuml;rlich geringf&uuml;gig
schneller, etwa um den Faktor 10...). Die erweiterten
F&auml;higkeiten k&ouml;nnen daher nach einem Reset mit zwei Flags
zugeschaltet werden, die XM (eXtended Mode, d.h. 32- statt
16-Bit-Adre&szlig;raum) und LW (long word mode, d.h. 32- statt 16-
Bit-Operanden) hei&szlig;en. Deren Stand mu&szlig; man AS &uuml;ber
die Befehle<TT> EXTMODE</TT> und<TT> LWORDMODE</TT> mitteilen, damit
Adressen und Konstantenwerte gegen die korrekten Obergrenzen
gepr&uuml;ft werden. Die Umschaltung zwischen 32- und 16-Bit-Befehlen
bewirkt nat&uuml;rlich nur bei solchen Befehlen etwas, die auch in
einer 32-Bit-Version existieren; beim Z380 sind das momentan leider
nur Lade- und Speicherbefehle, die ganze Aritmetik kann nur 16-bittig
ausgef&uuml;hrt werden. Hier sollte Zilog wohl noch einmal etwas
nachbessern, sonst kann man den Z380 selbst beim besten Willen nur
als ,,16-Bit-Prozessor mit 32-Bit-Erweiterungen'' bezeichnen...
<P>
Kompliziert wird die Sache dadurch, da&szlig; die mit LW eingestellte
Operandengr&ouml;&szlig;e f&uuml;r einzelne Befehle mit den
Pr&auml;fixen<TT> DDIR W</TT> und<TT> DDIR LW</TT> &uuml;bersteuert
werden kann. AS merkt sich das Auftreten solcher Befehle und schaltet
dann f&uuml;r den n&auml;chsten Prozessorbefehl automatisch mit um.
Andere<TT> DDIR</TT>-Varianten als<TT> W</TT> und<TT> LW</TT> sollte
man &uuml;brigens nie explizit verwenden, da AS bei zu langen
Operanden diese automatisch einsetzt, und das k&ouml;nnte zu
Verwirrungen f&uuml;hren. Die Automatik geht &uuml;brigens so weit,
da&szlig; in der Befehlsfolge
<PRE>

        DDIR    LW
        LD      BC,12345678h

</PRE>
automatisch der erforderliche<TT> IW</TT>-Pr&auml;fix mit in die
vorangehende Anweisung hineingezogen wird, effektiv wird also der
Code
<PRE>

        DDIR    LW,IW
        LD      BC,12345678h

</PRE>
erzeugt. Der im ersten Schritt erzeugte Code f&uuml;r<TT> DDIR
LW</TT> wird verworfen, was an einem<TT> R</TT> im Listing zu
erkennen ist.
<P>

<H2><A NAME="sect_4_22_">4.22. TLCS-900(L)</A></H2>
<A NAME="ref_TLCS900Spec"></A>
<P>
Diese Prozessoren k&ouml;nnen in zwei Betriebsarten laufen, einmal
im<I> Minimum</I>-Modus, der weitgehende Z80- und
TLCS-90-Quellcodekompatibilit&auml;t bietet, und zum anderen im<I>
Maximum</I>-Modus, in dem der Prozessor erst seine wahren
Qualit&auml;ten entfaltet. Die Hauptunterschiede zwischen den beiden
Betriebsarten sind:
<UL>
<LI> Breite der Register WA,BC,DE und HL: 16 oder 32 Bit;</LI>
<LI> Anzahl der Registerbanks: 8 oder 4;</LI>
<LI> Programmadre&szlig;raum: 64 Kbyte oder 16 Mbyte;</LI>
<LI> Breite von R&uuml;cksprungadressen: 16 oder 32 Bit.</LI>
</UL>
Damit AS gegen die richtigen Grenzen pr&uuml;fen kann, mu&szlig; man
ihm zu Anfang mit dem Befehl<TT> MAXMODE</TT> (siehe dort) mitteilen,
in welcher Betriebsart der Code ausgef&uuml;hrt werden wird;
Voreinstellung ist der Minimum-Modus.
<P>
Je nach Betriebsart m&uuml;ssen demzufolge auch die 16- oder
32-Bit-Versionen der Bankregister zur Adressierung verwendet werden,
d.h. WA, BC, DE und HL im Minimum-Modus sowie XWA, XBC, XDE und XHL
im Maximum-Modus. Die Register XIX..XIZ und XSP sind<B> immer</B> 32
Bit breit und m&uuml;ssen zur Adressierung auch immer in dieser Form
verwendet werden; hier mu&szlig; bestehender Z80-Code also auf jeden
Fall angepa&szlig;t werden (neben der Tatsache, da&szlig; es gar
keinen I/O-Adre&szlig;raum mehr gibt und alle I/O-Register
memory-mapped sind...).
<P>
Die von Toshiba gew&auml;hlte Syntax f&uuml;r Registernamen ist in
der Hinsicht etwas ungl&uuml;cklich, als da&szlig; zur Anwahl der
vorherigen Registerbank ein Hochkomma (') benutzt wird. Dieses
Zeichen wird von den prozessorunabh&auml;ngigen Teilen von AS bereits
zur Kennzeichnung von Zeichenkonstanten benutzt. Im Befehl
<PRE>

        ld      wa',wa

</PRE>
erkennt AS z.B. nicht das Komma zur Parametertrennung. Dieses Problem
kann man aber umgehen, indem man ein umgekehrtes Hochkomma (`)
verwendet, z.B.
<PRE>

        ld      wa`,wa

</PRE>
Toshiba liefert f&uuml;r die TLCS-900-Reihe selber einen Assembler
(TAS900), der sich in einigen Punkten von AS unterscheidet:
<P>

<H4>Symbolkonventionen</H4>
<P>
<UL>
<LI> TAS900 unterscheidet Symbolnamen nur auf den ersten 32 Zeichen. AS
    dagegen speichert Symbolnamen immer in der vollen L&auml;nge (bis
    255 Zeichen) und unterscheidet auch auf dieser L&auml;nge.</LI>
<LI> Unter TAS900 k&ouml;nnen Integerkonstanten sowohl in C-Notation (mit
    vorangestellter 0 f&uuml;r oktal bzw. 0x f&uuml;r hexadezimal)
    als auch in normaler Intel-Notation geschrieben werden. AS
    unterst&uuml;tzt in der Default-Einstellung<B> nur</B> die
    Intel-Notation. Mit dem<TT> RELAXED</TT>-Befehl bekommt man
    (unter anderem) auch die C-Notation.</LI>
<LI> AS macht keinen Unterschied zwischen Gro&szlig;- und
    Kleinschreibung, TAS900 hingegen unterscheidet Gro&szlig;-und
    Kleinbuchstaben in Symbolnamen. Dieses Verhalten erh&auml;lt man
    bei AS erst, wenn man die<TT> -u</TT>-Kommandozeilenoption
    benutzt.</LI>
</UL>
<P>

<H4>Syntax</H4>
<P>
AS ist bei vielen Befehlen in der Syntaxpr&uuml;fung weniger streng
als TAS900, bei einigen weicht er (sehr) geringf&uuml;gig ab. Diese
Erweiterungen bzw. &Auml;nderungen dienen teilweise der leichteren
Portierung von bestehendem Z80-Code, teilweise einer
Schreiberleichterung und teilweise einer besseren Orthogonalit&auml;t
der Assemblersyntax:
<UL>
<LI> Bei den Befehlen<TT> LDA, JP</TT> und<TT> CALL</TT> verlangt TAS,
    da&szlig; Adre&szlig;ausdr&uuml;cke wie<TT> XIX+5</TT> nicht
    geklammert sein d&uuml;rfen, wie es sonst &uuml;blich ist. AS
    verlangt im Sinne der Orthogonalit&auml;t f&uuml;r<TT> LDA</TT>
    dagegen immer eine Klammerung, bei<TT> JP</TT> und<TT> CALL</TT>
    ist sie dagegen f&uuml;r einfache, absolute Adressen
    optional.</LI>
<LI> Bei den bedingten Befehlen<TT> JP, CALL, JR</TT> und<TT> SCC</TT>
    stellt AS es dem Programmierer frei, die Default-Bedingung<TT>
    T</TT> (= true) als ersten Parameter anzugeben oder nicht. TAS900
    hingegen erlaubt es nur, die Default-Bedingung implizit zu
    benutzen (also z.B.<TT> jp (xix+5)</TT> anstelle von<TT> jp
    t,(xix+5)</TT>).</LI>
<LI> AS erlaubt beim<TT> EX</TT>-Befehl auch Operandenkombinationen, die
    zwar nicht direkt im User's Manual<A
    HREF="#cite_Tosh900">[106]</A> genannt werden, aber durch
    Vertauschung auf eine genannte zur&uuml;ckgef&uuml;hrt werden
    k&ouml;nnen. Kombinationen wie<TT> EX f`,f</TT> oder<TT> EX
    wa,(xhl)</TT> werden damit m&ouml;glich. TAS900 hingegen
    l&auml;&szlig;t nur die ,,reine Lehre'' zu.</LI>
<LI> AS erlaubt, bei den Befehlen<TT> INC</TT> und<TT> DEC</TT> die
    Angabe des Inkrements oder Dekrements wegzulassen, wenn dies 1
    ist. Unter TAS900 dagegen mu&szlig; auch eine 1 hingeschrieben
    werden.</LI>
<LI> &Auml;hnlich verh&auml;lt es sich bei allen Schiebebefehlen: Ist der
    zu verschiebende Operand ein Register, so verlangt TAS900,
    da&szlig; auch eine Schiebeamplitude von 1 ausgeschrieben werden
    mu&szlig;; ist dagegen eine Speicherstelle der Operand, so ist
    die Schiebezahl (hardwarebedingt) immer 1 und darf auch nicht
    hingeschrieben werden. Unter AS dagegen ist die Schiebezahl 1
    immer optional und auch f&uuml;r alle Operandentypen
    zul&auml;ssig.</LI>
</UL>
<P>

<H4>Makroprozessor</H4>
<P>
Der Makroprozessor wird TAS900 als externes Programm vorgeschaltet
und besteht aus zwei Komponenten: einem C-artigen Pr&auml;prozessor
und einer speziellen Makrosprache (MPL), die an h&ouml;here
Programmiersprachen erinnert. Der Makroprozessor von AS dagegen
orientiert sich an ,,klassischen'' Makroassemblern wie dem M80 oder
MASM (beides Programme von Microsoft). Er ist fester Bestandteil des
Programmes.
<P>

<H4>Ausgabeformat</H4>
<P>
TAS900 erzeugt relokatiblen Code, so da&szlig; sich mehrere, getrennt
assemblierte Teile zu einem Programm zusammenbinden lassen. AS
hingegen erzeugt direkt absoluten Maschinencode, der nicht linkbar
ist. An eine Erweiterung ist (vorl&auml;ufig) nicht gedacht.
<P>

<H4>Pseudoanweisungen</H4>
<P>
Bedingt durch den fehlenden Linker fehlen in AS eine ganze Reihe von
f&uuml;r relokatiblen Code erforderlichen Pseudoanweisungen, die
TAS900 implementiert. In gleicher Weise wie bei TAS900 sind folgende
Anweisungen vorhanden:
<BLOCKQUOTE>
    <TT> EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE,</TT>
</BLOCKQUOTE>
wobei die beiden letzteren einen erweiterten Funktionsumfang haben.
Einige weitere TAS900-Pseudobefehle lassen sich durch
&auml;quivalente AS-Befehle ersetzen (siehe Tabelle <A
HREF="#ref_TabTAS900">4.2</A>).
<P>
Von Toshiba existieren zwei Versionen des Prozessorkerns, wobei die
L-Variante eine ,,Sparversion'' darstellt. Zwischen TLCS-900 und
TLCS-900L macht AS folgende Unterschiede:
<UL>
<LI> Die Befehle<TT> MAX</TT> und<TT> NORMAL</TT> sind f&uuml;r die
    L-Version nicht erlaubt, der<TT> MIN</TT>-Befehl ist f&uuml;r die
    Vollversion gesperrt.</LI>
<LI> Die L-Version kennt den Normal-Stapelzeiger<TT> XNSP/NSP</TT> nicht,
    daf&uuml;r das Steuerregister<TT> INTNEST</TT>.</LI>
</UL>
Die Befehle<TT> SUPMODE</TT> und<TT> MAXMODE</TT> werden nicht
beeinflu&szlig;t, ebenso nicht deren initiale Einstellung OFF. Die
Tatsache, da&szlig; die L-Version im Maximum-Modus startet und keinen
Normal-Modus kennt, mu&szlig; also vom Programmierer
ber&uuml;cksichtigt werden. AS zeigt sich jedoch insofern kulant
gegen&uuml;ber der L-Variante, als da&szlig; Warnungen wegen
privilegierter Anweisungen im L-Modus unterdr&uuml;ckt werden.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>TAS900</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung/Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DL</TT> &lt;Daten&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DD</TT> &lt;Daten&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher in Langworten belegen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSB</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DB</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher byteweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSW</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DW</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher wortweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DSD</TT> &lt;Zahl&gt;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DD</TT> &lt;Zahl&gt;<TT> DUP</TT> (?)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Speicher langwortweise reservieren</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $MIN[IMUM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MAXMODE OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im Minimum-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $MAX[IMUM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MAXMODE ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im Maximum-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $SYS[TEM]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUPMODE ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im System-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $NOR[MAL]</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUPMODE OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>folgender Code im User-Modus</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $NOLIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING OFF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Assemblerlisting ausschalten</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $LIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING ON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Assemblerlisting einschalten</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $EJECT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NEWPAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>neue Seite im Listing beginnen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.2: &auml;quivalente Befehle TAS900<->AS<A
             NAME="ref_TabTAS900"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_4_23_">4.23. TLCS-90</A></H2>
<P>
Vielleicht fragt sich der eine oder andere, ob bei mir die
Reihenfolge durcheinandergekommen ist, es gab ja von Toshiba zuerst
den 90er als ,,aufgebohrten Z80'' und danach den 900er als
16-Bit-Version. Nun, ich bin einfach &uuml;ber den 900er zum 90er
gekommen (Danke, Oliver!). Die beiden Familien sind sich sehr
artverwandt, nicht nur was ihre Syntax angeht, sondern auch ihre
Architektur. Die Hinweise f&uuml;r den 90er sind daher eine
Untermenge derer f&uuml;r den 900er: Da Schieben, Inkrementieren und
Dekrementieren hier nur um eins m&ouml;glich sind, braucht und darf
diese Eins auch nicht als erstes Argument hingeschrieben werden. Bei
den Befehlen<TT> LDA, JP</TT> und<TT> CALL</TT> m&ouml;chte Toshiba
wieder die Klammern um Speicheroperanden weglassen, bei AS
m&uuml;ssen sie aber aus Gr&uuml;nden der Orthogonalit&auml;t gesetzt
werden (der tiefere Grund ist nat&uuml;rlich, da&szlig; ich mir damit
eine Sonderabfrage im Parser gespart habe, aber das sagt man nicht so
laut).
<P>
Die TLCS-90er besitzen bereits prinzipiell einen Adre&szlig;raum von
1 Mbyte, dieser Raum erschlie&szlig;t sich aber nur bei
Datenzugriffen &uuml;ber die Indexregister. AS verzichtet daher auf
eine Ber&uuml;cksichtigung der Bankregister und begrenzt den
Adre&szlig;raum f&uuml;r Code auf 64 Kbyte. Da der Bereich jenseits
aber sowieso nur &uuml;ber indirekte Adressierung erreichbar ist,
sollte dies keine allzu gro&szlig;e Einschr&auml;nkung darstellen.
<P>

<H2><A NAME="sect_4_24_">4.24. TLCS-870</A></H2>
<P>
Schon wieder Toshiba...diese Firma ist im Augenblick wirklich sehr
produktiv! Speziell dieser Spro&szlig; der Familie (Toshibas
Mikrokontroller sind sich ja alle in Bin&auml;rkodierung und
Programmiermodell recht &auml;hnlich) scheint auf den 8051-Markt
abzuzielen: Die Methode, Bitstellen durch einen Punkt getrennt an den
Adre&szlig;ausdruck anzuh&auml;ngen, hatte ja beim 8051 ihren
Ursprung, f&uuml;hrt jetzt aber auch genau zu den Problemen, die ich
beim 8051 geahnt hatte: Der Punkt ist jetzt einerseits legales
Zeichen in Symbolnamen, andererseits aber auch Teil der
Adre&szlig;syntax, d.h. AS mu&szlig; Adresse und Bitstelle trennen
und einzeln weiterverarbeiten. Diesen Interessenkonflikt habe ich
vorerst so gel&ouml;st, da&szlig; der Ausdruck von<B> hinten</B> an
nach Punkten durchsucht wird und so der letzte Punkt als Trenner
gilt, eventuelle weitere Punkte werden dem Symbolnamen zugerechnet.
Es gilt weiterhin die flehentliche Bitte, im eigenen Interesse auf
Punkte in Symbolnamen zu verzichten, sie f&uuml;hren nur zu
Verwirrungen:
<PRE>

        LD      CF,A.7  ; Akku Bit 7 nach Carry
        LD      C,A.7   ; Konstante A.7 nach Register C

</PRE>
<P>

<H2><A NAME="sect_4_25_">4.25. TLCS-47</A></H2>
<P>
Mit dieser 4-Bit-Prozessorfamilie d&uuml;rfte wohl das unter Ende
dessen erreicht sein, was AS unterst&uuml;tzen kann. Neben dem<TT>
ASSUME</TT>-Befehl f&uuml;r das Datenbankregister (siehe dort) ist
eigentlich nur ein Detail erw&auml;hnenswert: im Daten- und
I/O-Segment werden keine Bytes, sondern Nibbles reserviert (eben
4-Bitter...). Die Sache funktioniert &auml;hnlich wie das
Bitdatensegment beim 8051, wo ein<TT> DB</TT> ja nur einzelne Bit
reserviert, nur da&szlig; es hier eben Nibbles sind.
<P>
Toshiba hat f&uuml;r diese Prozessorfamilie einen ,,erweiterten
Befehlssatz'' in Makroform definiert, um das Arbeiten mit diesem doch
recht beschr&auml;nkten Befehlssatz zu erleichtern. Im Fall von AS
ist er in der Datei STDDEF47.INC definiert. Einige Befehle, deren
makrom&auml;&szlig;ige Realisierung nicht m&ouml;glich war, sind
allerdings ,,eingebaut'' und stehen daher auch ohne die Include-Datei
zur Verf&uuml;gung:
<UL>
<LI> der<TT> B</TT>-Befehl, der die jeweils optimale Version des
    Sprungbefehls (<TT>BSS, BS oder BSL</TT>) automatisch
    w&auml;hlt;</LI>
<LI> <TT>LD</TT> in der Variante HL mit immediate;</LI>
<LI> <TT>ROLC</TT> und<TT> RORC</TT> mit einer Schiebeamplitude
    &gt;1.</LI>
</UL>
<P>

<H2><A NAME="sect_4_26_">4.26. TLCS-9000</A></H2>
<P>
Hier ist es zum ersten Mal passiert, da&szlig; ich einen Prozessor in
AS implementiert habe, der zu diesem Zeitpunkt noch gar nicht auf dem
Markt war. Toshiba hat sich leider auch vorl&auml;ufig dazu
entschieden, diesen Prozessor ,,auf Eis'' zu legen, bis auf weiteres
wird es also auch kein Silizium geben. Das hat nat&uuml;rlich zur
Folge, da&szlig; dieser Teil
<DL COMPACT>
<DT>1.<DD>ein ,,Paper-Design'' ist, d.h. noch nicht praktisch getestet wurde
    und</DD>
<DT>2.<DD>Die Unterlagen, die ich zum 9000er hatte <A
    HREF="#cite_Tosh9000">[109]</A>, noch vorl&auml;ufig waren, also
    noch nicht bis ins letzte Klarheit lieferten.</DD>
</DL>
Fehler in diesem Teil sind also durchaus noch m&ouml;glich (und
werden nat&uuml;rlich bereinigt, wenn es denn einmal gehen sollte!).
Zumindest die Handvoll Beispiele in <A
HREF="#cite_Tosh9000">[109]</A> werden aber richtig &uuml;bersetzt.
<P>

<H2><A NAME="sect_4_27_">4.27. 29xxx</A></H2>
<P>
Wie schon beim<TT> ASSUME</TT>-Befehl beschrieben, kann AS mit der
Kenntnis &uuml;ber den Inhalt des RBP-Registers feststellen, ob im
User-Modus auf gesperrte Register zugegriffen wird. Diese
F&auml;higkeit beschr&auml;nkt sich nat&uuml;rlich auf direkte
Zugriffe (also nicht, wenn die Register IPA...IPC benutzt werden),
und sie hat noch einen weiteren Haken: da lokale Register (also
solche mit Nummern&gt;127) relativ zum Stackpointer adressiert
werden, die Bits in RBP sich aber immer auf absolute Nummern
beziehen, wird die Pr&uuml;fung f&uuml;r lokale Register NICHT
durchgef&uuml;hrt. Eine Erweiterung auf lokale Register w&uuml;rde
bedingen, da&szlig; AS zu jedem Zeitpunkt den absoluten Wert von SP
kennt, und das w&uuml;rde sp&auml;testens bei rekursiven
Unterprogrammen scheitern...
<P>

<H2><A NAME="sect_4_28_">4.28. 80C16x</A></H2>
<P>
Wie in der Erkl&auml;rung des<TT> ASSUME</TT>-Befehls schon
erl&auml;utert, versucht AS, dem Programmierer die Tatsache,
da&szlig; der Prozessor mehr physikalischen als logischen Speicher
hat, soweit als m&ouml;glich zu verbergen. Beachten Sie aber,
da&szlig; die DPP-Register<B> nur</B> Datenzugriffe betreffen und
auch dort nur absolute Adressierung, also weder indirekte noch
indizierte Zugriffe, da AS ja nicht wissen kann, wie die berechnete
Adresse zur Laufzeit aussehen wird...Bei Codezugriffen arbeitet die
Paging-Einheit leider nicht, man mu&szlig; also explizit mit langen
oder kurzen<TT> CALL</TT>s,<TT> JMP</TT>s oder<TT> RET</TT>s
arbeiten. Zumindest bei den ,,universellen'' Befehlen<TT> CALL</TT>
und<TT> JMP</TT> w&auml;hlt AS automatisch die k&uuml;rzeste Form,
aber sp&auml;testens beim<TT> RET</TT> sollte man wissen, woher der
Aufruf kam. Prinzipiell verlangen<TT> JMPS</TT> und<TT> CALLS</TT>
dabei, da&szlig; man Segment und Adresse getrennt angibt, AS ist
jedoch so geschrieben, da&szlig; er eine Adresse selber zerlegen
kann, z.B.
<PRE>

        jmps    12345h

</PRE>
anstelle von
<PRE>

        jmps    1,2345h

</PRE>
Leider sind nicht alle Effekte der chipinternen Instruktions-Pipeline
versteckt: Werden CP (Registerbankadresse), SP (Stack) oder eines der
Paging-Register ver&auml;ndert, so steht der neue Wert noch nicht
f&uuml;r den n&auml;chsten Befehl zur Verf&uuml;gung. AS versucht,
solche Situationen zu erkennen und gibt im Falle eines Falles eine
Warnung aus. Aber auch diese Mimik greift nur bei direkten Zugriffen.
<P>
Mit<TT> BIT</TT> definierte Bits werden intern in einem 13-Bit-Wort
abgelegt, wobei die Bitadresse in Bit 4..11 liegt und die Bitnummer
in den unteren vier Bits. Diese Anordnung erlaubt es, das
n&auml;chsth&ouml;here bzw. n&auml;chstniedrigere Bit durch
Inkrementieren bzw. Dekrementieren anzusprechen. Bei expliziten
Bitangaben mit Punkt funktioniert das aber nicht &uuml;ber
Wortgrenzen hinaus. So erzeugt folgender Ausdruck eine
Wertebereichs&uuml;berschreitung:
<PRE>

        bclr    r5.15+1

</PRE>
Hier mu&szlig; ein<TT> BIT</TT> her:
<PRE>

msb     bit     r5.15
        .
        .
        .
        bclr    msb+1

</PRE>
F&uuml;r den 80C167/165/163 ist der SFR-Bereich verdoppelt worden;
da&szlig; ein Bit im zweiten Teil liegt, wird durch ein gesetztes Bit
12 vermerkt. Leider hatte Siemens bei der Definition des 80C166 nicht
vorausgesehen, da&szlig; 256 SFRs (davon 128 bitadressierbar)
f&uuml;r Nachfolgechips nicht reichen w&uuml;rden. So w&auml;re es
unm&ouml;glich, den zweiten SFR-Bereich von F000H..F1DFH mit kurzen
Adressen oder Bitbefehlen zu erreichen, h&auml;tten die Entwickler
nicht einen Umschaltbefehl eingebaut:
<PRE>

        EXTR    #n

</PRE>
Dieser Befehl bewirkt, da&szlig; f&uuml;r die n&auml;chsten<TT>
n</TT> Befehle (0&lt;<TT>n</TT>&lt;5) anstelle des normalen der
erweiterte SFR-Bereich angesprochen werden kann. AS erzeugt bei diesm
Befehl nicht nur den passenden Code, sondern setzt intern ein Flag,
da&szlig; f&uuml;r die n&auml;chsten<TT> n</TT> Befehle nur Zugriffe
auf den erweiterten SFR-Bereich zul&auml;&szlig;t. Da d&uuml;rfen
nat&uuml;rlich keine Spr&uuml;nge dabei sein... Bits aus beiden
Bereichen lassen sich nat&uuml;rlich jederzeit definieren, ebenso
sind komplette Register aus beiden SFR-Bereichen jederzeit mit
absoluter Adressierung erreichbar. Nur die kurze bzw. Bitadressierung
geht immer nur abwechselnd, Zuwiderhandlungen werden mit einer
Fehlermeldung geahndet.
<P>
&Auml;hnlich sieht es mit den Pr&auml;fixen f&uuml;r absolute bzw.
indirekte Adressierung aus: Da aber sowohl Argument des Pr&auml;fixes
als auch der Adre&szlig;ausdruck nicht immer zur
&Uuml;bersetzungszeit bestimmbar sind, sind die
Pr&uuml;fungsm&ouml;glichkeiten durch AS sehr eingeschr&auml;nkt,
weshalb er es auch bei Warnungen bel&auml;&szlig;t...im einzelnen
sieht das folgenderma&szlig;en aus:
<UL>
<LI> feste Vorgabe einer 64K-Bank mittels<TT> EXTS</TT> oder<TT>
    EXTSR</TT>: Im Adre&szlig;ausdruck werden direkt die unteren 16
    Bit der Zieladresse eingesetzt. Haben sowohl Pr&auml;fix als auch
    Befehl einen konstanten Operanden, so wird &uuml;berpr&uuml;ft,
    ob Pr&auml;fixargument und Bit 16..23 der Zieladresse identisch
    sind.</LI>
<LI> feste Vorgabe einer 16K-Seite mittels<TT> EXTP</TT> oder<TT>
    EXTPR</TT>: Im Adre&szlig;ausdruck werden direkt die unteren 14
    Bit der Zieladresse eingesetzt. Bit 14 und 15 bleiben konstant 0,
    da sie in diesem Modus nicht vom Prozessor ausgewertet werden.
    Haben sowohl Pr&auml;fix als auch Befehl einen konstanten
    Operanden, so wird &uuml;berpr&uuml;ft, ob Pr&auml;fixargument
    und Bit 14..23 der Zieladresse identisch sind.</LI>
</UL>
Damit das etwas klarer wird, ein Beispiel (die DPP-Register haben die
Reset-Vorbelegung) :
<PRE>

       extp     #7,#1           ; Bereich von 112K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0defh im Code
       mov      r0,1cdefh       ; --&gt;Warnung
       exts     #1,#1           ; Bereich von 64K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0cdefh im Code
       mov      r0,1cdefh       ; --&gt;Warnung

</PRE>
<P>

<H2><A NAME="sect_4_29_">4.29. PIC16C5x/16C8x</A></H2>
<P>
&Auml;hnlich wie die MCS-48-Familie teilen auch die PICs ihren
Programmspeicher in mehrere B&auml;nke auf, da im Opcode nicht
gen&uuml;gend Platz f&uuml;r die vollst&auml;ndige Adresse war. AS
verwendet f&uuml;r die Befehle<TT> CALL</TT> und<TT> GOTO</TT> die
gleiche Automatik, d.h. setzt die PA-Bits im Statuswort entsprechend
Start- und Zieladresse. Im Gegensatz zu den 48ern ist dieses
Verfahren hier aber noch deutlich problematischer:
<OL>
<LI>Die Befehle sind nicht mehr nur ein Wort, sondern bis zu drei Worten
    lang, k&ouml;nnen also nicht mehr in jedem Fall mit einem
    bedingten Sprung &uuml;bergangen werden.</LI>
<LI>Es ist m&ouml;glich, da&szlig; der Programmz&auml;hler beim normalen
    Programmfortgang eine Seitengrenze &uuml;berschreitet. Die vom
    Assembler angenommene Belegung der PA-Bits stimmt dann nicht mehr
    mit der Realit&auml;t &uuml;berein.</LI>
</OL>
Bei den Befehlen, die das Register W mit einem anderen Register
verkn&uuml;pfen, mu&szlig; normalerweise als zweiter Parameter
angegeben werden, ob das Ergebnis in W oder im Register abgelegt
werden soll. Bei diesem Assembler ist es erlaubt, den zweiten
Parameter wegzulassen. Welches Ziel dann angenommen werden soll,
h&auml;ngt vom Typ des Befehls ab: bei un&auml;ren Operationen wird
defaultm&auml;&szlig;ig das Ergebnis zur&uuml;ck ins Register gelegt.
Diese Befehle sind:
<BLOCKQUOTE>
    <TT> COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF</TT> und<TT>
    SWAPF</TT>
</BLOCKQUOTE>
Die anderen Befehle betrachten W defaultm&auml;&szlig;ig als
Akkumulator, zu dem ein Register verkn&uuml;pft wird:
<BLOCKQUOTE>
    <TT> ADDWF, ANDWF, IORWF, MOVF, SUBWF</TT> und<TT> XORWF</TT>
</BLOCKQUOTE>
<P>
Die von Microchip vorgegebene Schreibweise f&uuml;r Literale ist
ziemlich abstrus und erinnert an die auf IBM 360/370-Systemen
&uuml;bliche Schreibweise (Gr&uuml;&szlig;e aus Neandertal...). Um
nicht noch einen Zweig in den Parser einf&uuml;gen zu m&uuml;ssen,
sind bei AS Konstanten in Motorola-Syntax zu schreiben (wahlweise
auch Intel oder C im<TT> RELAXED</TT>-Modus).
<P>
Dem Assembler liegt die Include-Datei STDDEF16.INC bei, in der die
Adressen der Hardware-Register und Statusbits verewigt sind. Daneben
enth&auml;lt sie eine Liste von ,,Befehlen'', die der
Microchip-Assembler als Makro implementiert. Bei der Benutzung dieser
Befehlsmakros ist gro&szlig;e Vorsicht angebracht, da sie mehrere
Worte lang sind und sich somit nicht &uuml;berspringen lassen!!
<P>

<H2><A NAME="sect_4_30_">4.30. PIC17C4x</A></H2>
<P>
F&uuml;r diese Prozessoren gelten im wesentlichen die gleichen
Hinweise wie f&uuml;r ihre kleinen Br&uuml;der, mit zwei Ausnahmen:
Die zugeh&ouml;rige Include-Datei enth&auml;lt nur
Registerdefinitionen, und die Probleme bei Sprungbefehlen sind
deutlich kleiner. Aus der Reihe f&auml;llt nur<TT> LCALL</TT>, der
einen 16-Bit-Sprung erlaubt. Dieser wird mit folgendem ,,Makro''
&uuml;bersetzt:
<PRE>

        MOVLW   &lt;Adr15..8&gt;
        MOWF    3
        LCALL   &lt;Adr0..7&gt;

</PRE>
<P>

<H2><A NAME="sect_4_31_">4.31. ST6</A></H2>
<P>
Diese Prozessoren k&ouml;nnen das Code-ROM seitenweise in den
Datenbereich einblenden. Weil ich nicht die ganze Mimik des<TT>
ASSUME</TT>-Befehles hier wiederk&auml;uen m&ouml;chte, verweise ich
auf das entsprechende Kapitel (<A HREF="#ref_ST6Assume">3.2.15</A>),
in dem steht, wie man mit diesem Befehl einigerma&szlig;en unfallfrei
Konstanten aus dem ROM lesen kann.
<P>
Bei n&auml;hererer Betrachtung des Befehlssatzes fallen einige
eingebaute ,,Makros'' auf. Die Befehle, die mir aufgefallen sind (es
gibt aber vielleicht noch mehr...), sind in Tabelle <A
HREF="#ref_TabHid62">4.3</A> aufgelistet.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Befehl</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>in Wirklichkeit</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CLR A</TT><BR>
<TT> SLA A</TT><BR>
<TT> CLR adr</TT><BR>
<TT> NOP</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> SUB A,A</TT><BR>
<TT> ADD A,A</TT><BR>
<TT> LDI adr,0</TT><BR>
<TT> JRZ PC+1</TT></TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.3: versteckte Makros im ST6225-Befehlssatz<A
             NAME="ref_TabHid62"></A>
</CENTER><P>

Insbesondere der letztere Fall verbl&uuml;fft doch etwas... Leider
fehlen aber einige Anweisungen wirklich. So gibt es z.B. zwar
einen<TT> AND</TT>-Befehl, aber kein<TT> OR</TT>...von<TT> XOR</TT>
gar nicht zu reden. In der Datei STDDEF62.INC finden sich deshalb
neben den Adressen der SFRs noch einige Makros zur Abhilfe.
<P>
Der Original-Assembler AST6 von SGS-Thomson verwendet teilweise
andere Pseudobefehle als AS. Au&szlig;er der Tatsache, da&szlig; AS
Pseudobefehle nicht mit einem vorangestellten Punkt kennzeichnet,
sind folgende Befehle identisch:
<PRE>

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING

</PRE>
Tabelle <A HREF="#ref_TabAST6">4.4</A> zeigt die AST6-Befehle, zu
denen analoge in AS existieren.
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AST6</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung/Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .DISPLAY</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MESSAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Meldung ausgeben</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .EJECT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NEWPAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>neue Seite im Listing</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ELSE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ELSEIF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ENDC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ENDIF</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .IFC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> IF...</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>bed. Assemblierung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .INPUT</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INCLUDE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Include-Datei einbinden</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .LIST</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTING</TT>,<TT> MACEXP</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Listing-Einstellung</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .PL</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PAGE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Seitenl&auml;nge Listing</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .ROMSIZE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CPU</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zielprozessor einstellen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .VERS</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> VERSION</TT> (Symbol)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Version abfragen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> .SET</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> EVAL</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Variablen neu setzen</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 4.4: &auml;quivalente Befehle AST6<->AS<A
             NAME="ref_TabAST6"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_4_32_">4.32. ST7</A></H2>
<P>
In <A HREF="#cite_ST7Man">[81]</A> ist der '.w'-Postfix f&uuml;r
16-Bit-Adressen nur f&uuml;r speicherindirekte Operanden definiert,
um zu vermerken, da&szlig; auf einer Zeropageadresse eine 16-bittige
Adresse liegt; AS unterst&uuml;tzt ihn jedoch zus&auml;tzlich auch
f&uuml;r absolute Adressen oder Displacements in indizierter
Adressierung, um trotz eines nur 8 Bit langen Wertes (0..255) ein
16-bittiges Displacement zu erzeugen.
<P>

<H2><A NAME="sect_4_33_">4.33. ST9</A></H2>
<P>
Die Bitadressierungsm&ouml;glichkeiten des ST9 sind relativ
eingeschr&auml;nkt: Mit Ausnahme des<TT> BTSET</TT>-Befehls ist es
nur m&ouml;glich, auf Bits innerhalb des aktuellen
Arbeitsregistersatzes zuzugreifen. Eine Bit-Adresse sieht also
folgenderma&szlig;en aus:
<PRE>

  rn.[!]b

</PRE>
wobei ! eine optionale Invertierung eines Quelloperanden bedeutet.
Wird ein Bit symbolisch mittels des<TT> BIT</TT>-Befehles definiert,
so wird die Registernummer im Symbolwert in Bit 7..4, die Bitnummer
in Bit 3..1 und eine optionale Invertierung in Bit 0 vermerkt. AS
unterscheidet direkte und symbolische Bitangaben am Fehlen eines
Punktes, der Name eines Bitsymboles darf also keinen Punkt enthalten,
obwohl sie an sich zul&auml;ssig w&auml;ren. Es ist auch
zul&auml;ssig, bei der Referenzierung von Bitsymbolen diese zu
nachtr&auml;glich zu invertieren:
<PRE>

bit2    bit     r5.3
        .
        .
        bld	r0.0,!bit2

</PRE>
Auf diese Weise ist es auch m&ouml;glich, eine inverse Definition
nachtr&auml;glich wieder aufzuheben.
<P>
Bitdefinitionen finden sich in gro&szlig;er Zahl in der Include-Datei
REGST9.INC, in der die Register- und Bitnamen aller
On-Chip-Peripherie beschrieben sind. Beachten Sie jedoch, da&szlig;
deren Nutzung nur m&ouml;glich ist, wenn die Arbeitsregisterbank
vorher auch auf diese Register ausgerichtet wurde!
<P>
Im Gegensatz zu der zum AST9 von SGS-Thomson geh&ouml;renden
Definitionsdatei sind f&uuml;r AS die Namen der Peripherieregister
nur als allgemeine Registernamen definiert (<TT>R...</TT>), nicht
auch noch als Arbeitsregister (<TT>r...</TT>). Dies ist so, weil AS
Geschwindigkeitsgr&uuml;nden keine Aliasnamen f&uuml;r Register
definieren kann.
<P>

<H2><A NAME="sect_4_34_">4.34. 6804</A></H2>
<P>
Eigentlich habe ich diesen Prozessor ja nur eingebaut, um mich
&uuml;ber das seltsame Gebaren von SGS-Thomson zu beklagen: Als ich
das 6804-Datenbuch zum ersten Mal in die Hand bekam, f&uuml;hlte ich
mich ob des etwas ,,unvollst&auml;ndigen'' Befehlssatzes und der
eingebauten Makros spontan an die ST62-Serie vom gleichen Hersteller
erinnert. Ein genauerer Vergleich der Opcodes f&ouml;rderte
erstaunliches zu Tage: Ein 6804-Opcode ergibt sich durch Spiegelung
aller Bits im entsprechenden ST62-OpCode! Thomson hat hier also
offensichtlich etwas Prozessorkern-Recycling betrieben...wogegen ja
auch nichts einzuwenden w&auml;re, wenn nicht so eine
Verschleierungstaktik betrieben werden w&uuml;rde: andere Peripherie,
Motorola- anstelle Zilog-Syntax sowie das h&auml;&szlig;liche Detail,
in Opcodes enthaltene Argumente (z.B. Bitfelder mit Displacements)<B>
nicht</B> zu drehen. Letzterer Punkt hat mich auch nach l&auml;ngerem
&Uuml;berlegen dazu bewogen, den 6804 doch in AS aufzunehmen. Ich
wage &uuml;brigens keine Spekulationen, welche Abteilung bei Thomson
von welcher abgekupfert hat...
<P>
Im Gegensatz zur ST62-Version enth&auml;lt die Include-Datei f&uuml;r
den 6804 keine Makros, die die L&uuml;cken im Befehlssatz etwas
,,auspolstern'' sollen. Dies &uuml;berlasse ich dem geneigten Leser
als Finger&uuml;bung!
<P>

<H2><A NAME="sect_4_35_">4.35. TMS3201x</A></H2>
<P>
Offensichtlich ist es Ehrgeiz jedes Prozessorherstellers, seine
eigene Notation f&uuml;r Hexadezimalkonstanten zu erfinden. Texas
Instruments war bei diesen Prozessoren besonders originell: ein
vorangestelltes &gt;-Zeichen! Die &Uuml;bernahme dieses Formates in
AS h&auml;tte zu schweren Konflikten mit den Vergleichs-und
Schiebeoperatoren von AS im Formelparser gef&uuml;hrt. Ich habe mich
deshalb f&uuml;r die Intel-Notation entschieden, zu der sich TI bei
der 340x0-Serie und den 3201x-Nachfolgern ja dann auch durchgerungen
hat...
<P>
Leider hat das Instruktionswort dieser Prozessoren nicht
gen&uuml;gend Bits, um bei direkter Adressierung alle 8 Bits zu
enthalten, weshalb der Datenadre&szlig;raum logisch in 2 B&auml;nke
zu 128 W&ouml;rtern gespalten ist. AS verwaltet diesen als ein
durchgehendes Segment von 256 W&ouml;rtern und l&ouml;scht bei
direkten Zugriffen automatisch das Bit 7 (Ausnahme: Befehl<TT>
SST</TT>, der nur in die obere Bank schreiben kann). Der
Programmierer ist daf&uuml;r erforderlich, da&szlig; das Bank-Bit
stets den richtigen Wert hat!
<P>
Ein weiterer, nur sehr versteckt im Datenbuch stehender Hinweis:
Die<TT> SUBC</TT>-Anweisung ben&ouml;tigt zur Ausf&uuml;hrung intern
mehr als einen Takt, das Steuerwerk arbeitet jedoch schon an dem
n&auml;chsten Befehl weiter. Im auf ein<TT> SUBC</TT> folgenden
Befehl darf deshalb nicht auf den Akkumulator zugegriffen werden. AS
nimmt hier<B> keine</B> Pr&uuml;fung vor!
<P>

<H2><A NAME="sect_4_36_">4.36. TMS320C2x</A></H2>
<P>
Da ich nicht selber diesen Codegenerator geschrieben habe (was nichts
an seiner Qualit&auml;t mindert), kann ich nur kurz hier
umrei&szlig;en, wieso es Befehle gibt, bei denen ein vorangestelltes
Label als untypisiert, d.h. keinem Adre&szlig;raum zugeordnet,
gespeichert wird: Der 20er der TMS-Reihe kennt sowohl ein 64 Kbyte
gro&szlig;es Code- als auch Datensegment. Je nach externer
Beschaltung kann man dabei Code- und Datenbereiche &uuml;berlappen,
um z.B. Konstanten im Codebereich zu abzulegen und auf diese als
Daten zuzugreifen (Ablage im Code ist notwendig, weil &auml;ltere
AS-Versionen davon ausgehen, da&szlig; ein Datensegment aus RAM
besteht, das in einem Standalone-System nach dem Einschalten keinen
definierten Inhalt hat und verweigern in Segmenten au&szlig;er Code
deshalb die Ablage von Daten). Ohne dieses Feature w&uuml;rde AS nun
jeden Zugriff auf die abgelegten Daten mit einer Warnung (,,Symbol
aus falschem Segment'') quittieren. Im einzelnen erzeugen folgende
Pseudobefehle untypisierte Labels:
<BLOCKQUOTE>
    <TT> BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT<BR>
    DOUBLE, EFLOAT, BFLOAT</TT> und<TT> TFLOAT</TT>
</BLOCKQUOTE>
Sollten doch einmal typisierte Labels gew&uuml;nscht sein, so kann
man sich behelfen, indem man das Label in eine getrennte Zeile vor
dem Pseudobefehl schreibt. Umgekehrt kann man einen der anderen
Pseudobefehle mit einem typenlosen Label versehen, indem man vor dem
Befehl das Label mit
<PRE>

&lt;Name&gt;  EQU     $

</PRE>
definiert.
<P>

<H2><A NAME="sect_4_37_">4.37. TMS320C3x</A></H2>
<P>
Die gr&ouml;&szlig;ten Magenschmerzen bei diesem Prozessor hat mir
die Syntax paralleler Befehle bereitet, die auf zwei Zeilen verteilt
werden, wobei beide Befehle an sich auch sequentiell ausgef&uuml;hrt
werden k&ouml;nnen. Deshalb erzeugt AS zuerst den Code f&uuml;r die
einzelne erste Operation, wenn er dann in der zweiten Zeile erkennt,
da&szlig; eine parallele Aweisung vorliegt, wird der zuerst erzeugte
Code durch den neuen ersetzt. Im Listing kann man dies daran
erkennen, da&szlig; der Programmz&auml;hler nicht weiterl&auml;uft
und in der zweiten Zeile anstelle eines Doppelpunktes ein<TT> R</TT>
vor dem erzeugten Code steht.
<P>
Bez&uuml;glich der doppelten senkrechten Striche und ihrer Position
in der Zeile ist man nicht ganz so flexibel wie beim TI-Assembler:
Entweder man schreibt sie anstelle eines Labels (d.h. in der ersten
Spalte oder mit einem angeh&auml;ngten Doppelpunkt, das ist aber
nicht mehr TI-kompatibel...) oder direkt vor den zweiten Befehl ohne
Leerzeichen, sonst bekommt der Zeilenparser von AS Probleme und
h&auml;lt die Striche f&uuml;r das Mnemonic.
<P>

<H2><A NAME="sect_4_38_">4.38. TMS9900</A></H2>
<P>
Wie bei den meisten &auml;lteren Prozessorfamilien auch, hatte TI
seinerzeit ein eigenes Format zur Schreibweise von Hexadezimal- und
Bin&auml;rkonstanten verwendet, anstelle deren AS die normale, heute
auch bei TI gebr&auml;uchliche Intel-Notation verwendet.
<P>
Die TI-Syntax f&uuml;r Register erlaubt es, da&szlig; anstelle eines
echten Namens (entweder<TT> Rx</TT> oder<TT> WRx</TT>) auch eine
einfache Integer-Zahl zwischen 0 und 15 benutzt werden kann. Dies hat
zwei Folgen:
<UL>
<LI> <TT>R0...R15</TT> bzw.<TT> WR0..WR15</TT> sind einfache,
    vordefinierte Integersymbole mit den Werten 0..15, und die
    Definition von Registeraliasen funktioniert &uuml;ber
    schlichte<TT> EQUs</TT>.</LI>
<LI> Im Gegensatz zu einigen anderen Prozessoren kann ich nicht das
    zus&auml;tzliche AS-Feature anbieten, da&szlig; das Kennzeichen
    f&uuml;r absolute Adressierung (hier ein Klammeraffe) weggelassen
    werden darf. Da ein fehlendes Kennzeichen hier aber
    Registernummern (im Bereich 0 bis 15) bedeuten w&uuml;rde, war
    das hier nicht m&ouml;glich.</LI>
</UL>
Weiterhin wechselt TI mit der Registerbezeichnung zwischen<TT>
Rx</TT> und<TT> WRx</TT>...vorerst ist beides zugelassen.
<P>

<H2><A NAME="sect_4_39_">4.39. TMS70Cxx</A></H2>
<P>
Diese Prozessorreihe geh&ouml;rt noch zu den &auml;lteren, von TI
entwickelten Reihen, und deswegen benutzt TI in ihren eigenen
Assemblern noch die herstellereigene Syntax f&uuml;r hexadezimale und
bin&auml;re Konstanten (vorangestelltes &lt; bzw. ?). Da das in AS
aber so nicht machbar ist, wird defaultm&auml;&szlig;ig die
Intel-Syntax verwendet. Auf diese ist Texas bei den Nachfolgern
dieser Familie, n&auml;mlich den 370ern auch umgestiegen. Beim
genaueren Betrachten des Maschinenbefehlssatzes stellt man fest,
da&szlig; ca. 80% der 7000er-Befehle bin&auml;r
aufw&auml;rtskompatibel sind, und auch die Assemblersyntax ist fast
gleich - aber eben nur fast. Bei der Erweiterung des
7000er-Befehlssatzes hat TI n&auml;mlich auch gleich die Chance
genutzt, die Syntax etwas zu vereinheitlichen und zu vereinfachen.
Ich habe mich bem&uuml;ht, einen Teil dieser &auml;nderungen auch in
die 7000er Syntax einflie&szlig;en zu lassen:
<UL>
<LI> Anstelle eines Prozentzeichens zur Kennzeichnung von unmittelbarer
    Adressierung darf auch das allgemein bekanntere Doppelkreuz
    verwendet werden.</LI>
<LI> Wenn bei den Befehlen<TT> AND, BTJO, BTJZ, MOV, OR</TT> und<TT>
    XOR</TT> eine Port-Adresse (<TT>P...</TT>) als Quelle oder Ziel
    benutzt wird, ist es nicht notwendig, die Mnemonic-Form mit
    explizit angeh&auml;ngtem<TT> P</TT> zu benutzen - die allgemeine
    Form reicht genauso aus.</LI>
<LI> Der vorangestelle Klammeraffe f&uuml;r absolute oder B-indizierte
    Adressierung darf weggelassen werden.</LI>
<LI> Anstelle des<TT> CMPA</TT>-Befehls darf auch einfach<TT> CMP</TT>
    mit<TT> A</TT> als Ziel benutzt werden.</LI>
<LI> Anstelle<TT> LDA</TT> oder<TT> STA</TT> darf auch einfach der<TT>
    MOV</TT>-Befehl mit<TT> A</TT> als Ziel bzw. Quelle benutzt
    werden.</LI>
<LI> Anstelle des<TT> MOVD</TT>-Befehls darf auch<TT> MOVW</TT> benutzt
    werden.</LI>
<LI> Anstelle von<TT> RETS</TT> oder<TT> RETI</TT> darf auch
    verk&uuml;rzt<TT> RTS</TT> bzw.<TT> RTI</TT> geschrieben
    werden.</LI>
<LI> <TT>TSTA</TT> bzw.<TT> TSTB</TT> d&uuml;rfen auch als<TT> TST A</TT>
    bzw.<TT>TST B geschrieben werden.</TT></LI>
<LI> <TT>XCHB B</TT> ist als Alias f&uuml;r<TT> TSTB</TT>
    zugelassen.</LI>
</UL>
Wichtig - diese Varianten sind nur beim TMS70Cxx zugelassen -
entsprechende 7000er-Varianten sind bei den 370ern<EM> nicht</EM>
erlaubt!
<P>

<H2><A NAME="sect_4_40_">4.40. TMS370xxx</A></H2>
<P>
Obwohl diese Prozessoren keine speziellen Befehle zur Bitmanipulation
besitzen, wird mit Hilfe des Assemblers und des<TT>
DBIT</TT>-Befehles (siehe dort) die Illusion erzeugt, als ob man
einzelne Bits manipulieren w&uuml;rde. Dazu wird beim<TT>
DBIT</TT>-Befehl eine Adresse mit einer Bitposition
zusammengefa&szlig;t und in einem Symbol abgelegt, das man dann als
Argument f&uuml;r die Pseudobefehle<TT> SBIT0, SBIT1, CMPBIT,
JBIT0</TT> und<TT> JBIT1</TT> verwenden kann. Diese werden in die
Befehle<TT> OR, AND, XOR, BTJZ</TT> und<TT> BTJO</TT> mit einer
passenden Bitmaske &uuml;bersetzt.
<P>
An diesen Bit-Symbolen ist &uuml;berhaupt nichts geheimnisvolles, es
handelt sich um schlichte Integerwerte, in deren unterer H&auml;lfte
die Speicheradresse und in deren oberer H&auml;lfte die Bitstelle
gespeichert wird. Man k&ouml;nnte sich seine Symbole also auch ohne
weiteres selber basteln:
<PRE>

defbit  macro   name,bit,adr
name    equ     adr+(bit&lt;&lt;16)
        endm

</PRE>
aber mit dieser Schreibweise erreicht man nicht den<TT>
EQU</TT>-artigen Stil, den Texas vorgegeben hat (d.h. das zu
definierende Symbol steht anstelle eines Labels). ACHTUNG! Obwohl<TT>
DBIT</TT> eine beliebige Adresse zul&auml;&szlig;t, k&ouml;nnen
f&uuml;r die Pseudobefehle nur die Adressen 0..255 und 1000h..10ffh
verwendet werden, eine absolute Adressierungsart kennt der Prozessor
an dieser Stelle nicht...
<P>

<H2><A NAME="sect_4_41_">4.41. MSP430</A></H2>
<A NAME="ref_MSPSpec"></A>
<P>
Der MSP430 wurde als RISC-Prozessor mit minimalem Stromverbrauch
konzipiert. Aus diesem Grund ist der Satz von Befehlen, die der
Prozessor in Hardware versteht, auf das absolut notwendige reduziert
worden (da RISC-Prozessoren keinen Mikrocode besitzen, mu&szlig;
jeder Befehl mit zus&auml;tzlichem Silizium implementiert werden und
erh&ouml;ht so den Stromverbrauch). Eine Reihe von Befehlen, die bei
anderen Prozessoren in Hardware gegossen wurden, werden beim MSP
durch eine Emulation mit anderen Befehlen realisiert. Bei AS finden
sich diese Befehle mit in der Datei<TT> REGMSP.INC</TT>. Wer diese
Datei nicht einbindet, wird bei &uuml;ber der H&auml;lfte der
insgesamt von TI definierten Befehle Fehlermeldungen bekommen!!
<P>

<H2><A NAME="sect_4_42_">4.42. COP8 &amp; SC/MP</A></H2>
<A NAME="ref_COP8Spec"></A>
<P>
Leider Gottes hat sich auch National dazu entschieden, als
Schreibweise f&uuml;r nichtdezimale Integer-Konstanten die von
IBM-Gro&szlig;rechnern bekannte (und von mir vielgeha&szlig;te)
Variante  X'... zu benutzen. Das geht nat&uuml;rlich (wie immer)
nicht. Zum Gl&uuml;ck scheint der ASMCOP aber auch die C-Variante
zuzulassen, und diese wurde deshalb der Default f&uuml;r die COPs...
<P>

<H2><A NAME="sect_4_43_">4.43. SC144xxx</A></H2>
<A NAME="ref_SC144xxspec"></A>
<P>
Original gab es f&uuml;r diese Reihe von DECT-Controllern mit relativ
einfachem Befehlssatz nur einen sehr schlichten Assembler von
National selber. Ein Assembler von IAR Systems ist angek&uuml;ndigt,
aber noch nicht erh&auml;ltlich. Da die Entwicklungstools von IAR
allerdings auch nach M&ouml;glichkeit CPU-unabh&auml;ngig angelegt
sind, kann man anhand erh&auml;ltlicher Zielplattformen in
ungef&auml;hr absch&auml;tzen, wie dessen Pseudobefehle aussehen
werden, und damit im Blick sind die (wenigen) SC144xx-spezifisch
realisierten Befehle<TT> DC, DC8, DW16, DS, DS8, DS16, DW</TT>
angelegt. Bei Befehlen, die bereits im AS-Kern angelegt sind, wollte
ich nat&uuml;rlich nicht das Rad neu erfinden, deshalb hier eine
Tabelle mit &Auml;quivalenzen:
<P>
Die Befehle<TT> ALIGN, END, ENDM, EXITM, MACRO, ORG, RADIX, SET</TT>
und<TT> REPT</TT> exisieren sowohl bei IAR als auch AS und haben
gleiche Bedeutung. Bei folgenden Befehlen mu&szlig; man umstellen:
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>IAR</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>AS</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Funktion</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> #include</TT><BR>
<TT> #define</TT><BR>
<TT> #elif, ELIF, ELSEIF</TT><BR>
<TT> #else, ELSE</TT><BR>
<TT> #endif, ENDIF</TT><BR>
<TT> #error</TT><BR>
<TT> #if, IF</TT><BR>
<TT> #ifdef</TT><BR>
<TT> #ifndef</TT><BR>
<TT> #message</TT><BR>
<TT> =, DEFINE, EQU</TT><BR>
<TT> EVEN</TT><BR>
<TT> COL, PAGSIZ</TT><BR>
<TT> ENDR</TT><BR>
<TT> LSTCND, LSTOUT</TT><BR>
<TT> LSTEXP, LSTREP</TT><BR>
<TT> LSTXRF</TT><BR>
<TT> PAGE</TT><BR>
<TT> REPTC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> include</TT><BR>
<TT> SET, EQU</TT><BR>
<TT> ELSEIF</TT><BR>
<TT> ELSE</TT><BR>
<TT> ENDIF</TT><BR>
<TT> ERROR, FATAL</TT><BR>
<TT> IF</TT><BR>
<TT> IFDEF</TT><BR>
<TT> IFNDEF</TT><BR>
<TT> MESSAGE</TT><BR>
<TT> =, EQU</TT><BR>
<TT> ALIGN 2</TT><BR>
<TT> PAGE</TT><BR>
<TT> ENDM</TT><BR>
<TT> LISTING</TT><BR>
<TT> MACEXP</TT><BR>
 &lt;Kommandozeile&gt;<BR>
<TT> NEWPAGE</TT><BR>
<TT> IRPC</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Include-Datei einbinden<BR>
Symbole definieren<BR>
Weiterer Zweig einer IF-Kette<BR>
Letzter Zweig einer IF-Kette<BR>
Beendet eine IF-Kette<BR>
Fehlermeldung erzeugen<BR>
Beginn einer IF-Kette<BR>
Symbol definiert ?<BR>
Symbol nicht definiert ?<BR>
Nachricht ausgeben<BR>
Feste Wertzuweisung<BR>
Programmz&auml;hler gerade machen<BR>
Seitengr&ouml;&szlig;e f&uuml;r Listing setzen<BR>
Ende einer REPT-Struktur<BR>
Umfang des Listings steuern<BR>
Expandierte Makros anzeigen?<BR>
Querverweisliste erzeugen<BR>
Neue Seite im Listing<BR>
Repetition mit Zeichenersetzung</TD>
</TR>
</TABLE></CENTER>
</CENTER>

<P>
Keine direkte Entsprechung gibt es f&uuml;r die Befehle<TT> CASEON,
CASEOFF, LOCAL, LSTPAG, #undef</TT> und<TT> REPTI</TT>.
<P>
Ein direktes &Auml;quivalent der Pr&auml;prozessorbefehle ist
nat&uuml;rlich nicht m&ouml;glich, solange AS keinen C-artigen
Pr&auml;prozessor besitzt. C-artige Kommentare sind im Moment leider
auch nicht m&ouml;glich. Achtung: Wer IAR-Codes f&uuml;r AS umsetzt,
mu&szlig; die Pr&auml;prozessorstatements nicht nur umwandeln,
sondern auch aus Spalte 1 herausbewegen, da bei AS in Spalte 1 nur
Labels stehen d&uuml;rfen!
<P>

<H2><A NAME="sect_4_44_">4.44. 75K0</A></H2>
<A NAME="ref_75K0Spec"></A>
<P>
Wie bei einigen anderen Prozessoren auch, kennt die Assemblersprache
der 75er von NEC Pseudo-Bitoperanden, d.h. man kann einem Symbol eine
Kombination aus Adresse und Bitnummer zuweisen, die dann bei
bitorientierten Befehlen anstelle direkter Ausdr&uuml;cke verwendet
werden kann. Die drei folgenden Befehle erzeugen daher z.B.
identischen Code:
<PRE>

ADM     sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

</PRE>
AS unterscheidet direkte und symbolische Bitzugriffe an einem bei
Symbolen fehlenden Punkt; Punkte in Symbolnamen darf man daher nicht
verwenden, da es sonst zu Mi&szlig;verst&auml;ndnissen bei der
Aufl&ouml;sung kommt.
<P>
Die Ablage von Bitsymbolen orientiert sich dabei weitgehend an der
bin&auml;ren Kodierung, die die Prozessorhardware selber verwendet:
Es werden 16 Bit belegt, und es existieren ein ,,kurzes'' und ein
,,langes'' Format. Das kurze Format kann folgende Varianten
aufnehmen:
<UL>
<LI> direkte Zugriffe auf die Bereiche 0FBxH und 0FFxH</LI>
<LI> indirekte Zugriffe der Form Adr.@L (0FC0H <=<TT> Adr</TT> <=
    0FFFH)</LI>
<LI> indirekte Zugriffe der Form @H+d4.bit</LI>
</UL>
Das obere Byte ist auf 0 gesetzt, das untere Byte enth&auml;lt den
gem&auml;&szlig; <A HREF="#cite_NEC75">[73]</A> kodierten
Bitausdruck. Das lange Format kennt im Gegensatz dazu nur direkte
Adressierung, kann daf&uuml;r aber (korrekte Einstellungen von<TT>
MBS</TT> und<TT> MBE</TT> vorausgesetzt) den ganzen Adre&szlig;raum
abdecken. Bei langen Ausdr&uuml;cken stehen im unteren Byte Bit 7..0
der Adresse, in Bit 8 und 9 die Bitstelle sowie in Bit 10 und 11
konstant 01. Letztere erm&ouml;glichen es, langes und kurzes Format
einfach durch einen Vergleich des oberen Bytes gegen Null zu
unterscheiden. Die Bits 12..15 enthalten Bit 8..11 der Adresse; sie
werden zwar nicht zur Generierung des Kodes ben&ouml;tigt,
m&uuml;ssen jedoch gespeichert werden, da eine Pr&uuml;fung auf ein
korrektes Banking erst bei der Verwendung des Symboles erfolgen kann.
<P>

<H2><A NAME="sect_4_45_">4.45. 78K0</A></H2>
<A NAME="ref_78K0Spec"></A>
<P>
NEC benutzt in seinen Datenb&uuml;chern zur Kennzeichnung der
Zugriffsweise auf absolute Adressen verschiedene Schreibweisen:
<UL>
<LI> absolut kurz: kein Pr&auml;fix</LI>
<LI> absolut lang: vorangestelltes !</LI>
<LI> PC-relativ: vorangestelltes $</LI>
</UL>
Bei AS sind diese Pr&auml;fixe nur notwendig, falls man eine
bestimmte Adressierung erzwingen will und der Befehl verschiedene
Varianten zul&auml;&szlig;t. Setzt man keinen Pr&auml;fix, so
w&auml;hlt AS automatisch die k&uuml;rzeste Variante. Es d&uuml;rfte
daher in der Praxis sehr selten notwendig sein, einen Pr&auml;fix zu
verwenden.
<P>

<H2><A NAME="sect_4_46_">4.46. 78K2</A></H2>
<A NAME="ref_78K2Spec"></A>
<P>
Analog wie beim 78K0 benutzt NEC auch hier wieder Dollar- und
Ausrufezeichen f&uuml;r verschiedene L&auml;ngen von
Adre&szlig;sausdr&uuml;cken. Zwischen langen und kurzen Adressen
(sowohl im RAM- als auch SFR-Bereich) wird wieder automatisch
entschieden, nur relative Adressierung mu&szlig; man manuell
anw&auml;hlen, wenn ein Befehl beides unterst&uuml;tzt (z.B.<TT>
BR</TT>).
<P>
Noch eine Anmerkung (die im &uuml;brigens auch f&uuml;r den 78K0
gilt): Wer mittels<TT> RELAXED</TT> mit Motorola-Syntax arbeitet,
mu&szlig; Hexadezimalkonstanten klammern, weil das f&uuml;hrende
Dollarzeichen u.U. als relative Adressierung mi&szlig;verstanden
wird...
<P>

<H2><A NAME="sect_4_47_">4.47. uPD772x</A></H2>
<P>
Sowohl 7720 als auch 7725 werden von dem gleichen Codegenerator
behandelt und sind sich in ihren Befehlssatz extrem &auml;hnlich.
Trotzdem sollte man sich nicht zu der Annahme verleiten lassen, sie
seien bin&auml;r kompatibel: Um die l&auml;ngeren Adre&szlig;felder
und zus&auml;tzlichen Befehle unterbringen zu k&ouml;nnen, haben sich
die Bitpositionen einiger Felder im Instruktionswort verschoben, die
Instruktionsl&auml;nge hat sich auch insgesamt von 23 auf 24 Bit
ge&auml;ndert. Im Code-Format sind deshalb auch unterschiedliche
Header-Ids f&uuml;r beide reserviert.
<P>
Gemeinsam ist beiden, da&szlig; sie neben Code- und Datensegment auch
noch ein ROM zur Ablage von Konstanten besitzen. Dieses ist bei AS
auf das<TT> ROMDATA</TT>-Segment abgebildet!
<P>

<H2><A NAME="sect_4_48_">4.48. F2MC16L</A></H2>
<P>
Darauf, da&szlig; man bei Anwendungen mit mehr als 64K ROM oder 64K
RAM darauf achten sollte, AS die korrekte momentane Belegung der
Bank-Register mitzuteilen, wurde bereits in Zusammenhang mit dem<TT>
ASSUME</TT>-Befehl erw&auml;hnt. AS &uuml;berpr&uuml;ft bei jedem
absoluten Zugriff anhand dieser Annahmen, ob evtl. ein Zugriff auf
eine Speicherstelle erfolgt, die momentan &uuml;berhaupt nicht
greifbar ist. Standardm&auml;&szlig;ig sind daf&uuml;r nat&uuml;rlich
nur DTB und DPR wichtig, denn ADB bzw. SSB/USB werden nur bei
indirekten Zugriffen &uuml;ber RW2/RW6 bzw. RW3/RW7 benutzt, und bei
indirekten Zugriffen greift diese Pr&uuml;fmimik ohnehin nicht. Nun
ist es aber so, da&szlig; man - &auml;hnlich wie beim 8086 - einem
Befehl eine Segmentpr&auml;fix voranstellen kann, mit dem DTB
f&uuml;r den folgenden Befehl durch ein beliebiges anderes Register
ersetzt werden kann. AS f&uuml;hrt deswegen &uuml;ber die verwendeten
Pr&auml;fixbefehle Buch und schaltet bei der Pr&uuml;fung f&uuml;r
den n&auml;chsten<EM> Prozessorbefehl</EM> um - eine zwischen dem
Segmentpr&auml;fix und Prozessorbefehl eingestreute Pseudoanweisung
l&ouml;scht den Merker also<EM> nicht</EM>. Dies gilt auch f&uuml;r
Pseudobefehle zur Datenablage oder Ver&auml;nderung des
Programmz&auml;hlers - aber wer macht so etwas schon ;-)
<P>

<H1><A NAME="sect_5_">5. Dateiformate</A></H1>
<P>
In diesem Kapitel sollen die Formate von von AS erzeugten Dateien
beschrieben werden, deren Format sich nicht direkt erschlie&szlig;t.
<P>

<H2><A NAME="sect_5_1_">5.1. Code-Dateien</A></H2>
<A NAME="ref_SectCodeFormat"></A>
<P>
Das vom Assembler ausgegebene Codedatenformat mu&szlig; in der Lage
sein, die Codeteile f&uuml;r unterschiedliche Prozessoren voneinander
zu trennen, und sieht daher etwas anders aus als g&auml;ngige
Formate. Obwohl dem Assembler Tools zur Bearbeitung der Codedateien
beiliegen, halte ich es f&uuml;r guten Stil, das Format hier kurz
offenzulegen:
<P>
Sofern in der Datei Mehrbyte-Integers gespeichert sind, werden sie im
Intelformat abgelegt, d.h. mit dem LSB zuerst. Diese Regel gilt
bereits f&uuml;r das 16-Bit-Kennungswort mit dem Wert $1489, d.h.
jede Codedatei beginnt mit den Bytes $89/$14.
<P>
Danach folgt eine Reihe beliebig vieler ,,Records'', wobei ein Record
entweder ein zusammenh&auml;ngendes Teilfeld des Codes darstellt oder
bestimmte Zusatzinformationen enth&auml;lt. Eine Datei kann auch ohne
Umschaltung des Prozessortyps mehrere Records enthalten, wenn Code-
oder Konstantenbereiche durch reservierte (und nicht zu
initialisierende) Speicherbereiche unterbrochen werden. Der Assembler
versucht auf diese Weise, die Datei nicht l&auml;nger als n&ouml;tig
werden zu lassen.
<P>
Allen Records ist gemein ist ein Header-Byte, das den Typ des Records
und die damit folgenden Datenstrukturen festlegt. In einer
Pascal-artigen Form l&auml;&szlig;t sich die Record-Struktur
folgenderma&szlig;en beschreiben:
<PRE>

FileRecord = RECORD CASE Header:Byte OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
              $80:(EntryPoint:LongInt);
              $81:(Header   : Byte;
                   Segment  : Byte;
                   Gran     : Byte;
                   StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
             END

</PRE>
Was in dieser Schreibweise nicht ganz zum Ausdruck kommt, ist,
da&szlig; die L&auml;nge von Datenfeldern variabel ist und von<TT>
Length</TT> abh&auml;ngt.
<P>
Ein Record mit einem Header-Byte von $81 ist ein Record, der Code
oder Daten aus beliebigen Segmenten beinhalten kann. Das erste Byte
(Header) gibt an, f&uuml;r welche Prozessorfamilie die folgenden
Daten bzw. der folgende Code bestimmt ist (siehe Tabellen <A
HREF="#ref_TabHeader">5.1</A> und <A HREF="#ref_TabHeader2">5.2</A>).
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Header</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Header</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$01<BR>
$04<BR>
$09<BR>
$12<BR>
$14<BR>
$16<BR>
$21<BR>
$29<BR>
$31<BR>
$33<BR>
$38<BR>
$3a<BR>
$3c<BR>
$41<BR>
$47<BR>
$49<BR>
$4b<BR>
$51<BR>
$53<BR>
$55<BR>
$59<BR>
$5c<BR>
$5f<BR>
$61<BR>
$63<BR>
$65<BR>
$67<BR>
$69<BR>
$6b<BR>
$6d<BR>
$6f<BR>
$71<BR>
$73<BR>
$75</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>680x0, 6833x<BR>
XGATE<BR>
DSP56xxx<BR>
MELPS-4500<BR>
M16C<BR>
F<SUP>2</SUP>MC16L<BR>
MCS-48<BR>
29xxx<BR>
MCS-51<BR>
ST7<BR>
1802/1805<BR>
8X30x<BR>
XA<BR>
8080/8085<BR>
TMS320C6x<BR>
TMS370xxx<BR>
TMS320C54x<BR>
Z80/180/380<BR>
TLCS-90<BR>
TLCS-47<BR>
eZ8<BR>
LatticeMico8<BR>
COP4<BR>
6800, 6301, 6811<BR>
6809<BR>
68HC16<BR>
ACE<BR>
H8/500<BR>
KCPSM<BR>
SC14xxx<BR>
COP8<BR>
PIC16C5x<BR>
TMS-7000<BR>
TMS320C2x</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$03<BR>
$05<BR>
$11<BR>
$13<BR>
$15<BR>
$19<BR>
$25<BR>
$2a<BR>
$32<BR>
$37<BR>
$39<BR>
$3b<BR>
$3f<BR>
$42<BR>
$48<BR>
$4a<BR>
$4c<BR>
$52<BR>
$54<BR>
$56<BR>
$5b<BR>
$5e<BR>
$60<BR>
$62<BR>
$64<BR>
$66<BR>
$68<BR>
$6a<BR>
$6c<BR>
$6e<BR>
$70<BR>
$72<BR>
$74<BR>
$76</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>M*Core<BR>
PowerPC<BR>
65xx/MELPS-740<BR>
M16<BR>
F<SUP>2</SUP>MC8L<BR>
65816/MELPS-7700<BR>
SYM53C8xx<BR>
i960<BR>
ST9<BR>
2650<BR>
MCS-96/196/296<BR>
AVR<BR>
4004/4040<BR>
8086..V35<BR>
TMS9900<BR>
MSP430<BR>
80C166/167<BR>
TLCS-900<BR>
TLCS-870<BR>
TLCS-9000<BR>
KCPSM3<BR>
68RS08<BR>
78K2<BR>
6805/HC08<BR>
6804<BR>
68HC12<BR>
H8/300(H)<BR>
807x<BR>
SH7000<BR>
SC/MP<BR>
PIC16C8x<BR>
PIC17C4x<BR>
TMS3201x<BR>
TMS320C3x</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 5.1: Headerbytes f&uuml;r die verschiedenen
             Prozessorfamilien<A NAME="ref_TabHeader"></A>
</CENTER><P>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Header</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Header</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Familie</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$77<BR>
$79<BR>
$7b<BR>
$7d<BR>
$7f</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>TMS320C20x/TMS320C5x<BR>
Z8<BR>
75K0<BR>
&micro;PD7720<BR>
&micro;PD77230</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$78<BR>
$7a<BR>
$7c<BR>
$7e<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>ST6<BR>
&micro;PD78(C)10<BR>
78K0<BR>
&micro;PD7725<BR>
</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 5.2: Headerbytes f&uuml;r die verschiedenen
             Prozessorfamilien<A NAME="ref_TabHeader2"></A>
</CENTER><P>

<P>
Das Segment-Feld gibt an, in welchen Adre&szlig;raum des Prozessors
der folgende Code geh&ouml;rt. Dabei gilt die in Tabelle <A
HREF="#ref_TabSegments">5.3</A> angegeben Zuordnung.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Nummer</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TH>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Nummer</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Segment</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$00<BR>
$02<BR>
$04<BR>
$06<BR>
$08</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&lt;undefiniert&gt;<BR>
DATA<BR>
XDATA<BR>
BDATA<BR>
REG</TD>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>$01<BR>
$03<BR>
$05<BR>
$07<BR>
$09</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>CODE<BR>
IDATA<BR>
YDATA<BR>
IO<BR>
ROMDATA</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 5.3: Kodierungen des<TT> Segment</TT>-Feldes<A
             NAME="ref_TabSegments"></A><A
             NAME="ref_TabSegmentNums"></A>
</CENTER><P>

Das Gran-Feld gibt die ,,Granularit&auml;t'' des Codes an, d.h. die
Gr&ouml;&szlig;e der kleinsten, adressierbaren Einheit im folgenden
Datensatz. Dieser Wert ist eine Funktion von Prozessortyp und Segment
und ein wichtiges Detail f&uuml;r die Interpretation der beiden
folgenden Felder, die Startadresse und L&auml;nge angeben:
W&auml;hrend die Startadresse sich auf die Granularit&auml;t bezieht,
erfolgt die L&auml;ngenangabe immer in Bytes! W&auml;re die
Startadresse z.B. $300 und die L&auml;nge 12, so w&auml;re die sich
ergebende Endadresse bei einer Granularit&auml;t von 1 $30b, bei
einer Granularit&auml;t von z.B. 4 jedoch $303! Andere
Granularit&auml;ten als eins sind selten und treten in erster Linie
bei Signalprozessoren auf, die nicht auf Einzelbyteverarbeitung
ausgelegt sind deren Datenspeicher z.B. aus 64kWorten zu 16 Bit
besteht (DSP56K). Der sich ergebende Speicherplatz betr&auml;gt dann
zwar 128 KByte, er ist aber in 2<SUP> 16</SUP> Worten organisiert,
die mit Adressen von 0,1,2,...65535 adressiert werden!
<P>
Die Startadresse ist 32-bittig, unabh&auml;ngig von der
Adre&szlig;breite der jeweiligen Prozessorfamilie. Im Gegensatz dazu
ist die L&auml;ngenangabe nur 16 Bit lang, ein Record kann also
maximal (4+4+2+(64K-1)) = 65545 Byte lang werden.
<P>
Daten-Records mit den Header-Bytes $01..$7f stellen eine
Kurzschreibweise dar und stellen die Abw&auml;rtskompatibilit&auml;t
mit fr&uuml;heren Definitionen des Dateiformats her: Das Header-Byte
gibt direkt den Prozessortyp gem&auml;&szlig; der ersten Tabelle an,
das Zielsegment ist auf<TT> CODE</TT> festgelegt und die
Granularit&auml;t ergibt sich aus dem Prozessortyp, aufgerundet auf
eine Zweierpotenz von Bytes. AS bevorzugt diese Records, wenn Daten
bzw. Code f&uuml;r das<TT> CODE</TT>-Segment anstehen.
<P>
Der Record mit dem Typ-Byte $80 legt den Einsprungpunkt fest, d.h.
die Adresse, an der mit der Ausf&uuml;hrung des Programmes begonnen
werden soll. Ein solcher Record ist das Ergebnis einer<TT>
END</TT>-Anweisung mit einer entsprechenden Adresse als Argument.
<P>
Der letzte Record in der Datei tr&auml;gt das Header-Byte $00 und
besitzt als einziges Datenfeld einen String, dessen Ende durch das
Dateiende definiert ist. Dieser String spezifiziert, von welchem
Programm diese Datei erzeugt wurde und hat keine weitere Bedeutung.
<P>

<H2><A NAME="sect_5_2_">5.2. Debug-Dateien</A></H2>
<A NAME="ref_SectDebugFormat"></A>
<P>
Debug-Dateien k&ouml;nnen optional von AS erzeugt werden und liefern
nachgeschalteten Werkzeugen wie Disassemblern oder Debuggern f&uuml;r
diese wichtige Informationen. AS kann Debug-Informationen in drei
Formaten ausgeben: Zum einen im Objekt-Format der AVR-Tools von Atmel
sowie eine zu NoICE kompatible Kommandodatei und zum anderen in einem
eigenen Format. Die ersten beiden werden in <A
HREF="#cite_AVRObj">[4]</A> bzw. der Dokumentation zu NoICE
ausf&uuml;hrlich beschrieben, deshalb beschr&auml;nkt sich die
folgende Beschreibung auf das AS-eigene MAP-Format:
<P>
Diese Informationen in einer MAP-Datei teilen sich in drei Gruppen:
<UL>
<LI> Symboltabelle</LI>
<LI> Speicherberlegung, auf Sektionen verteilt</LI>
<LI> Maschinenadressen von Quellzeilen</LI>
</UL>
Letzterer Teil findet sich zuerst in der Datei. Ein einzelner Eintrag
in dieser Liste besteht aus zwei, von einem Doppelpunkt getrennten
Zahlen:
<PRE>

 &lt;Zeilennummer&gt;:&lt;Adresse&gt;

</PRE>
Ein solcher Eintrag besagt, da&szlig; der aus einer bestimmten
Quellcodezeile erzeugte Maschinencode auf der angegebenen Adresse
(hexadezimal) zu liegen kam. Mit einer solchen Information kann ein
Debugger beim Durchsteppen des Programmes die entsprechenden
Quellcodezeilen anzeigen. Da ein Programm aber auch aus mehreren
Include-Dateien bestehen kann, und viele Prozessoren mehr als nur
einen Adre&szlig;raum besitzen (von dem zugegebenerma&szlig;en nur in
einem Code liegt), m&uuml;ssen die oben beschriebenen Eintr&auml;ge
sortiert werden. AS tut dies in zwei Stufen: Das prim&auml;re
Sortierkriterium ist das Zielsegment, innerhalb dieser Segmente wird
noch einmal nach Dateien sortiert. Einzelne Abschnitte werden dabei
durch durch spezielle Zeilen der Form
<PRE>

Segment &lt;Segmentname&gt;

</PRE>
bzw.
<PRE>

File &lt;Dateiname&gt;

</PRE>
getrennt.
<P>
Die Symboltabelle folgt der Quellzeileninformation und ist wieder
prim&auml;r nach den Segmenten geordnet, aus denen die Symbole
stammen. Im Gegensatz zur Zeileninformation kommt hier allerdings
auch der Abschnitt<TT> NOTHING</TT> hinzu, der die Symbole
beinhaltet, die keinem speziellen Adre&szlig;raum zugeordnet sind
(z.B. Symbole, die einfach mit<TT> EQU</TT> definiert wurden). Die
Einleitung eines Abschnittes in der Symboltabelle erfolgt mit einer
Zeile der Form
<PRE>

Symbols in Segment &lt;Segmentname&gt;   .

</PRE>
Innerhalb eines Abschnittes sind die Symbole nach Namen sortiert, und
ein Symboleintrag belegt genau eine Zeile. Eine solche Zeile besteht
wiederum aus 5 Feldern, die durch jeweils mindestens ein Leerzeichen
getrennt sind:
<P>
Das erste Feld ist der Name des Symbols selber, eventuell erweitert
um eine in eckigen Klammern eingeschlossene Sektionsnummer, die den
G&uuml;ltigkeitsbereich des Symbols einschr&auml;nkt. Die zweite
Spalte bezeichnet den Typ des Symbols:<TT> Int</TT> f&uuml;r
Integerzahlen,<TT> Float</TT> f&uuml;r Gleitkommazahlen und<TT>
String</TT> f&uuml;r Zeichenketten. Die dritte Zeile
schlie&szlig;lich beinhaltet den eigentliche Wert des Symbols. Falls
das Symbol eine Zeichenkette beinhaltet, ist es notwendig, Steuer-
und Leerzeichen mit einer gesonderten Notation zu kennzeichnen, damit
ein im String enthaltenes Leerzeichen nicht eventuell als
Trennzeichen zur n&auml;chsten Spalte interpretiert werden kann. AS
bedient sich dazu der bereits der in Assemblerquellen &uuml;blichen
Schreibweise, den ASCII-Zahlenwert mit einem f&uuml;hrenden Backslash
(\) einzusetzen. Aus dem String
<PRE>

 Dies ist ein Test

</PRE>
wird also z.B.
<PRE>

 Dies\032ist\032ein\032Test

</PRE>
Die Zahlenangabe ist immer dezimal und dreistellig, und der Backslash
selber wird ebenfalls in dieser Schreibweise kodiert.
<P>
Das vierte Feld gibt - falls vorhanden - die Gr&ouml;&szlig;e der
Datenstruktur an, die an der durch das Symbol gekennzeichneten
Adresse abgelegt ist. Ein Debugger kann eine solche Information z.B.
nutzen, um symbolisch angesprochene Variablen direkt in der korrekten
L&auml;nge aufzulisten. Hat AS keine Informationen &uuml;ber die
Symbolgr&ouml;&szlig;e, so steht in diesem Feld eine schlichte -1.
<P>
Das f&uuml;nfte und letzte Feld gibt schlu&szlig;endlich durch eine 0
oder 1 an, ob das Symbol w&auml;hrend der Assemblierung jemals
referenziert wurde. Ein Programm, da&szlig; die Symboltabelle liest,
kann auf diese Weise z.B. nicht benutzte Symbole automatisch
verwerfen, da sie beim folgenden Debugging oder der Disassemblierung
mit hoher Wahrscheinlichkeit auch nicht ben&ouml;tigt werden.
<P>
Der dritte Abschnitt in einer Debug-Datei beschreibt die im Programm
benutzten Sektionen n&auml;her. Eine solche Beschreibung ist
erforderlich, da Sektionen den G&uuml;ltigkeitsbereich von Symbolen
einschr&auml;nken k&ouml;nnen. Je nach momentanem Stand des
Programmz&auml;hlers kann z.B. ein symbolischer Debugger einzelne
Symboldefinitionen f&uuml;r eine R&uuml;ck&uuml;bersetzung nicht
nutzen oder mu&szlig; Priorit&auml;ten bei der Symbolnutzung
beachten. Die Definition einer Sektion beginnt mit einer Zeile der
Form
<PRE>

Info for Section nn ssss pp     ,

</PRE>
wobei<TT> nn</TT> die Nummer der Sektion angibt (die Nummer, die als
Postfix f&uuml;r Symbolnamen in der Symboltabelle genutzt wird),<TT>
ssss</TT> der Name der Sektion ist und<TT> pp</TT> die Nummer der
Vatersektion darstellt. Letztere Information ben&ouml;tigt ein
R&uuml;ck&uuml;bersetzer, um sich bei der Auffindung eines Symbols
f&uuml;r einen Zahlenwert ausgehend von der aktuellen Sektion im Baum
bis zur Wurzel ,,durchhangeln'' kann, bis ein passendes Symbol
gefunden wird. Auf diese Zeile folgt eine Reihe weiterer Zeilen, die
den von dieser Sektion belegten Code-Bereich beschreiben. Jeder
einzelne Eintrag (genau einer pro Zeile) beschreibt entweder eine
einzelne Adresse oder einen durch zwei Grenzwerte beschriebenen
Bereich (Trennung von Anfangs-und Endwert durch ein Minuszeichen).
Die Grenzen sind dabei ,,inklusive'', d.h. die Grenzen geh&ouml;ren
auch zu dem Bereich. Wichtig ist, da&szlig; ein einer Sektion
zugeh&ouml;riger Bereich nicht nochmals f&uuml;r ihre Vatersektionen
aufgef&uuml;hrt wird (eine Ausnahme ist nat&uuml;rlich, wenn Bereiche
absichtlich mehrfach belegt werden, aber so etwas macht man ja auch
nicht, gelle?). Dies dient einer Optimierung der Bereichsspeicherung
w&auml;hrend der Assemblierung und sollte auch f&uuml;r eine
Symbolr&uuml;ck&uuml;bersetzung keine Probleme darstellen, da durch
die einfache Kennzeichnung bereits der Einstiegspunkt und damit der
Suchpfad im Sektionsbaum gegeben ist. Die Beschreibung einer Sektion
wird durch eine Leerzeile oder das Dateiende gekennzeichnet.
<P>
Programmteile, die au&szlig;erhalb aller Sektionen liegen, werden
nicht gesondert ausgewiesen. Diese ,,implizite Wurzelsektion''
tr&auml;gt die Nummer -1 und wird auch als Vatersektion f&uuml;r
Sektionen benutzt, die keine eigentliche Vatersektion besitzen.
<P>
Es ist m&ouml;glich, da&szlig; die Datei Leerzeilen oder
Kommentarzeilen (Semikolon am Zeilenanfang) beinhaltet. Diese sind
von einem Leseprogramm zu ignorieren.
<P>

<H1><A NAME="sect_6_">6. Hilfsprogramme</A></H1>
<A NAME="ref_ChapTools"></A>
<P>
Um die Arbeit mit dem Codeformat des Assemblers etwas zu erleichtern,
lege ich einige Progamme zu deren Bearbeitung bei. F&uuml;r diese
Programme gilt sinngem&auml;&szlig; das gleiche wie in <A
HREF="#ref_SectLicense">1.1</A>! Allen Programmen gemeinsam sind die
Returncodes, die sie liefern (Tabelle <A
HREF="#ref_TabToolReturns">6.1</A>).
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=CENTER>Returncode</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>tritt auf bei...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=CENTER>0<BR>
1<BR>
2<BR>
3</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>kein Fehler<BR>
Kommandozeilenparameterfehler<BR>
I/O-Fehler<BR>
Dateiformatfehler</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle 6.1: Returncodes der Dienstprogramme<A
             NAME="ref_TabToolReturns"></A>
</CENTER><P>

Ebenso eintr&auml;chtig wie AS lesen sie ihre Eingaben von STDIN und
schreiben Meldungen auf STDOUT (bzw. Fehlermeldungen auf STDERR).
Ein-und Ausgaben sollten sich daher problemlos umleiten lassen.
<P>
Sofern Programme im folgenden Zahlen-oder Adre&szlig;angaben von der
Kommandozeile lesen, d&uuml;rfen diese auch hexadezimal geschrieben
werden, indem man sie mit einem voranstehenden Dollarzeichen oder<TT>
0x</TT> wie in C versieht (z.B. $10 oder 0x10 anstelle von 16).
<P>
Unix-Shells ordnen dem Dollarzeichen allerdings eine spezielle           
Bedeutung zu (Parameterexpansion), weshalb es n&ouml;tig ist, einem
Dollarzeichen direkt einen Backslash voranzustellen. Die<TT>
0x</TT>-Variante ist hier sicherlich angenehmer.
<P>
Ansonsten folgen die Aufrufkonventionen und -variationen (bis auf
PLIST und AS2MSG) denen von AS, d.h. man kann dauernd gebrauchte
Schalter in einer Environmentvariablen ablegen (deren Name sich aus
dem Anh&auml;ngen von CMD an den Programmnamen ergibt, z.B. BINDCMD
f&uuml;r BIND), Optionen negieren und Gro&szlig;-bzw. Kleinschreibung
erzwingen (n&auml;heres zu dem Wie in Abschnitt <A
HREF="#ref_SectCallConvention">2.4</A>).
<P>
Sofern Adre&szlig;angaben benutzt werden, beziehen sie sich immer auf
die Granularit&auml;t des Adre&szlig;raumes des jeweiligen
Prozessors; beim PIC bedeutet z.B. eine Adre&szlig;differenz von 1
nicht ein Byte, sondern ein Wort.
<P>

<H2><A NAME="sect_6_1_">6.1. PLIST</A></H2>
<P>
PLIST ist das einfachste Programm der vier mitgelieferten; es dient
einfach nur dazu, die in einer Codedatei gespeicherten Records
aufzulisten. Da das Programm nicht allzuviel bewirkt, ist der Aufruf
ziemlich simpel:
<PRE>

    PLIST $&lt;$Dateiname$&gt;$

</PRE>
Der Dateiname wird automatisch um die Endung P erweitert, falls keine
Endung vorhanden ist.
<P>
<B> ACHTUNG!</B> An dieser Stelle sind keine Jokerzeichen erlaubt!
Falls mit einem Befehl trotzdem mehrere Programmdateien gelistet
werden sollen, kann man sich mit folgendem ''Minibatch'' behelfen:
<PRE>

    for %n in (*.p) do plist %n

</PRE>
PLIST gibt den Inhalt der Codedatei in Tabellenform aus, wobei
f&uuml;r jeden Record genau eine Zeile ausgegeben wird. Die Spalten
haben dabei folgende Bedeutung:
<UL>
<LI> Codetyp: die Prozessorfamilie, f&uuml;r die der Code erzeugt
    wurde.</LI>
<LI> Startadresse: absolute Speicheradresse, an die der Code zu laden
    ist.</LI>
<LI> L&auml;nge: L&auml;nge des Codest&uuml;cks in Byte.</LI>
<LI> Endadresse: letzte absolute Adresse des Codest&uuml;cks. Diese
    berechnet sich als Startadresse+L&auml;nge-1.</LI>
</UL>
Alle Angaben sind als hexadezimal zu verstehen.
<P>
Zuletzt gibt PLIST noch einen Copyrightvermerk aus, sofern er einen
solchen in der Datei findet, und die Summe aller Codel&auml;ngen.
<P>
PLIST ist praktisch ein DIR f&uuml;r Codedateien. Man kann es
benutzen, um sich den Inhalt einer Datei auflisten zu lassen, bevor
man sie weiterbearbeitet.
<P>

<H2><A NAME="sect_6_2_">6.2. BIND</A></H2>
<P>
BIND ist ein Programm, mit dem man die Records mehrerer Codedateien
in eine Datei zusammenkopieren kann. Die dabei vorhandene
Filterfunktion erlaubt es aber auch, nur Records eines bestimmten
Typs zu &uuml;bernehmen. Auf diese Weise kann BIND auch dazu
verwendet werden, um eine Codedatei in mehrere aufzuspalten.
<P>
Die allgemeine Syntax von BIND lautet
<PRE>

   BIND &lt;Quelldatei(en)&gt; &lt;Zieldatei&gt; [Optionen]

</PRE>
Wie auch AS betrachtet BIND alle nicht mit einem +, - oder /
eingeleiteten Parameter als Dateiangaben, von denen die letzte die
Zieldatei angeben mu&szlig;. Alle anderen Dateiangaben bezeichnen
Quellen, diese Angaben d&uuml;rfen auch wieder Jokerzeichen
enthalten.
<P>
An Optionen definiert BIND momentan nur eine:
<UL>
<LI> <TT>f &lt;Header[,Header...]&gt;</TT>: gibt eine Liste von
    Header-IDs an, die kopiert werden sollen. Alle anderen Records
    werden nicht kopiert. Ohne diese Angabe werden alle Records
    kopiert. Die in der Liste angegebenen entsprechen dem Header-Feld
    in der Recordstruktur, wie es in Abschnitt <A
    HREF="#ref_SectCodeFormat">5.1</A> beschrieben wurden. Die
    einzelnen Header-Nummern in der Liste werden durch Kommas
    getrennt.</LI>
</UL>
Um z.B. alle MCS-51-Codeteile aus einer Programmdatei auszusieben,
benutzt man BIND folgenderma&szlig;en:
<PRE>

   BIND &lt;Quellname&gt; &lt;Zielname&gt; -f $31

</PRE>
Fehlt bei einer Dateiangabe eine Endung, so wird automatisch die
Endung P angef&uuml;gt.
<P>

<H2><A NAME="sect_6_3_">6.3. P2HEX</A></H2>
<P>
P2HEX ist eine Erweiterung von BIND. Es besitzt alle
Kommandozeilenoptionen von BIND und hat die gleichen Konventionen
bzgl. Dateinamen. Im Gegensatz zu BIND wird die Zieldatei aber als
Hexfile ausgegeben, d.h. als eine Folge von Zeilen, die den Code als
ASCII-Hexzahlen enthalten.
<P>
P2HEX kennt 8 verschiedene Zielformate, die &uuml;ber den
Kommandozeilenparameter<B> F</B> ausgew&auml;hlt werden k&ouml;nnen:
<UL>
<LI> Motorola S-Record (<TT>-F Moto</TT>)</LI>
<LI> MOS Hex (<TT>-F MOS</TT>)</LI>
<LI> Intel-Hex (Intellec-8,<TT> -F Intel</TT>)</LI>
<LI> 16-Bit Intel-Hex (MCS-86,<TT> -F Intel16</TT>)</LI>
<LI> 32-Bit Intel-Hex (<TT>-F Intel32</TT>)</LI>
<LI> Tektronix Hex (<TT>-F Tek</TT>)</LI>
<LI> Texas Instruments DSK (<TT>-F DSK</TT>)</LI>
<LI> Atmel AVR Generic (-F Atmel, siehe <A
    HREF="#cite_AVRObj">[4]</A>)</LI>
</UL>
Wird kein Zielformat explizit angegeben, so w&auml;hlt P2HEX anhand
des Prozessortyps automatisch eines aus, und zwar S-Records f&uuml;r
Motorola- Prozessoren, Hitachi und TLCS-900(0), MOS f&uuml;r
65xx/MELPS, DSK f&uuml;r die 16-Bit-Texas-Signalprozessoren, Atmel
Generic f&uuml;r die AVRs und Intel-Hex f&uuml;r den Rest. Je nach
Breite der Startadresse kommen bei S-Record Records der Typen 1,2
oder 3 zum Einsatz, jedoch nie in einer Gruppe gemischt. Diese
Automatik l&auml;&szlig;t sich mit der Kommandozeilenoption
<PRE>

  -M &lt;1|2|3&gt;

</PRE>
teilweise unterdr&uuml;cken: Ein Wert von 2 bzw. 3 sorgt daf&uuml;r,
da&szlig; S-Records mit einem Mindesttyp von 2 bzw. 3 benutzt werden,
w&auml;hrend ein Wert von 0 der vollen Automatik entspricht.
<P>
Normalerweise benutzt das AVR-Format immer eine Adre&szlig;l&auml;nge
von 3 Bytes. Manche Programme m&ouml;gen das leider nicht...deshalb
kann man mit dem Schalter
<PRE>

  -avrlen &lt;2|3&gt;

</PRE>
die L&auml;nge zur Not auf 2 Bytes reduzieren.
<P>
Die Intel-, Tektronix- und MOS-Formate sind auf 16 Bit-Adressen
beschr&auml;nkt, das 16-Bit Intel-Format reicht 4 Bit weiter.
L&auml;ngere Adressen werden von P2HEX mit einer Warnung gemeldet und
abgeschnitten(!). F&uuml;r die PICs k&ouml;nnen die drei von
Microchip spezifizierten Varianten des Intel-Hex-Formates erzeugt
werden, und zwar mit dem Schalter
<PRE>

  -m &lt;0..3&gt;

</PRE>
Das Format 0 ist INHX8M, in dem alle Bytes in Lo-Hi-Ordnung enthalten
sind. Die Adre&szlig;angaben verdoppeln sich, weil bei den PICs die
Adresse sich nur um 1 pro Wort erh&ouml;ht. Dieses Format ist
gleichzeitig die Vorgabe. Im Format 1 (INHX16M) werden alle Worte in
ihrer nat&uuml;rlichen Ordnung abgelegt. Dieses Format verwendet
Microchip f&uuml;r seine eigenen Programierger&auml;te. Format 2
(INHX8L) und 3 (INHX8H) trennen die Worte in ihre oberen und unteren
Bytes auf. Um die komplette Information zu erhalten, mu&szlig; P2HEX
zweimal aufgerufen werden, z.B. so:
<PRE>

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

</PRE>
F&uuml;r das Motorola-Format verwendet P2HEX zus&auml;tzlich einen in
<A HREF="#cite_CPM68K">[8]</A> genannten Recordtyp mit der Nummer 5,
der die Zahl der folgenden Daten-Records (S1/S2/S3) bezeichnet. Da
dieser Typ vielleicht nicht jedem Programm bekannt ist, kann man ihn
mit der Option
<PRE>

 +5

</PRE>
unterdr&uuml;cken.
<P>
Finden sich Code-Records verschiedener Prozessoren in einer
Quelldatei, so erscheinen die verschiedenen Hexformate auch gemischt
in der Zieldatei --- es empfiehlt sich also dringend, von der
Filterfunktion Gebrauch zu machen.
<P>
Neben dem Codetypenfilter kennt P2HEX noch ein Adre&szlig;filter, das
n&uuml;tzlich ist, falls der Code auf mehrere EPROMs verteilt werden
mu&szlig;:
<PRE>

  -r &lt;Startadresse&gt;-&lt;Endadresse&gt;

</PRE>
Die Startadresse ist dabei die erste Speicherzelle, die im Fenster
liegen soll, die Endadresse die der letzten Speicherzelle im
Fenster,<I> nicht</I> die der ersten au&szlig;erhalb. Um z.B. ein
8051-Programm in 4 2764-EPROMs aufzuteilen, geht man
folgenderma&szlig;en vor:
<PRE>

p2hex &lt;Quelldatei&gt; eprom1 -f $31 -r $0000-$1fff
p2hex &lt;Quelldatei&gt; eprom2 -f $31 -r $2000-$3fff
p2hex &lt;Quelldatei&gt; eprom3 -f $31 -r $4000-$5fff
p2hex &lt;Quelldatei&gt; eprom4 -f $31 -r $6000-$7fff

</PRE>
Defaultm&auml;&szlig;ig ist das Fenster 32 KByte gro&szlig; und
beginnt bei Adresse 0.
<P>
<B> ACHTUNG!</B> Die Splittung &auml;ndert nichts an den absoluten
Adressen, die in den Hexfiles stehen! Sollen die Adressen im Hexfile
bei 0 beginnen, so kann man dies durch den zus&auml;tzlichen Schalter
<PRE>

 -a

</PRE>
erreichen. Um im Gegenteil die Adre&szlig;lage auf einen bestimmten
Wert zu verschieben, kann man den Schalter
<PRE>

 -R &lt;Wert&gt;

</PRE>
verwenden. Der dabei angegebene Wert ist ein<EM> Offset</EM>, d.h. er
wird auf die in der Code-Datei angegebenen Adressen aufaddiert.
<P>
Als Sonderwerte f&uuml;r Start-und Endadresse beim r-Parameter ist
ein schlichtes Dollar-Zeichen ($) erlaubt. Diese kennzeichnet die
erste bzw. letzte in der Programmdatei belegte Adresse. Wer also
sicher sein will, da&szlig; immer das ganze Programm in der Hex-Datei
abgelegt wird, braucht sich mit dem Schalter
<PRE>

 -r $-$

</PRE>
keine Gedanken mehr zu machen. Dollarzeichen und feste Adressen
lassen sich selbstverst&auml;ndlich auch gemischt verwenden, z.B.
kann mit
<PRE>

 -r $-$7fff

</PRE>
das obere Ende auf die ersten 32K begrenzt werden.
<P>
Den Inhalt einer Datei kann man mit einem Offset auf eine beliebige
Position verschieben; diesen Offset h&auml;ngt man einfach in
Klammern an den Dateinamen an. Ist der Code in einer Datei z.B. auf
Adresse 0 in der P-Datei abgelegt, man m&ouml;chte ihn jedoch auf
Adresse 1000h verschieben, so h&auml;ngt man an<TT> ($1000)</TT> an
den Dateinamen (ohne Leerzeichen!) an.
<P>
Da das TI-DSK-Format Daten und Code unterscheiden kann,
l&auml;&szlig;t sich mit dem Schalter
<PRE>

 -d &lt;Start&gt;-&lt;Ende&gt;

</PRE>
festlegen, welche Adre&szlig;bereiche als Daten ausgegeben werden
sollen. Dollarzeichen sind hier<B> nicht</B> zugelassen. Diese Option
sollte nicht mehr in neuen Projekten verwendet werden, da P2HEX
inzwischen direkt Daten aus dem Datensegment korrekt umsetzen kann.
<P>
F&uuml;r das DSK- sowie Intel- und Motorola-Format relevant ist
dagegen die Option
<PRE>

 -e &lt;Adresse&gt; ,

</PRE>
mit der man die in die Hex-Datei einzutragende Startadresse festlegen
kann. Fehlt diese Angabe, so wird nach einen entsprechenden Eintrag
in der Code-Datei gesucht. Ist auch dort kein Hinweis auf einen
Einsprungpunkt zu finden, so wird kein Eintrag in die HEX-Datei
geschrieben (DSK/Intel) bzw. das entsprechende Feld wird auf 0
gesetzt (Motorola).
<P>
Leider ist sich die Literatur nicht ganz &uuml;ber die Endezeile
f&uuml;r Intel-Hexfiles einig. P2HEX kennt daher 3 Varianten,
einstellbar &uuml;ber den Parameter<B> i</B> mit einer nachfolgenden
Ziffer:
<DL COMPACT>
<DT>0<DD>:00000001FF</DD>
<DT>1<DD>:00000001</DD>
<DT>2<DD>:0000000000</DD>
</DL>
<P>
Defaultm&auml;&szlig;ig wird die Variante 0 benutzt, die die
gebr&auml;uchlichste zu sein scheint.
<P>
Fehlt der Zieldateiangabe eine Endung, so wird<TT> HEX</TT> als
Endung angenommen.
<P>
Defaultm&auml;&szlig;ig gibt P2HEX pro Zeile maximal 16 Datenbytes
aus, wie es auch die meisten anderen Tools tun, die Hex-Files
erzeugen. Wollen Sie dies &auml;ndern, so k&ouml;nnen Sie dies mit
dem Schalter
<PRE>

-l &lt;Anzahl&gt;

</PRE>
tun. Der erlaubte Wertebereich liegt dabei zwischen 2 und 254
Datenbytes; ungerade Werte werden implizit auf gerade Anzahlen
aufgerundet.
<P>
Meist werden die tempor&auml;ren, von AS erzeugten Code-Dateien nach
einer Umwandlung nicht mehr unbedingt gebraucht. Mit der
Kommandozeilen- option
<PRE>

-k

</PRE>
kann man P2HEX anweisen, diese automatisch nach der Konversion zu
l&ouml;schen.
<P>
Anders als BIND erzeugt P2HEX keine Leerdatei, wenn nur ein Dateiname
(=Zieldatei) angegeben wurde, sondern bearbeitet die
dazugeh&ouml;rige Codedatei. Es ist also ein Minimalaufruf &agrave;
la
<PRE>

 P2HEX &lt;Name&gt;

</PRE>
m&ouml;glich, um &lt;Name: &gt;.HEX aus &lt;Name: &gt;.P zu erzeugen.
<P>

<H2><A NAME="sect_6_4_">6.4. P2BIN</A></H2>
<P>
P2BIN funktioniert wie P2HEX und bietet die gleichen Optionen (bis
auf die a- und i- Optionen, die bei Bin&auml;rdateien keinen Sinn
ergeben), nur wird das Ergebnis nicht als Hexdatei, sondern als
einfache Bin&auml;rdatei abgelegt. Dies kann dann z.B. direkt in ein
EPROM gebrannt werden.
<P>
Zur Beeinflussung der Bin&auml;rdatei kennt P2BIN gegen&uuml;ber
P2HEX noch drei weitere Optionen:
<UL>
<LI> <TT>l &lt;8-Bit-Zahl&gt;</TT>: gibt den Wert an, mit dem unbenutzte
    Speicherstellen in der Datei gef&uuml;llt werden sollen.
    Defaultm&auml;&szlig;ig ist der Wert $ff, so da&szlig; ein
    halbwegs intelligenter EPROM-Brenner sie &uuml;berspringt. Man
    kann aber hiermit auch andere Werte einstellen, z.B. enthalten
    die gel&ouml;schten Speicherzellen der MCS-48-EPROM-Versionen
    Nullen. In einem solchen Falle w&auml;re 0 der richtige
    Wert.</LI>
<LI> <TT>s</TT>: weist das Programm an, eine Pr&uuml;fsumme &uuml;ber die
    Bin&auml;rdatei zu berechnen. Die Pr&uuml;fsumme wird einmal als
    32-Bit-Wert ausgegeben, zum anderen wird das Zweierkomplement der
    Bits 0..7 in der letzten Speicherstelle abgelegt, so da&szlig;
    die Modulo-256-Summe zu 0 wird.</LI>
<LI> <TT>m</TT>: f&uuml;r den Fall, da&szlig; ein Prozessor mit 16- oder
    32-Bit-Datenbus eingesetzt wird und die Bin&auml;rdatei f&uuml;r
    mehrere EPROMs aufgesplittet werden mu&szlig;. Das Argument kann
    folgende Werte annnehmen:
<UL>
<LI>     <TT>ALL</TT>: alles kopieren</LI>
<LI>     <TT>ODD</TT>: alle Bytes mit ungerader Adresse kopieren</LI>
<LI>     <TT>EVEN</TT>: alle Bytes mit gerader Adresse kopieren</LI>
<LI>     <TT>BYTE0</TT>..<TT>BYTE3</TT>: nur alle Bytes kopieren, deren
        Adresse die Form 4n+0...4n+3 hat.</LI>
<LI>     <TT>WORD0</TT>,<TT>WORD1</TT>: nur das untere bzw. obere
        16-Bit-Wort der 32-Bit-Worte kopieren.</LI>
</UL>
    </LI>
</UL>
<P>
Nicht wundern: Bei letzteren Optionen ist die Bin&auml;rdatei um den
Faktor 2 oder 4 kleiner als bei<TT> ALL</TT>. Dies ist bei konstantem
Adre&szlig;fenster logisch!
<P>
Falls die Code-Datei keine Startadresse enth&auml;lt, kann man diese
analog zu P2HEX &uuml;ber die<TT> -e</TT>-Kommandozeilenoption
vorgeben. Auf Anforderung teilt P2BIN ihren Wert der Ergebnisdatei
voran. Mit der Kommandozeilenoption
<PRE>

-S

</PRE>
wird diese Funktion aktiviert. Sie erwartet als Argument eine
Zahlenangabe zwischen 1 und 4, die die L&auml;nge des Adressfeldes in
Bytes bestimmt. Optional kann dieser Angabe auch noch der Buchstabe L
oder B vorangestellt werden, um die Byte-Order dieser Adresse
festzulegen. So erzeugt z.B. die Angabe<TT> B4</TT> eine
4-Byte-Adresse in Big-Endian-Anordnung,<TT> L2</TT> oder nur '2' eine
2-Byte-Adresse in Little-Endian-Anordnung.
<P>

<H2><A NAME="sect_6_5_">6.5. AS2MSG</A></H2>
<P>
Bei AS2MSG handelt es sich eigentlich um kein Hilfsprogramm, sondern
um ein Filter, das (gl&uuml;cklichen) Besitzern von Borland-Pascal
7.0 das Arbeiten mit dem Assembler erleichtern soll. In den
DOS-Arbeitsumgebungen existiert ein ,,Tools''-Men&uuml;, das man um
eigene Programme, z.B. AS erweitern kann. Das Filter erlaubt, die von
AS gelieferten Fehlermeldungen mit Zeilenangabe direkt im
Editorfenster anzuzeigen. Dazu mu&szlig; im Tools-Men&uuml; ein neuer
Eintrag angelegt werden (<TT>Options/Tools/New</TT>). Tragen Sie in
die einzelnen Felder folgende Werte ein :
<UL>
<LI> Title:<TT> ~M~akroassembler</TT></LI>
<LI> Program path:<TT> AS</TT></LI>
<LI> Command line:<TT> -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE
    ALL</TT></LI>
<LI> bei Bedarf einen Hotkey zuordnen (z.B. Shift-F7)</LI>
</UL>
Die Option<TT> -E</TT> sorgt daf&uuml;r, da&szlig; Turbo-Pascal nicht
mit STDOUT und STDERR durcheinander kommt.
<P>
Ich setze dabei voraus, da&szlig; sowohl AS als auch AS2MSG sich in
einem Verzeichnis befinden, welches in der Pfadliste aufgef&uuml;hrt
ist. Nach einem Druck auf dem passenden Hotkey (oder Auswahl aus dem
Tools-Men&uuml;) wird AS mit dem Namen der Textdatei im aktiven
Editorfenster aufgerufen. Die dabei aufgetretenen Fehler werden in
ein separates Fenster geleitet, durch das man nun ,,browsen'' kann.
Mit<B> Ctrl-Enter</B> springt man eine fehlerhafte Zeile an.
Zus&auml;tzlich enth&auml;lt das Fenster die Statistik, die AS am
Ende der Assemblierung ausgibt. Diese erhalten als Dummy-Zeilennummer
1.
<P>
F&uuml;r diese Arbeitsweise sind sowohl TURBO.EXE (Real Mode) als
auch BP.EXE (Protected Mode) geeignet. Ich empfehle BP, da in dieser
Variante beim Aufruf nicht erst der halbe DOS-Speicher
,,freigeswappt'' werden mu&szlig;.
<P>
<P>
<P>

<H1><A NAME="sect_A_">A. Fehlermeldungen von AS</A></H1>
<A NAME="ref_ChapErrMess"></A>
<P>
Im folgenden findet sich eine halb-tabellarische Auflistung der in AS
definierten Fehlermeldungen. Zu jeder Fehlermeldung finden sich
folgende Angaben:
<UL>
<LI> interne Fehlernummer (f&uuml;r den Anwender nur mit der<TT>
    n</TT>-Option sichtbar);</LI>
<LI> Fehlermeldung im Klartext;</LI>
<LI> Typ:
<UL>
<LI>     Warnung: zeigt m&ouml;gliche Fehler oder ineffizienten Code an.
        Assemblierung geht weiter.</LI>
<LI>     Fehler: echte Fehler. Assemblierung geht weiter, aber keine
        Code-Datei wird geschrieben.</LI>
<LI>     Fatal: schwerwiegende Fehler. Assemblierung wird
        abgebrochen.</LI>
</UL>
 </LI>
<LI> Ursache: die Situation(en), in denen der Fehler ausgegeben
    wird;</LI>
<LI> Argument: Die Ausgabe, die auf Wunsch als erweiterte Fehlermeldung
    erfolgt.</LI>
</UL>
<P>
<P>
<P>
<P>
<DL COMPACT>
<DT>0<DD>Displacement=0, &uuml;berfl&uuml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei 680x0-,6809- und COP8-Prozessoren: Das Displacement in
        einem Adre&szlig;ausdruck hat den Wert 0 ergeben. Es wird ein
        Adre&szlig;ausdruck ohne Displacement erzeugt. Um keine
        Phasenfehler zu erzeugen, werden NOP-Befehle
        eingef&uuml;gt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>10<DD>Kurzadressierung m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei 680x0-, 6502- und 68xx-Prozessoren k&ouml;nnen bestimmte
        Speicherbereiche mit kurzen Adressen erreicht werden. Um
        keine Phasefehler zu erzeugen, wird zwar der k&uuml;rzere
        Ausdruck erzeugt, der freie Platz wird aber mit NOPs
        aufgef&uuml;llt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>20<DD>kurzer Sprung m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Bei 680x0 und 8086-Prozessoren kann der Sprung sowohl mit
        langem als auch kurzem Displacement ausgef&uuml;hrt werden.
        Da kein kurzer Sprung angefordert wurde, wurde im ersten Pass
        Platz f&uuml;r den langen Sprung freigehalten. Es wird ein
        kurzer Sprung erzeugt, der freie Platz wird mit NOPs
        aufgef&uuml;llt, um Phasenfehler zu vermeiden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>30<DD>kein Sharefile angelegt, SHARED ignoriert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde eine<TT> SHARED</TT>-Anweisung gefunden, es wurde
        aber keine Kommandozeilenoption angegeben, um eine
        Shared-Datei zu erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>40<DD>FPU liest Wert evtl. nicht korrekt ein (&gt;=1E1000)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das BCD-Gleitkommaformat der 680x0-Koprozessoren erlaubt zwar
        vierstellige Exponenten, lt. Datenbuch k&ouml;nnen solche
        Werte aber nicht korrekt eingelesen werden. Der vierstellige
        Wert wird zwar erzeugt, eine Funktion ist aber nicht
        gew&auml;hleistet.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>50<DD>Privilegierte Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde eine Anweisung benutzt, die nur im Supervisor-Mode
        zul&auml;ssig ist, obwohl dieser nicht mittels<TT> SUPMODE
        ON</TT> vorher explizit angezeigt wurde.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>60<DD>Distanz 0 nicht bei Kurzsprung erlaubt (NOP erzeugt)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein kurzer Sprung mit der Distanz 0 ist bei 680x0- bzw.
        COP8-Prozessoren nicht erlaubt, da dieser Sonderwert f&uuml;r
        lange Spr&uuml;nge ben&ouml;tigt wird. Stattdessen wurde ein
        NOP-Befehl eingef&uuml;gt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>70<DD>Symbol aus falschem Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol ist aus einem
        Adre&szlig;raum, der nicht mit dem benutzten Befehl
        bearbeitet werden kann.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>75<DD>Segment nicht adressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol ist aus einem
        Adre&szlig;raum, der mit keinem der Segmentregister des 8086
        adressiert werden kann.</DD>
<DT>Argument:<DD>     <BR>
        Name des nicht adressierbaren Segments<BR>
         </DD>
</DL>
</DD>
<DT>80<DD>&Auml;nderung des Symbolwertes erzwingt zus&auml;tzlichen Pass
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbol hat einen anderen Wert zugewiesen bekommen als im
        vorhergehenden Pass. Diese Warnung wird nur ausgegeben, falls
        die<TT> r</TT>-Option angegeben wurde.</DD>
<DT>Argument:<DD>     <BR>
        Der Name des fraglichen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>90<DD>&Uuml;berlappende Speicherbelegung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Bei der Bildung der Belegungsliste wurde festgestellt,
        da&szlig; ein Speicherbereich im Codesegment mehrfach benutzt
        wurde. Ursache k&ouml;nnen un&uuml;berlegte<TT>
        ORG</TT>-Anweisungen sein.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>100<DD>keine CASE-Bedingung zugetroffen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        bei einem<TT> SWITCH</TT>..<TT>CASE</TT>-Konstrukt ohne<TT>
        ELSECASE</TT>-Zweig traf keiner der<TT> CASE</TT>-Zweige
        zu.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>110<DD>Seite m&ouml;glicherweise nicht adressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das in dem Operanden benutzte Symbol liegt nicht in der
        momentan mit<TT> ASSUME</TT> eingestellten Fenster
        (ST6,78(C)10).</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>120<DD>Registernummer mu&szlig; gerade sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Hardware erlaubt nur ein Registerpaar zu verketten,
        dessen Startadresse gerade ist (RR0, RR2..., nur Z8).</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>130<DD>veralteter Befehl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der verwendete Befehl ist zwar noch definiert, ist in seiner
        Funktion aber durch andere, neue Befehle ersetzbar und daher
        in zuk&uuml;nftigen Prozessorversionen eventuell nicht mehr
        vorhanden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>140<DD>Nicht vorhersagbare Ausf&uuml;hrung dieser Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendete Adressierungsart ist bei diesem Befehl zwar
        prinzipiell erlaubt, ein Register wird jedoch in einer Weise
        doppelt verwendet, da&szlig; je nach
        Aus&uuml;hrungsreihenfolge sich unterschiedliche Ergebnisse
        einstellen k&ouml;nnen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>150<DD>Lokaloperator au&szlig;erhalb einer Sektion &uuml;berfl&uuml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein vorangestellter Klammeraffe dient dazu, sich explizit auf
        zu der Sektion lokale Symbole zu beziehen. Wenn man sich
        au&szlig;erhalb einer Sektion befindet, gibt es keine lokalen
        Symbole, weshalb dieser Operator &uuml;berfl&uuml;ssig
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>160<DD>sinnlose Operation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Anweisung ergibt entweder &uuml;berhaupt keinen Sinn oder
        kann auf andere Weise schneller und k&uuml;rzer
        ausgef&uuml;hrt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>170<DD>unbekannter Symbolwert erzwingt zus&auml;tzlichen Pass
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        AS vermutet eine Vorw&auml;rtsreferenz eines Symbols, d.h.
        das Symbol wird benutzt, bevor es definiert wurde, und
        h&auml;lt einen weiteren Pass f&uuml;r unumg&auml;nglich.
        Diese Warnung wird nur ausgegeben, falls die<TT>
        r</TT>-Option angegeben wurde.</DD>
<DT>Argument:<DD>     <BR>
        Der Name des fraglichen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>180<DD>Adresse nicht ausgerichtet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Eine Adresse ist nicht ein mehrfaches der
        Operandengr&ouml;&szlig;e. Das Datenbuch verbietet zwar
        solche Zugriffe, im Instruktionswort ist aber Platz f&uuml;r
        diese Adresse, so da&szlig; AS es bei einer Warnung belassen
        hat.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>190<DD>I/O-Adresse darf nicht verwendet werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Der verwendete Adressierungsmodus oder die angesprochene
        Adresse sind zwar prinzipiell erlaubt, die Adresse liegt aber
        im Bereich der Peripherieregister, die in diesem Zusammenhang
        nicht verwendet werden d&uuml;rfen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>200<DD>m&ouml;gliche Pipeline-Effekte
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Register wird in einer Befehlsfolge so verwendet,
        da&szlig; die Befehlsausf&uuml;hrung m&ouml;glicherweise
        nicht in der hingeschriebenen Form ablaufen wird.
        &Uuml;blicherweise wird ein Register benutzt, bevor der neue
        Wert zur Verf&uuml;gung steht.</DD>
<DT>Argument:<DD>     <BR>
        das die Verklemmung verursachende Register<BR>
         </DD>
</DL>
</DD>
<DT>210<DD>mehrfache Adre&szlig;registerbenutzung in einer Anweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Adre&szlig;register wird in mehreren
        Adre&szlig;ausdr&uuml;cken eines Befehls benutzt. Sofern
        einer der beiden Ausdr&uuml;cke das Register modifiziert,
        sind die Ergebnisadressen nicht eindeutig festgelegt.</DD>
<DT>Argument:<DD>     <BR>
        das mehrfach verwendete Register<BR>
         </DD>
</DL>
</DD>
<DT>220<DD>Speicherstelle ist nicht bitadressierbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Mit einer<TT> SFRB</TT>-Anweisung wurde versucht, eine
        Speicherstelle als bitadressierbar zu deklarieren, die
        aufgrund der Architektur des 8051 nicht bitadressierbar
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>230<DD>Stack ist nicht leer
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Am Ende eines Durchlaufes ist ein vom Programm definierter
        Stack nicht leer.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Stacks sowie seine Resttiefe<BR>
         </DD>
</DL>
</DD>
<DT>240<DD>NUL-Zeichen in Strings, Ergebnis undefiniert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Eine String-Konstante enth&auml;lt ein NUL-Zeichen. Dies
        funktioniert zwar mit der Pascal-Version, in Hinblick auf die
        C-Version von AS ist dies aber ein Problem, da C Strings mit
        einem NUL-Zeichen terminiert, d.h. der String w&auml;re
        f&uuml;r C an dieser Stelle zu Ende...</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>250<DD>Befehl &uuml;berschreitet Seitengrenze
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Befehl steht zu Teilen auf verschiedenen Seiten. Da der
        Programmz&auml;hler des Prozessors aber nicht &uuml;ber
        Seitengrenzen hinweg inkrementiert wird, w&uuml;rde zur
        Laufzeit anstelle des Instruktionsbytes von der Folgeseite
        wieder das erste Byte der alten Seite geholt; das Programm
        w&uuml;rde fehlerhaft ablaufen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>260<DD>Bereichs&uuml;berschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein Zahlenwert lag au&szlig;erhalb des erlaubten Bereichs. AS
        hat den Wert durch ein Abschneiden der oberen Bitstellen in
        den erlaubten Bereich gebracht, es ist jedoch nicht
        garantiert, da&szlig; sich durch diese Operation sinnvoller
        und korrekter Code ergibt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>270<DD>negatives Argument f&uuml;r DUP
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Das Wiederholungsargument einer<TT> DUP</TT>-Direktive war
        kleiner als 0. Es werden (analog zu einem Argument von genau
        0) keine Daten abgelegt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>280<DD>einzelner X-Operand wird als indizierte und nicht als implizite
    Adressierung interpretiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Ein einzelner X-Operand kann sowohl als Register X als auch
        X-inidizierte Adressierung mit Null-Displacement
        interpretiert werden, da sich Morola hier nicht festlegt. AS
        w&auml;hlt die letztere Variante, was m&ouml;glicherweise
        nicht das erwartete ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
    </DD>
<DT>300<DD>Bit-Nummer wird abgeschnitten werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Warnung</DD>
<DT>Ursache:<DD>     <BR>
        Die Instruktion arbeitet nur auf Byte- bzw.
        Langwort-Operanden, Bitnummern jenseits 7 bzw. 31 werden von
        der CPU modulo-8 bzw. modulo-32 behandelt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1000<DD>Symbol doppelt definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Einem Symbol wurde durch ein Label oder<TT> EQU</TT>,<TT>
        PORT</TT>,<TT> SFR</TT>,<TT> LABEL</TT>,<TT> SFRB</TT>
        oder<TT> BIT</TT> ein neuer Wert zugewiesen, dies ist aber
        nur bei<TT> SET/EVAL</TT> erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        Name des fraglichen Symbols, bei eingeschalteter
        Querverweisliste zus&auml;tzlich die Zeile der ersten
        Definition<BR>
         </DD>
</DL>
</DD>
<DT>1010<DD>Symbol nicht definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein benutztes Symbol ist auch im 2.Pass noch nicht in der
        Symboltabelle enthalten.</DD>
<DT>Argument:<DD>     <BR>
        Name des nicht gefundenen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>1020<DD>Ung&uuml;ltiger Symbolname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbolname entspricht nicht den Bedingungen f&uuml;r
        einen g&uuml;ltigen Symbolnamen. Beachten Sie, da&szlig;
        f&uuml;r Makro-und Funktionsparameter strengere Regeln
        gelten!</DD>
<DT>Argument:<DD>     <BR>
        der fehlerhafte Symbolname<BR>
         </DD>
</DL>
</DD>
<DT>1090<DD>Ung&uuml;ltiges Format
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte Befehlsformat existiert bei diesem Befehl
        nicht.</DD>
<DT>Argument:<DD>     <BR>
        Der Kennbuchstabe des verwendeten Formates<BR>
         </DD>
</DL>
</DD>
<DT>1100<DD>&Uuml;berfl&uuml;ssiges Attribut
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl (Prozessor oder Pseudo) darf kein mit
        einem Punkt angeh&auml;ngtes Attribut haben.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1105<DD>Attribut darf nur 1 Zeichen lang sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das mit einem Punkt an einen Befehl angeh&auml;ngte Attribut
        mu&szlig; genau ein Zeichen lang sein; weder mehr noch
        weniger ist erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1107<DD>undefiniertes Attribut
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das an einem Befehl angef&uuml;gte Attribut ist
        ung&uuml;ltig.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1110<DD>Unpassende Operandenzahl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei einem Befehl (Prozessor oder Pseudo) angegebene
        Operandenzahl liegt nicht in dem f&uuml;r diesen Befehl
        erlaubten Bereich.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1115<DD>Unpassende Optionenzahl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei diesem Befehl angegebene Zahl von Optionen liegt
        nicht in dem f&uuml;r diesen Befehl erlaubten Bereich.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1120<DD>nur immediate-Adressierung erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl l&auml;&szlig;t nur immediate-Operanden
        (mit vorangestelltem #) zu.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1130<DD>Unpassende Operandengr&ouml;&szlig;e
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Operand hat zwar einen f&uuml;r den Befehl zugelassenen
        Typ, jedoch nicht die richtige L&auml;nge (in Bits).</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1131<DD>Widersprechende Operandengr&ouml;&szlig;en
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebenen Operanden haben unterschiedliche L&auml;ngen
        (in Bit).</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1132<DD>Undefinierte Operandengr&ouml;&szlig;e
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Aus Opcode und Operanden l&auml;&szlig;t sich die
        Operandengr&ouml;&szlig;e nicht eindeutig bestimmen (ein
        Problem des 8086-Assemblers). Sie m&uuml;ssen die
        Operandengr&ouml;&szlig;e durch einen<TT> BYTE</TT>,<TT>
        WORD</TT>, usw.<TT> PTR</TT>-Pr&auml;fix festlegen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1135<DD>Ung&uuml;ltiger Operandentyp
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausdruck hat einen an dieser Stelle nicht zul&auml;ssigen
        Typ (Integer/Gleitkomma/String).</DD>
<DT>Argument:<DD>     <BR>
        Die an dieser Stelle zul&auml;ssigen Datentypen<BR>
         </DD>
</DL>
</DD>
<DT>1140<DD>Zuviele Argumente
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Einem Befehl wurden mehr als die unter AS zul&auml;ssigen 20
        Parameter &uuml;bergeben.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1200<DD>Unbekannter Befehl
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl ist weder ein Pseudobefehl von AS noch
        ein Befehl des momentan eingestellten Prozessors.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1300<DD>Klammerfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Formelparser ist auf einen (Teil-)Ausdruck
        gesto&szlig;en, in dem die Summe &ouml;ffnender und
        schlie&szlig;ender Klammern nicht &uuml;bereinstimmt.</DD>
<DT>Argument:<DD>     <BR>
        der beanstandete (Teil-)Ausdruck<BR>
         </DD>
</DL>
</DD>
<DT>1310<DD>Division durch 0
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei einer Division oder Modulooperation ergab die Auswertung
        des rechten Teilausdruckes 0.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1315<DD>Bereichsunterschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Integer-Wert unterschreitet den
        zul&auml;ssigen Bereich.</DD>
<DT>Argument:<DD>     <BR>
        aktueller Wert und zul&auml;ssiges Minimum (manchmal, ich
        stelle das gerade um...)<BR>
         </DD>
</DL>
</DD>
<DT>1320<DD>Bereichs&uuml;berschreitung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Integer-Wert &uuml;berschreitet den
        zul&auml;ssigen Bereich.</DD>
<DT>Argument:<DD>     <BR>
        aktueller Wert und zul&auml;ssiges Maximum (manchmal,ich
        stelle das gerade um...)<BR>
         </DD>
</DL>
</DD>
<DT>1325<DD>Adresse nicht ausgerichtet
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene direkte Speicheradresse entspricht nicht den
        Anspr&uuml;chen des Datentransfers, d.h. ist nicht ein
        mehrfaches der Operandengr&ouml;&szlig;e. Nicht alle
        Prozessoren erlauben unausgerichtete Datenzugriffe.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1330<DD>Distanz zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der in einem Adre&szlig;ausdruck enthaltene Displacement-Wert
        ist zu gro&szlig;.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1340<DD>Kurzadressierung nicht m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Adresse des Operanden liegt au&szlig;erhalb des
        Speicherbereiches, in dem Kurzadressierung m&ouml;glich
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1350<DD>Unerlaubter Adressierungsmodus
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Adressierungsmodus existiert generell zwar, ist
        an dieser Stelle aber nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1351<DD>Nummer mu&szlig; ausgerichtet sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        An dieser Stelle sind nur ausgerichtete (d.h z.B. gerade)
        Adressen erlaubt, da die untersten Bits f&uuml;r andere
        Zwecke verwendet werden oder reserviert sind.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1355<DD>Adressierungsmodus im Parallelbetrieb nicht erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendeten Adressierungsmodi sind zwar im sequentiellen
        Modus zul&auml;ssig, jedoch nicht bei parallelen
        Instruktionen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1360<DD>Undefinierte Bedingung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die benutzte Bedingung f&uuml;r bedingte Spr&uuml;nge
        existiert nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1365<DD>inkompatible Bedingungen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die benutzte Kombination von Bedingungen kann nicht in einem
        Befehl verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        die Bedingung, bei der die Unvertr&auml;glichkeit entdeckt
        wurde.<BR>
         </DD>
</DL>
</DD>
<DT>1370<DD>Sprungdistanz zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel liegen zu weit auseinander, um
        mit einem Sprung der benutzten L&auml;nge
        &uuml;berbr&uuml;ckt werden zu k&ouml;nnen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1375<DD>Sprungdistanz ist ungerade
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Da Befehle nur auf geraden Adressen liegen d&uuml;rfen,
        mu&szlig; eine Sprungdistanz zwischen zwei Befehlen auch
        immer gerade sein, das Bit 0 der Distanz wird anderweitig
        verwendet. Diese Bedingung ist verletzt worden. Grund ist
        &uuml;blicherweise die Ablage einer ungeraden Anzahl von
        Daten in Bytes oder ein falsches<TT> ORG</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1380<DD>ung&uuml;ltiges Schiebeargument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        als Argument f&uuml;r die Schiebeamplitude darf nur eine
        Konstante oder ein Datenregister verwendet werden. (nur
        680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1390<DD>Nur Bereich 1..8 erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Konstanten f&uuml;r Schiebeamplituden oder<TT>
        ADDQ</TT>-Argumente d&uuml;rfen nur im Bereich 1..8 liegen.
        (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1400<DD>Schiebezahl zu gro&szlig;
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1410<DD>Ung&uuml;ltige Registerliste
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Registerlisten-Argument von<TT> MOVEM</TT> oder<TT>
        FMOVEM</TT> hat ein falsches Format. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1420<DD>Ung&uuml;ltiger Modus mit CMP
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die verwendete Operandenkombination von<TT> CMP</TT> ist
        nicht erlaubt. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1430<DD>Ung&uuml;ltiger Prozessortyp
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Den mit CPU angeforderten Zielprozessor kennt AS nicht.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte Prozessortyp<BR>
         </DD>
</DL>
</DD>
<DT>1440<DD>Ung&uuml;ltiges Kontrollregister
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das bei z.B.<TT> MOVEC</TT> benutzte Kontrollregister kennt
        der mit CPU gesetzte Prozessor (noch) nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1445<DD>Ung&uuml;ltiges Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte Register ist zwar prinzipiell vorhanden, hier
        aber nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1450<DD>RESTORE ohne SAVE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde ein<TT> RESTORE</TT>-Befehl gefunden, obwohl kein
        mit<TT> SAVE</TT> gespeicherter Zustand (mehr) auf dem Stapel
        vorhanden ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1460<DD>fehlendes RESTORE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach der Assemblierung sind nicht alle<TT> SAVE</TT>-Befehle
        wieder aufgel&ouml;st worden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1465<DD>unbekannte Makro-Steueranweisung
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine beim<TT> MACRO</TT>-Befehl zus&auml;tzlich angegebene
        Steueranweisung ist AS unbekannt.</DD>
<DT>Argument:<DD>     <BR>
        die fragliche Anweisung<BR>
         </DD>
</DL>
</DD>
<DT>1470<DD>fehlendes ENDIF/ENDCASE
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach der Assemblierung sind nicht alle Konstrukte zur
        bedingten Assemblierung aufgel&ouml;st worden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1480<DD>ung&uuml;ltiges IF-Konstrukt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Reihenfolge der Befehle in einem<TT> IF</TT>- oder<TT>
        SWITCH</TT>-Konstrukt stimmt nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1483<DD>doppelter Sektionsname
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es existiert bereits eine Sektion gleichen Namens auf dieser
        Ebene.</DD>
<DT>Argument:<DD>     <BR>
        der doppelte Name<BR>
         </DD>
</DL>
</DD>
<DT>1484<DD>unbekannte Sektion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Im momentanen Sichtbarkeitsbereich existiert keine Sektion
        dieses Namens.</DD>
<DT>Argument:<DD>     <BR>
        der unbekannte Name<BR>
         </DD>
</DL>
</DD>
<DT>1485<DD>fehlendes ENDSECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach Ende eines Durchganges sind nicht alle Sektionen wieder
        geschlossen worden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1486<DD>falsches ENDSECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        die bei<TT> ENDSECTION</TT> angegebene Sektion ist nicht die
        innerste offene.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1487<DD>ENDSECTION ohne SECTION
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde ein<TT> ENDSECTION</TT>-Befehl gegeben, obwohl gar
        keine Sektion offen war.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1488<DD>nicht aufgel&ouml;ste Vorw&auml;rtsdeklaration
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        ein mit<TT> FORWARD</TT> oder<TT> PUBLIC</TT>
        angek&uuml;ndigtes Symbol wurde nicht in der Sektion
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>1489<DD>widersprechende FORWARD <->PUBLIC-Deklaration
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Symbol wurde sowohl als privat als auch global
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Symbols<BR>
         </DD>
</DL>
</DD>
<DT>1490<DD>falsche Argumentzahl f&uuml;r Funktion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Anzahl der Argumente f&uuml;r eine selbstdefinierte
        Funktion stimmt nicht mit der geforderten Anzahl
        &uuml;berein.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1495<DD>unaufgel&ouml;ste Literale (LTORG fehlt)
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Am Programmende oder beim Umachalten zu einem anderen
        Zielprozessor blieben noch nicht abgelegte Literale
        &uuml;brig.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1500<DD>Befehl auf dem ... nicht vorhanden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl existiert zwar grunds&auml;tzlich, das
        eingestellte Mitglied der Prozessorfamilie beherrscht ihn
        aber noch nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1505<DD>Adressierungsart auf dem ... nicht vorhanden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Adressierungsmodus existiert zwar
        grunds&auml;tzlich, das eingestellte Mitglied der
        Prozessorfamilie beherrscht ihn aber noch nicht.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1510<DD>Ung&uuml;ltige Bitstelle
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene Bitnummer ist nicht erlaubt oder eine Angabe
        fehlt komplett.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1520<DD>nur ON/OFF erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieser Pseudobefehl darf als Argument nur<TT> ON</TT>
        oder<TT> OFF</TT> haben.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1530<DD>Stack ist leer oder nicht definiert
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde bei einem<TT> POPV</TT> einen Stack anzusprechen,
        der entweder nie definiert oder bereits leerger&auml;umt
        wurde.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Stacks<BR>
         </DD>
</DL>
</DD>
<DT>1540<DD>Nicht genau ein Bit gesetzt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        In einer Bitmaske, die der<TT> BITPOS</TT>- Funktion
        &uuml;bergeben wurde, war nicht genau ein Bit gesetzt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1550<DD>ENDSTRUCT ohne STRUCT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine<TT> ENDSTRUCT</TT>-Anweisung wurde gegeben, obwohl
        momentan keine Strukturdefinition in Gange war.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1551<DD>offene Strukturdefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Nach Ende der Assemblierung waren noch nicht alle<TT>
        STRUCT</TT>-Anweisungen durch passende<TT> ENDSTRUCT</TT>s
        abgeschlossen.</DD>
<DT>Argument:<DD>     <BR>
        die innerste, noch nicht abgeschlossene
        Strukturdefinition<BR>
         </DD>
</DL>
</DD>
<DT>1552<DD>falsches ENDSTRUCT
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Namensparameter einer<TT> ENDSTRUCT</TT>-Anweisung
        entspricht nicht der innersten, offenen
        Strukturdefinition.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1553<DD>Phasendefinition nicht in Strukturen erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Was gibt es dazu zu sagen?<TT> PHASE</TT> in einem Record
        ergibt einfach keinen Sinn und nur Verwirrung...</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1554<DD>ung&uuml;ltige<TT> STRUCT</TT>-Direktive
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Direktive f&uuml;r<TT> STRUCT</TT> ist nur<TT>
        EXTNAMES</TT> oder<TT> NOEXTNAMES</TT> zugelassen.</DD>
<DT>Argument:<DD>     <BR>
        die unbekannte Direktive<BR>
         </DD>
</DL>
</DD>
<DT>1560<DD>Anweisung nicht wiederholbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Maschinenanweisung kann nicht mit Hilfe eines<TT>
        RPT</TT>-Konstruktes wiederholt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1600<DD>vorzeitiges Dateiende
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde mit einem<TT> BINCLUDE</TT>-Befehl versucht,
        &uuml;ber das Ende einer Datei hinauszulesen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1700<DD>ROM-Offset geht nur von 0..63
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Konstanten-ROM der 680x0-Koprozessoren hat nur max. 63
        Eintr&auml;ge.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1710<DD>Ung&uuml;ltiger Funktionscode
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Funktionscodeargument darf nur SFC, DFC, ein
        Datenregister oder eine Konstante von 0..15 verwendet werden.
        (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1720<DD>Ung&uuml;ltige Funktionscodemaske
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Als Funktionscodemaske darf nur ein Wert von 0..15 verwendet
        werden. (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1730<DD>Ung&uuml;ltiges MMU-Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die MMU hat kein Register mit dem angegebenen Namen. (nur
        680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1740<DD>Level nur von 0..7
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Ebene f&uuml;r<TT> PTESTW</TT> und<TT> PTESTR</TT>
        mu&szlig; eine Konstante von 0..7 sein. (nur 680x0-MMU)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1750<DD>ung&uuml;ltige Bitmaske
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die bei den Bit-Feld-Befehlen angegebene Bitmaske hat ein
        falsches Format. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1760<DD>ung&uuml;ltiges Registerpaar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Registerpaar ist hier nicht verwendbar oder
        syntaktisch falsch. (nur 680x0)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1800<DD>offene Makrodefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine Makrodefinition war am Dateiende nicht zuende.
        Vermutlich fehlt ein<TT> ENDM</TT>.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1805<DD>EXITM au&szlig;erhalb eines Makrorumpfes
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        <TT>EXITM</TT> bricht die Expansion von Makro-Konstrukten ab.
        Dieser Befehl macht nur innerhalb von Makros Sinn und es
        wurde versucht, ihn au&szlig;erhalb aufzurufen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1810<DD>mehr als 10 Makroparameter
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Makro darf h&ouml;chstens 10 Parameter haben.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1815<DD>doppelte Makrodefinition
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Makronamne wurde in einer Sektion doppelt vergeben.</DD>
<DT>Argument:<DD>     <BR>
        der doppelt verwendete Name<BR>
         </DD>
</DL>
</DD>
<DT>1820<DD>Ausdruck mu&szlig; im ersten Pass berechenbar sein
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der benutzte Befehl beeinflu&szlig;t die Codel&auml;nge,
        daher sind Vorw&auml;rtsreferenzen hier nicht erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1830<DD>zu viele verschachtelte IFs
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1840<DD>ELSEIF/ENDIF ohne ENDIF
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        es wurde ein<TT> ELSEIF</TT>- oder<TT> ENDIF</TT>-Befehl
        gefunden, obwohl kein offener<TT> IF</TT>-Befehl vorhanden
        ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1850<DD>verschachtelter/rekursiver Makroaufruf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1860<DD>unbekannte Funktion
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angesprochene Funktion ist weder eingebaut noch
        nachtr&auml;glich definiert worden.</DD>
<DT>Argument:<DD>     <BR>
        der Funktionsname<BR>
         </DD>
</DL>
</DD>
<DT>1870<DD>Funktionsargument au&szlig;erhalb Definitionsbereich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument liegt nicht im Bereich der angesprochenen
        transzendenten Funktion.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1880<DD>Gleitkomma&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das Argument liegt zwar im Bereich der angesprochenen
        transzendenten Funktion, das Ergebnis w&auml;re aber nicht
        mehr darstellbar.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1890<DD>ung&uuml;ltiges Wertepaar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das benutzte P&auml;rchen aus Basis und Exponent kann nicht
        berechnet werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1900<DD>Befehl darf nicht auf dieser Adresse liegen
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Prozessorhardware erlaubt keine Spr&uuml;nge von dieser
        Adresse.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1905<DD>ung&uuml;ltiges Sprungziel
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die Prozessorhardware erlaubt keine Spr&uuml;nge zu dieser
        Adresse.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1910<DD>Sprungziel nicht auf gleicher Seite
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Sprungbefehl und Sprungziel m&uuml;ssen bei diesem Befehl auf
        der gleichen Seite liegen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1920<DD>Code&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Es wurde versucht, mehr als 1024 Bytes Code oder Daten in
        einer Zeile zu erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1925<DD>Adre&szlig;&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der Adre&szlig;raum dieses Prozessors wurde
        &uuml;berschritten.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1930<DD>Konstanten und Platzhalter nicht mischbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Anweisungen, die Speicher reservieren und solche, die ihn mit
        Konstanten belegen, d&uuml;rfen nicht in einer
        Pseudoanweisung gemischt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1940<DD>Codeerzeugung in Strukturdefinition nicht zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein<TT> STRUCT</TT>-Konstrukt dient nur der Beschreibung
        einer Datenstruktur und nicht dem Anlegen einer solchen, es
        sind daher keine Befehle zugelassen, die Code erzeugen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1950<DD>Paralleles Konstrukt nicht m&ouml;glich
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Entweder sind die beiden Instruktionen prinzipiell nicht
        parallel ausf&uuml;hrbar, oder sie stehen nicht unmittelbar
        untereinander.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1960<DD>ung&uuml;ltiges Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segment ist an dieser Stelle nicht
        anwendbar.</DD>
<DT>Argument:<DD>     <BR>
        der benutzte Segmentname<BR>
         </DD>
</DL>
</DD>
<DT>1961<DD>unbekanntes Segment
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segment existiert bei diesem Prozessor
        nicht.</DD>
<DT>Argument:<DD>     <BR>
        der benutzte Segmentname<BR>
         </DD>
</DL>
</DD>
<DT>1962<DD>unbekanntes Segmentregister
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Segmentregister existiert nicht (nur
        8086).</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1970<DD>ung&uuml;ltiger String
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene String hat ein ung&uuml;ltiges Format.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1980<DD>ung&uuml;ltiger Registername
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das angegebene Register existiert nicht oder darf hier nicht
        verwendet werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1985<DD>ung&uuml;ltiges Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Der angegebene Befehl darf nicht mit einem<TT>
        REP</TT>-Pr&auml;fix versehen werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1990<DD>keine Indirektion erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        in dieser Kombination ist keine indirekte Adressierung
        erlaubt.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1995<DD>nicht im aktuellen Segment erlaubt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        (nicht mehr verwendet)</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1996<DD>nicht im Maximum-Modus zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieses Register ist nur im Minimum-Modus definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>1997<DD>nicht im Minimum-Modus zul&auml;ssig
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Dieses Register ist nur im Maximum-Modus definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2000<DD>Anweisungspaket &uuml;berschreitet Adre&szlig;grenze
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Anweisungspaket dard nicht &uuml;ber eine
        32-Byte-Adre&szlig;grenze reichen.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2001<DD>Ausf&uuml;hrungseinheit mehrfach benutzt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Eine der Ausf&uuml;hrungseinheiten des Prozessors wurde in
        einem Anweisungspaket mehrfach benutzt.</DD>
<DT>Argument:<DD>     <BR>
        der Name der Funktionseinheit<BR>
         </DD>
</DL>
</DD>
<DT>2002<DD>mehrfache Lang-Leseoperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt mehr als eine
        Lang-Leseoperation, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, auf denen eine
        Lang-Leseoperation ausgef&uuml;hrt wird<BR>
         </DD>
</DL>
</DD>
<DT>2003<DD>mehrfache Lang-Schreiboperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt mehr als eine
        Lang-Schreiboperation, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, auf denen eine
        Lang-Schreiboperation ausgef&uuml;hrt wird<BR>
         </DD>
</DL>
</DD>
<DT>2004<DD>Lang-Lese- mit Schreiboperation
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Ausf&uuml;hrungspaket enth&auml;lt sowohl eine
        Lang-Leseoperation als auch eine Schreiboperation, was nicht
        erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        eine der Funktionseinheiten, deren Operationen im Konflikt
        stehen.<BR>
         </DD>
</DL>
</DD>
<DT>2005<DD>zu viele Lesezugriffe auf ein Register
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Auf das gleiche Register wurde mehr als viermal im gleichen
        Anweisungspaket Bezug genommen.</DD>
<DT>Argument:<DD>     <BR>
        der Name des Registers, das zu oft referenziert wurde<BR>
         </DD>
</DL>
</DD>
<DT>2006<DD>&uuml;berlappende Ziele
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Auf das gleiche Register wurde mehrfach im gleichen
        Ausf&uuml;hrungspaket geschrieben, was nicht erlaubt
        ist.</DD>
<DT>Argument:<DD>     <BR>
        der Name der fraglichen Registers<BR>
         </DD>
</DL>
</DD>
<DT>2008<DD>zu viele absolute Spr&uuml;nge in einem Anweisungspaket
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein Anweisungspaket beinhaltet mehr als einen direkten
        Sprung, was nicht erlaubt ist.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2009<DD>Anweisung nicht auf diese Funktionseinheit ausf&uuml;hrbar
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Diese Anweisung kann nicht auf dieser Funktionseinheit
        ausgef&uuml;hrt werden.</DD>
<DT>Argument:<DD>     <BR>
        none<BR>
         </DD>
</DL>
</DD>
<DT>2010<DD>Ung&uuml;ltige Escape-Sequenz
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Das mit einem Backslash eingeleitete Sonderzeichen ist nicht
        definiert.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2020<DD>ung&uuml;ltige Pr&auml;fix-Kombination
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Die angegebene Kombination von Pr&auml;fixen ist nicht
        zul&auml;ssig oder nicht im Maschinenkode darstellbar.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2030<DD>Konstante kann nicht als Variable redefiniert werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein einmal mit<TT> EQU</TT> als Konstante<BR>
        definiertes Symbol kann nicht nachtr&auml;glich mit<BR>
        <TT> SET</TT> ver&auml;ndert werden.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>2035<DD>Variable kann nicht als Konstante redefiniert werden
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Ein einmal mit<TT> SET</TT> als Variable<BR>
        definiertes Symbol kann nicht nachtr&auml;glich als<BR>
        Konstante deklariert werden (z.B. mit<TT> EQU</TT>.</DD>
<DT>Argument:<DD>     <BR>
        der Name des fraglichen Symbols<BR>
         </DD>
</DL>
</DD>
<DT>2040<DD>Strukturname fehlt
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        Bei einer Strukturdefinition fehlt der zugeh&ouml;rende Name
        f&uuml;r die Struktur.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>2050<DD>leeres Argument
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        Fehler</DD>
<DT>Ursache:<DD>     <BR>
        In der Argumentenliste dieser Anweisung d&uuml;rfen keine
        Leerstrings benutzt werden.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>10001<DD>Fehler bein &Ouml;ffnen der Datei
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Versuch, eine Datei zu &ouml;ffnen, ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers<BR>
         </DD>
</DL>
</DD>
<DT>10002<DD>Listingschreibfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Schreiben des Assemblerlistings ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers<BR>
         </DD>
</DL>
</DD>
<DT>10003<DD>Dateilesefehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Lesen aus einer Quelldatei ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers<BR>
         </DD>
</DL>
</DD>
<DT>10004<DD>Dateischreibfehler
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Beim Schreiben von Code- oder Share-Datei ist ein Fehler
        aufgetreten.</DD>
<DT>Argument:<DD>     <BR>
        Beschreibung des E/A-Fehlers<BR>
         </DD>
</DL>
</DD>
<DT>10006<DD>Speicher&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Der verf&uuml;gbare Speicher reicht nicht mehr, alle
        Datenstrukturen aufzunehmen. Weichen Sie auf die DPMI- oder
        OS/2-Version von AS aus.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
<DT>10007<DD>Stapel&uuml;berlauf
<DL COMPACT>
<DT>Typ:<DD>     <BR>
        fatal</DD>
<DT>Ursache:<DD>     <BR>
        Der Programmstapel ist wegen zu komplizierter
        Formelausdr&uuml;cke oder einer ung&uuml;nstigen Anlage der
        Symbol- oder Makrotabelle &uuml;bergelaufen. Versuchen Sie es
        noch einmal mit der<TT> -A</TT>-Option.</DD>
<DT>Argument:<DD>     <BR>
        keines<BR>
         </DD>
</DL>
</DD>
</DL>
<P>

<H1><A NAME="sect_B_">B. E/A-Fehlermeldungen</A></H1>
<P>
Die hier aufgelisteten Fehlermeldungen werden nicht nur von AS bei
E/A- Fehlern ausgegeben, sondern auch von den Hilfsprogrammen PLIST,
BIND, P2HEX und P2BIN. Es sind nur die Fehler n&auml;her
erkl&auml;rt, die m.E. bei der Arbeit auftreten k&ouml;nnen. Sollte
doch einmal ein nicht erl&auml;uterter E/A-Fehler auftreten, so
d&uuml;rfte der Grund in einem Programmfehler liegen. Melden Sie dies
unbedingt!!
<P>
<DL COMPACT>
<DT>2<DD>Datei nicht gefunden<BR>
    Die angegebene Datei existiert nicht oder liegt auf einem anderen
    Laufwerk.</DD>
<DT>3<DD>Pfad nicht gefunden<BR>
    Der Pfad eines Dateinamens existiert nicht oder liegt auf einem
    anderen Laufwerk.</DD>
<DT>4<DD>zu viele offene Dateien<BR>
    DOS sind die Dateihandles ausgegangen. Erh&ouml;hen Sie die<TT>
    FILES=</TT>-Angabe in der CONFIG.SYS.</DD>
<DT>5<DD>Dateizugriff verweigert<BR>
    Entweder reichen die Netzwerkrechte f&uuml;r einen Dateizugriff
    nicht, oder es wurde versucht, eine schreibgesch&uuml;tzte Datei
    zu &uuml;berschreiben oder zu ver&auml;ndern. Bei Benutzung in
    DOS- Fenstern von Multitasking- Systemen ist es &uuml;berdies
    m&ouml;glich, da&szlig; ein andere Proze&szlig; die Datei in
    exklusivem Zugriff hat.</DD>
<DT>6<DD>ung&uuml;ltiger Dateihandle</DD>
<DT>12<DD>ung&uuml;ltiger Zugriffsmodus</DD>
<DT>15<DD>ung&uuml;ltiger Laufwerksbuchstabe<BR>
    Das angesprochene Laufwerk existiert nicht.</DD>
<DT>16<DD>aktuelles Verzeichnis kann nicht gel&ouml;scht werden</DD>
<DT>17<DD>RENAME geht nicht &uuml;ber Laufwerke</DD>
<DT>100<DD>vorzeitiges Dateiende<BR>
    Eine Datei war zuende, obwohl sie es aufgrund ihrer Struktur noch
    nicht sein d&uuml;rfte. Vermutlich ist sie besch&auml;digt.</DD>
<DT>101<DD>Diskette/Platte voll<BR>
    Das spricht wohl f&uuml;r sich! Aufr&auml;umen!!</DD>
<DT>102<DD>ASSIGN fehlt</DD>
<DT>103<DD>Datei nicht offen</DD>
<DT>104<DD>Datei nicht f&uuml;r Einlesen offen</DD>
<DT>105<DD>Datei nicht f&uuml;r Ausgaben offen</DD>
<DT>106<DD>Ung&uuml;ltiges numerisches Format</DD>
<DT>150<DD>Diskette ist schreibgesch&uuml;tzt<BR>
    Wenn Sie schon keine Festplatte als Arbeitsmedium verwenden, so
    sollten Sie wenigstens den Schreibschutz entfernen!</DD>
<DT>151<DD>Unbekanntes Ger&auml;t<BR>
    Sie haben versucht, ein Peripherieger&auml;t anzusprechen,
    welches DOS unbekannt ist. Dies sollte normalerweise nicht
    auftreten, da der Name dann automatisch als Datei interpretiert
    wird.</DD>
<DT>152<DD>Laufwerk nicht bereit<BR>
    Schlie&szlig;en Sie die Klappe des Diskettenlaufwerks.</DD>
<DT>153<DD>unbekannte DOS-Funktion</DD>
<DT>154<DD>Pr&uuml;fsummenfehler auf Diskette/Platte<BR>
    Ein harter Lesefehler auf der Diskette. Nochmal versuchen; wenn
    immer noch vorhanden, Diskette neu formatieren bzw. ernste Sorgen
    um Festplatte machen!</DD>
<DT>155<DD>ung&uuml;ltiger DPB</DD>
<DT>156<DD>Positionierfehler<BR>
    Der Platten/Disketten-Controller hat eine bestimmte Spur nicht
    gefunden. Siehe Nr. 154!</DD>
<DT>157<DD>unbekanntes Sektorformat<BR>
    DOS kann mit dem Format der Diskette nichts anfangen.</DD>
<DT>158<DD>Sektor nicht gefunden<BR>
    Analog zu Nr. 158, nur da&szlig; hier der angeforderte Sektor auf
    der Spur nicht gefunden werden konnte.</DD>
<DT>159<DD>Papierende<BR>
    Offensichtlich haben Sie die Ausgaben von AS direkt auf einen
    Drucker umgeleitet. Assemblerlistings k&ouml;nnen seeehr lang
    sein...</DD>
<DT>160<DD>Ger&auml;telesefehler<BR>
    Nicht n&auml;her vom Ger&auml;tetreiber klassifizierter
    Lesefehler.</DD>
<DT>161<DD>Ger&auml;teschreibfehler<BR>
    Nicht n&auml;her vom Ger&auml;tetreiber klassifizierter
    Schreibfehler.</DD>
<DT>162<DD>allgemeiner Ger&auml;tefehler<BR>
    Hier ist der Ger&auml;tetreiber v&ouml;llig ratlos, was passiert
    sein k&ouml;nnte.</DD>
</DL>
<P>

<H1><A NAME="sect_C_">C. H&auml;ufig gestellte Fragen</A></H1>
<P>
In diesem Kapitel habe ich versucht, einige besonders h&auml;ufig
gestellte Fragen mit den passenden Antworten zu sammeln. Die
Antworten auf die hier auftauchenden Probleme finden sich zwar auch
an anderer Stelle in der Anleitung, jedoch findet man sie vielleicht
nicht auf den ersten Blick...
<P>
<DL COMPACT>
<DT>F:<DD>Ich bin DOS leid. F&uuml;r welche Plattformen gibt es AS sonst ?</DD>
<DT>A:<DD>Neben der Protected-Mode-Version, die AS unter DOS mehr Speicher zur
    Verf&uuml;gung stellt, existieren Portierungen f&uuml;r OS/2 und
    Unix-Systeme wie z.B. Linux (im Teststadium). An Versionen, die
    Softwareherstellern in Redmond beim Geldscheffeln zuarbeiten
    w&uuml;rden, ist momentan nicht gedacht. Sofern jemand anders in
    dieser Hinsicht aktiv werden will, stelle ich ihm aber gerne die
    AS-Quellen zur Verf&uuml;gung, von denen sich die C-Variante
    insbesondere eignen d&uuml;rfte. &Uuml;ber Fragen zu diesen
    Quellen hinaus sollte er sich aber nicht viel von mir erwarten...
    </DD>
<DT>F:<DD>Ist eine Unterst&uuml;tzung des XYZ-Prozessors f&uuml;r AS
    geplant?</DD>
<DT>A:<DD>Es kommen immer neue Prozessoren heraus, und ich bem&uuml;he mich,
    bei Erweiterung von AS Schritt zu halten. Der Stapel mit der
    Aufschrift ,,Unerledigt'' auf meinem Schreibtisch unterschreitet
    aber selten die 10cm-Grenze... Bei der Planung, welche Kandidaten
    zuerst abgearbeitet werden, spielen W&uuml;nsche von Anwendern
    nat&uuml;rlich eine gro&szlig;e Rolle. Das Internet und die
    steigende Zahl elektronisch publizierter Dokumentation
    erleichtern die Beschaffung von Unterlagen, speziell bei
    ausgefallenen oder &auml;lteren Architekturen wird es aber immer
    wieder schwierig. Wenn sich die fragliche Prozessorfamilie nicht
    in der Liste in Planung befindlicher Prozessoren befindet (siehe
    Kapitel 1), macht es sich sehr gut, der Anfrage auch gleich ein
    passendes Datenbuch hinzuzupacken (zur Not auch leihweise!).
    </DD>
<DT>F:<DD>Ein freier Assembler ist ja eine feine Sache, aber eigentlich
    br&auml;uchte ich jetzt auch noch einen Disassembler...und einen
    Debugger...ein Simulator w&auml;re auch ganz nett..</DD>
<DT>A:<DD>AS ist ein Freizeitprojekt von mir, d.h. etwas, was ich in der Zeit
    tue, wenn ich mich nicht gerade um den Broterwerb k&uuml;mmere.
    Von dieser Zeit nimmt AS schon einen ganz erheblichen Teil ein,
    und ab und zu genehmige ich mir auch mal eine Auszeit, um den
    L&ouml;tkolben zu schwingen, mal wieder eine Tangerine
    Dream-Platte bewu&szlig;t zu h&ouml;ren, mich vor den Fernseher
    zu hocken oder einfach nur dringenden menschlichen
    Bed&uuml;rfnissen nachzugehen. Ich habe einmal angefangen, einen
    Disassembler zu konzipieren, der wieder voll reassemblierbaren
    Code erzeugt und automatisch Daten- und Code-Bereiche trennt,
    habe das Projekt aber relativ schnell wieder eingestellt, weil
    die restliche Zeit f&uuml;r so etwas einfach nicht mehr reicht.
    Ich mache lieber eine Sache gut als ein halbes Dutzend
    m&auml;&szlig;ig. Von daher mu&szlig; die Antwort also wohl
    ,,nein'' hei&szlig;en...
    </DD>
<DT>F:<DD>In den Bildschirmausgaben von AS tauchen seltsame Zeichen auf, z.B.
    Pfeile und eckige Klammern. Warum?</DD>
<DT>A:<DD>AS verwendet zur Bildschirmsteuerung defaultm&auml;&szlig;ig einige
    ANSI-Terminal-Steuersequenzen. Haben Sie keinen ANSI-Treiber
    installiert, so kommen diese Steuerzeichen ungefiltert auf Ihrem
    Bildschirm heraus. Installieren Sie entweder einen ANSI-Treiber
    oder schalten Sie die Steuersequenzen mit dem DOS-Befehl<TT> SET
    USEANSI=N</TT> ab.
    </DD>
<DT>F:<DD>W&auml;hrend der Assemblierung bricht AS pl&ouml;tzlich mit der
    Meldung eines Stapel&uuml;berlaufes ab. Ist mein Programm zu
    kompliziert?</DD>
<DT>A:<DD>Ja und Nein. Die Symboltabelle f&uuml;r Ihr Programm ist nur etwas
    unregelm&auml;&szlig;ig gewachsen, was zu zu hohen
    Rekursionstiefen im Zugriff auf die Tabelle gef&uuml;hrt hat.
    Diese Fehler treten insbesondere bei der 16-Bit-OS/2-Version von
    AS auf, die nur &uuml;ber einen relativ kleinen Stack
    verf&uuml;gt. Starten Sie AS noch einmal mit dem<TT>
    -A</TT>-Kommandozeilenschalter. Hilft dies auch nicht, so kommen
    als m&ouml;gliche Problemstellen noch zu komplizierte
    Formelausdr&uuml;cke in Frage. Versuchen Sie in einem solchen
    Fall, die Formel in Zwischenschritte aufzuspalten.
    </DD>
<DT>F:<DD>AS scheint mein Programm nicht bis zum Ende zu assemblieren. Mit
    einer &auml;lteren Version von AS (1.39) hat es dagegen
    funktioniert.</DD>
<DT>A:<DD>Neuere Versionen von AS ignorieren das<TT> END</TT>-Statement nicht
    mehr, sondern beenden danach wirklich die Assemblierung.
    Insbesondere bei Include-Dateien ist es fr&uuml;her vorgekommen,
    da&szlig; Anwender jede Datei mit einem<TT> END</TT>-Statement
    beendet haben. Entfernen Sie die &uuml;berfl&uuml;ssigen<TT>
    END</TT>s.
    </DD>
<DT>F:<DD>Weil ich noch ein paar kompliziertere Assemblierfehler im Programm
    hatte, habe ich mir ein Listing gemacht und es einmal genauer
    angeschaut. Dabei ist mir aufgefallen, da&szlig; einige
    Spr&uuml;nge nicht auf das gew&uuml;nschte Ziel, sondern auf sich
    selbst zeigen!</DD>
<DT>A:<DD>Dieser Effekt tritt bei Vorw&auml;rtsspr&uuml;ngen auf, bei denen der
    Formelparser von AS im ersten Pass die Zieladresse noch nicht
    kennen kann. Da der Formelparser ein unabh&auml;ngiges Modul ist,
    mu&szlig; er sich in einem solchen Fall einen Wert ausdenken, der
    auch relativen Spr&uuml;ngen mit kurzer Reichweite nicht wehtut,
    und dies ist nun einmal die aktuelle Programmz&auml;hleradresse
    selber...im zweiten Pass w&auml;ren die korrekten Werte
    erschienen, aber zu diesem ist es nicht gekommen, da schon im
    ersten Pass Fehler auftraten. Korrigieren Sie die anderen Fehler
    zuerst, so da&szlig; AS zum zweiten Pass kommt, und das Listing
    sollte wieder vern&uuml;nftiger aussehen.
    </DD>
<DT>F:<DD>Mein Programm wird zwar korrekt assembliert, bei der Umwandlung mit
    P2BIN oder P2HEX erhalte ich aber nur eine leere Datei.</DD>
<DT>A:<DD>Dann haben Sie wahrscheinlich das Adre&szlig;filter nicht korrekt
    eingestellt. Defaultm&auml;&szlig;ig reicht der Filter von 0 bis
    32 Kbyte, falls Ihr Programm Teile au&szlig;erhalb dieses
    Bereiches besitzen sollte, werden diese nicht &uuml;bernommen.
    Sollte Ihr Code komplett jenseits 32 Kbyte liegen (wie es bei
    65er und 68er-Prozessoren &uuml;blich ist), dann erhalten Sie das
    von Ihnen geschilderte Ergebnis. Setzen Sie das Adre&szlig;filter
    einfach auf einen passenden Bereich (s. das Kapitel zu
    P2BIN/P2HEX).
    </DD>
<DT>F:<DD>Ich bekomme unter Unix bei der Benutzung von P2BIN oder P2HEX das
    Dollarzeichen nicht eingegeben. Die automatische
    Bereichsfestlegung funktioniert nicht, stattdessen gibt es
    eigenartige Fehlermeldungen.</DD>
<DT>A:<DD>Unix-Shells benutzen das Dollarzeichen zur Expansion von
    Shell-Variablen. Wollen Sie ein Dollarzeichen an eine Anwendung
    durchreichen, stellen Sie einen Backslash (\) voran. Im Falle der
    Adre&szlig;angabe bei P2BIN und P2HEX darf aber auch<TT> 0x</TT>
    anstelle des Dollarzeichens benutzt werden, was dieses Problem
    von vornherein vermeidet.
    </DD>
<DT>F:<DD>Ich nutze AS auf einem Linux-System, das Ladeprogramm f&uuml;r mein
    Zielsystem l&auml;uft aber auf einem Windows-Rechner. Um das zu
    vereinfachen, greifen beide System auf das gleiche
    Netzwerklaufwerk zu. Leider will die Windows-Seite aber die von
    der Linux-Seite erzeugten Hex-Dateien nicht lesen :-(</DD>
<DT>A:<DD>Windows- und Linux-Systeme benutzen ein etwas abweichendes Format
    f&uuml;r Textdateien, unter die auch Hex-Dateien fallen.
    W&auml;hrend Windows jede Zeile mit den Zeichen CR (Carriage
    Return) und LF (Linefeed) abschlie&szlig;t, verwendet Linux nur
    ein Linefeed. Es h&auml;ngt nun von der ''Gutm&uuml;tigkeit''
    eines Windows-Programmes ab, ob es die Dateien im Linux-Format
    akzeptiert. Falls nicht, kann man die Dateien anstelle &uuml;ber
    ein Netzwerklaufwerk &uuml;ber FTP im ASCII-Modus
    &uuml;bertragen, oder man konvertiert die Dateien unter ins
    Windows-Format. Das Programm<EM> unix2dos</EM> kann dazu z.B.
    verwendet werden, oder unter Linux ein kleines Script:
<PRE>

          awk '{print $0"\r"}' test.hex &gt;test_cr.hex

</PRE>
    </DD>
</DL>
<P>

<H1><A NAME="sect_D_">D. Pseudobefehle gesammelt</A></H1>
<P>
In diesem Anhang finden sich noch einmal als schnelle Referenz alle
von AS zur Verf&uuml;gung gestellten Pseudobefehle. Die Liste ist in
zwei Teile gegliedert: Im ersten Teil finden sich Befehle, die
unabh&auml;ngig vom eingestellten Zielprozessor vorhanden sind,
danach folgen f&uuml;r jede Prozessorfamilie die zus&auml;tzlich
vorhandenen Befehle:
<P>

<H4>Immer vorhandene Befehle</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> =</TT></TD><TD NOWRAP><TT> :=</TT></TD><TD NOWRAP><TT> ALIGN</TT></TD><TD NOWRAP><TT> BINCLUDE</TT></TD><TD NOWRAP><TT> CASE</TT></TD></TR>
<TR><TD NOWRAP><TT> CHARSET</TT></TD><TD NOWRAP><TT> CPU</TT></TD><TD NOWRAP><TT> DEPHASE</TT></TD><TD NOWRAP><TT> DOTTEDSTRUCTS</TT></TD><TD NOWRAP><TT> ELSE</TT></TD></TR>
<TR><TD NOWRAP><TT> ELSECASE</TT></TD><TD NOWRAP><TT> ELSEIF</TT></TD><TD NOWRAP><TT> END</TT></TD><TD NOWRAP><TT> ENDCASE</TT></TD><TD NOWRAP><TT> ENDIF</TT></TD></TR>
<TR><TD NOWRAP><TT> ENDM</TT></TD><TD NOWRAP><TT> ENDS</TT></TD><TD NOWRAP><TT> ENDSECTION</TT></TD><TD NOWRAP><TT> ENDSTRUCT</TT></TD><TD NOWRAP><TT> ENUM</TT></TD></TR>
<TR><TD NOWRAP><TT> ERROR</TT></TD><TD NOWRAP><TT> EQU</TT></TD><TD NOWRAP><TT> EXITM</TT></TD><TD NOWRAP><TT> FATAL</TT></TD><TD NOWRAP><TT> FORWARD</TT></TD></TR>
<TR><TD NOWRAP><TT> FUNCTION</TT></TD><TD NOWRAP><TT> GLOBAL</TT></TD><TD NOWRAP><TT> IF</TT></TD><TD NOWRAP><TT> IFB</TT></TD><TD NOWRAP><TT> IFDEF</TT></TD></TR>
<TR><TD NOWRAP><TT> IFEXIST</TT></TD><TD NOWRAP><TT> IFNB</TT></TD><TD NOWRAP><TT> IFNDEF</TT></TD><TD NOWRAP><TT> IFNEXIST</TT></TD><TD NOWRAP><TT> IFNUSED</TT></TD></TR>
<TR><TD NOWRAP><TT> IFUSED</TT></TD><TD NOWRAP><TT> INCLUDE</TT></TD><TD NOWRAP><TT> IRP</TT></TD><TD NOWRAP><TT> LABEL</TT></TD><TD NOWRAP><TT> LISTING</TT></TD></TR>
<TR><TD NOWRAP><TT> MACEXP</TT></TD><TD NOWRAP><TT> MACRO</TT></TD><TD NOWRAP><TT> MESSAGE</TT></TD><TD NOWRAP><TT> NEWPAGE</TT></TD><TD NOWRAP><TT> ORG</TT></TD></TR>
<TR><TD NOWRAP><TT> PAGE</TT></TD><TD NOWRAP><TT> PHASE</TT></TD><TD NOWRAP><TT> POPV</TT></TD><TD NOWRAP><TT> PUSHV</TT></TD><TD NOWRAP><TT> PRTEXIT</TT></TD></TR>
<TR><TD NOWRAP><TT> PRTINIT</TT></TD><TD NOWRAP><TT> PUBLIC</TT></TD><TD NOWRAP><TT> READ</TT></TD><TD NOWRAP><TT> RELAXED</TT></TD><TD NOWRAP><TT> REPT</TT></TD></TR>
<TR><TD NOWRAP><TT> RESTORE</TT></TD><TD NOWRAP><TT> SAVE</TT></TD><TD NOWRAP><TT> SECTION</TT></TD><TD NOWRAP><TT> SEGMENT</TT></TD><TD NOWRAP><TT> SHARED</TT></TD></TR>
<TR><TD NOWRAP><TT> STRUC</TT></TD><TD NOWRAP><TT> STRUCT</TT></TD><TD NOWRAP><TT> SWITCH</TT></TD><TD NOWRAP><TT> TITLE</TT></TD><TD NOWRAP><TT> UNION</TT></TD></TR>
<TR><TD NOWRAP><TT> WARNING</TT></TD><TD NOWRAP><TT> WHILE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT> Zus&auml;tzlich existiert<TT> SET</TT> bzw.<TT> EVAL</TT>,
falls<TT> SET</TT> bereits ein Prozessorbefehl ist.
<P>

<H4>Motorola 680x0</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> FULLPMMU</TT></TD><TD NOWRAP><TT> FPU</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> PMMU</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 56xxx</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> XSFR</TT></TD><TD NOWRAP><TT> YSFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>PowerPC</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola M-Core</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola XGATE</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68xx/Hitachi 6309</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola/Freescale 6805/68HC(S)08</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 6809/Hitachi 6309</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD></TR>
<TR><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68HC12</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD></TR>
<TR><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Motorola 68HC16</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> DS[.&lt;size&gt;] FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Freescale 68RS08</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi H8/300(L/H)</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> MAXMODE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi H8/500</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> MAXMODE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Hitachi SH7x00</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> COMPLITERALS</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> LTORG</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>65xx/MELPS-740</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD></TR>
<TR><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>65816/MELPS-7700</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> DFS</TT></TD></TR>
<TR><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi MELPS-4500</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi M16</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi M16C</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 4004</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 8008</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-48</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-(2)51</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIGENDIAN</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT> SFRB</TT></TD><TD NOWRAP><TT> SRCMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel MCS-96</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>Intel 8080/8085</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel 8080/8085</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Intel i960</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT></TT></TD><TD NOWRAP><TT> FPU</TT></TD><TD NOWRAP><TT> SPACE</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Signetics 8X30x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> LIV</TT></TD><TD NOWRAP><TT> RIV</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Philips XA</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Atmel AVR</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> PACKING</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>AMD 29K</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> EMULATED</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Siemens 80C166/167</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Zilog Zx80</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DEFB</TT></TD><TD NOWRAP><TT> DEFW</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> EXTMODE</TT></TD><TD NOWRAP><TT> LWORDMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Zilog Z8</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Xilinx KCPSM</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> CONSTANT</TT></TD><TD NOWRAP><TT> NAMEREG</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Xilinx KCPSM3</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> CONSTANT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> NAMEREG</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>LatticeMico8</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-900</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> MAXIMUM</TT></TD><TD NOWRAP><TT> SUPMODE</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-90</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-870</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-47(0(A))</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Toshiba TLCS-9000</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC16C5x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC16C8x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Microchip PIC17C42</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> ZERO</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST6</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASCII</TT></TD><TD NOWRAP><TT> ASCIZ</TT></TD><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> BLOCK</TT></TD></TR>
<TR><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST7</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> DS[.&lt;size&gt;]</TT></TD><TD NOWRAP><TT> PADDING</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>SGS-Thomson ST9</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> REG</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>6804</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADR</TT></TD><TD NOWRAP><TT> BYT</TT></TD><TD NOWRAP><TT> DFS</TT></TD><TD NOWRAP><TT> FCB</TT></TD><TD NOWRAP><TT> FCC</TT></TD></TR>
<TR><TD NOWRAP><TT> FDB</TT></TD><TD NOWRAP><TT> RMB</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TM3201x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> PORT</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TM32C02x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BFLOAT</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD></TR>
<TR><TD NOWRAP><TT> EFLOAT</TT></TD><TD NOWRAP><TT> TFLOAT</TT></TD><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> LQxx</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> Qxx</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> RSTRING</TT></TD><TD NOWRAP><TT> STRING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TMS320C3x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> EXTENDED</TT></TD><TD NOWRAP><TT> SINGLE</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TM32C020x/TM32C05x/TM32C054x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BFLOAT</TT></TD><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD></TR>
<TR><TD NOWRAP><TT> EFLOAT</TT></TD><TD NOWRAP><TT> TFLOAT</TT></TD><TD NOWRAP><TT> LONG</TT></TD><TD NOWRAP><TT> LQxx</TT></TD><TD NOWRAP><TT> PORT</TT></TD></TR>
<TR><TD NOWRAP><TT> Qxx</TT></TD><TD NOWRAP><TT> RES</TT></TD><TD NOWRAP><TT> RSTRING</TT></TD><TD NOWRAP><TT> STRING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TMS320C6x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> DOUBLE</TT></TD><TD NOWRAP><TT> SINGLE</TT></TD></TR>
<TR><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TMS9900</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TMS70Cxx</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas TMS370</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DBIT</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Texas MSP430</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BSS</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> PADDING</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National SC/MP</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>National INS807x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>

<H4>National COP4</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADDR</TT></TD><TD NOWRAP><TT> ADDRW</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DSB</TT></TD><TD NOWRAP><TT> DSW</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> FB</TT></TD><TD NOWRAP><TT> FW</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National COP8</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ADDR</TT></TD><TD NOWRAP><TT> ADDRW</TT></TD><TD NOWRAP><TT> BYTE</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD></TR>
<TR><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DSB</TT></TD><TD NOWRAP><TT> DSW</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> FB</TT></TD><TD NOWRAP><TT> FW</TT></TD><TD NOWRAP><TT> SFR</TT></TD><TD NOWRAP><TT> WORD</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>National COP8</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DC</TT></TD><TD NOWRAP><TT> DC8</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DS8</TT></TD><TD NOWRAP><TT> DS16</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> DW16</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fairchild ACE</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD78(C)1x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 75K0</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> ASSUME</TT></TD><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD></TR>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD><TD NOWRAP><TT> SFR</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K0</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC 78K2</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> BIT</TT></TD><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD></TR>
<TR><TD NOWRAP><TT> DT</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD772x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DATA</TT></TD><TD NOWRAP><TT> RES</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>NEC &micro;PD772x</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Symbios Logic SYM53C8xx</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fujitsu F<SUP>2</SUP>MC8L</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Fujitsu F<SUP>2</SUP>MC16L</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H4>Mitsubishi M16C</H4>
<TT>
<TABLE SUMMARY="No Summary" CELLPADDING=2>
<TR><TD NOWRAP><TT> DB</TT></TD><TD NOWRAP><TT> DD</TT></TD><TD NOWRAP><TT> DQ</TT></TD><TD NOWRAP><TT> DS</TT></TD><TD NOWRAP><TT> DT</TT></TD></TR>
<TR><TD NOWRAP><TT> DW</TT></TD></TR>
<TR><TD NOWRAP><TT></TT></TD></TR>
</TABLE></TT>
<P>

<H1><A NAME="sect_E_">E. Vordefinierte Symbole</A></H1>
<A NAME="ref_AppInternSyms"></A>
<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datentyp</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Definition</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> ARCHITECTURE</TT><BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zielplattform, f&uuml;r die AS<BR>
&uuml;bersetzt wurde, in der Form<BR>
Prozesor-Hersteller-Betriebs-<BR>
system</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> BIGENDIAN</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Konstantenablage mit MSB<BR>
first ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CASESENSITIVE</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Unterscheidung von Gro&szlig;-<BR>
und Kleinbuchstaben in<BR>
Symbolnamen ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> CONSTPI</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Gleitkomma</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>normal</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Kreiszahl Pi (3.1415.....)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> DATE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Datum des Beginns der<BR>
Assemblierung (1.Pass)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> FALSE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>0 = logisch ,,falsch''</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> HASFPU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Koprozessor-Befehle<BR>
freigeschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> HASPMMU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>MMU-Befehle frei-<BR>
geschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INEXTMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>XM-Flag f&uuml;r 4 Gbyte<BR>
Adre&szlig;raum gesetzt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INLWORDMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>LW-Flag f&uuml;r 32-Bit-Befehle<BR>
gesetzt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INMAXMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Maximum-<BR>
Modus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INSUPMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Supervisor-<BR>
Modus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> INSRCMODE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Prozessor im Quellmodus ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> FULLPMMU</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0/1)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>voller PMMU-Befehlssatz ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> LISTON</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Listing freigeschaltet ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MACEXP</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Expansion von Makrokon-<BR>
strukten im Listing<BR>
freigeschaltet ?</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle E.1: Vordefinierte Symbole - Teil 1<A
             NAME="ref_TabInternSyms1"></A>
</CENTER><P>

<P>

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Name</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Datentyp</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Definition</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Bedeutung</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMCPU</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.<BR>
(68008)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Nummer der momentan<BR>
gesetzten Ziel-CPU</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMCPUNAME</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.<BR>
(68008)</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name der momentan<BR>
gesetzten Ziel-CPU</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMFILE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>augenblickliche Quelldatei<BR>
(schlie&szlig;t Includes ein)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMLINE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>aktuelle Zeilennummer in<BR>
der Quelldatei</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMPASS</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Nummer des laufenden<BR>
Durchgangs</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMSECTION</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name der aktuellen Sektion<BR>
oder Leerstring, fall au&szlig;er-<BR>
halb aller Sektionen</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> MOMSEGMENT</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Name des mit<TT> SEGMENT</TT> ein-<BR>
gestellten Adre&szlig;raumes</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> NESTMAX</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(256)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>maximale Verschachtelungs-<BR>
tiefe f&uuml;r Makros</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PADDING</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(1)<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Auff&uuml;llen von Bytefeldern<BR>
auf ganze Anzahl ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> RELAXED</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Boolean<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>dynam.(0)<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Schreibweise von Integer-Kon-<BR>
stanten in beliebiger Syntax<BR>
erlaubt ?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> PC</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler<BR>
(Thomson)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TIME</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>String<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Zeit des Beginns der Assem-<BR>
blierung (1. Pass)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> TRUE</TT></TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>1 = logisch ,,wahr''</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> VERSION</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Version von AS in BCD-Kodie-<BR>
rung, z.B. 1331 hex f&uuml;r<BR>
Version 1.33p1</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> WRAPMODE</TT><BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>vordef.<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>verk&uuml;rzter Programmz&auml;hler<BR>
angenommen?</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT> *<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler (Motorola,<BR>
Rockwell, Microchip, Hitachi)</TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT><TT> $</TT><BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Integer<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>Spezial<BR>
<BR>
</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>mom. Programmz&auml;hler (Intel,<BR>
Zilog, Texas, Toshiba, NEC,<BR>
Siemens, AMD)</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle E.2: Vordefinierte Symbole - Teil 2<A
             NAME="ref_TabInternSyms2"></A>
</CENTER><P>

<P>
Boolean-Symbole sind eigentlich normale normale Integer-Symbole, mit
dem Unterschied, da&szlig; ihnen von AS nur zwei verschiedene Werte
(0 oder 1, entsprechend FALSE oder TRUE) zugewiesen werden.
Spezialsymbole werden von AS nicht in der Symboltabelle abgelegt,
sondern aus Geschwindigkeitsgr&uuml;nden direkt im Parser abgefragt.
Sie tauchen daher auch nicht in der Symboltabelle des Listings auf.
W&auml;hrend vordefinierte Symbole nur einmal am Anfang eines Passes
besetzt werden, k&ouml;nnen sich die Werte dynamischer Symbole
w&auml;hrend der Assemblierung mehrfach &auml;ndern, da sie mit
anderen Befehlen vorgenommene Einstellungen widerspiegeln.
<P>
Die hier aufgelistete Schreibweise ist diejenige, mit der man die
Symbole auch im case-sensitiven Modus erreicht.
<P>
Die hier aufgef&uuml;hrten Namen sollte man f&uuml;r eigene Symbole
meiden; entweder kann man sie zwar definieren, aber nicht darauf
zugreifen (bei Spezialsymbolen), oder man erh&auml;lt eine
Fehlermeldung wegen eines doppelt definierten Symboles. Im gemeinsten
Fall f&uuml;hrt die Neubelegung durch AS zu Beginn eines Passes zu
einem Phasenfehler und einer Endlosschleife...
<P>

<H1><A NAME="sect_F_">F. Mitgelieferte Includes</A></H1>
<P>
Der Distribution von AS liegen eine Reihe von Include-Dateien bei.
Neben Includes, die sich nur auf eine Prozessorfamilie beziehen (und
deren Funktion sich demjenigen unmittelbar erschlie&szlig;t, der mit
dieser Familie arbeitet), existieren aber auch ein paar Dateien, die
prozessorunabh&auml;ngig sind und die eine Reihe n&uuml;tzlicher
Funktionen implementieren. Die definierten Funktionen sollen hier
kurz beschrieben werden:
<P>

<H2><A NAME="sect_F_1_">F.1. BITFUNCS.INC</A></H2>
<P>
Diese Datei definiert eine Reihe bitorientierter Operationen, wie man
sie bei anderen Assemblern vielleicht fest eingebaut sind. Bei AS
werden sie jedoch mit Hilfe benutzerdefinierter Funktionen
implementiert:
<P>
<UL>
<LI> <EM> mask(start,bits)</EM> liefert einen Integer, in dem ab
    Stelle<EM> start</EM><EM> bits</EM> Bits gesetzt sind;</LI>
<LI> <EM> invmask(start,bits)</EM> liefert das Einerkomplement zu<EM>
    mask()</EM>;</LI>
<LI> <EM> cutout(x,start,bits)</EM> liefert ausmaskierte<EM> bits</EM>
    Bits ab Stelle<EM> start</EM> aus<EM> x</EM>, ohne sie auf Stelle
    0 zu verschieben;</LI>
<LI> <EM> hi(x)</EM> liefert das zweitniedrigste Byte (Bit 8..15) aus<EM>
    x</EM>;</LI>
<LI> <EM> lo(x)</EM> liefert das niederwertigste Byte (Bit 0..7) aus<EM>
    x</EM>;</LI>
<LI> <EM> hiword(x)</EM> liefert das zweitniedrigste Wort (Bit 16..31)
    aus<EM> x</EM>;</LI>
<LI> <EM> loword(x)</EM> liefert das niederwertigste Wort (Bit 0..15)
    aus<EM> x</EM>;</LI>
<LI> <EM> odd(x)</EM> liefert TRUE, falls<EM> x</EM> ungerade ist;</LI>
<LI> <EM> even(x)</EM> liefert TRUE, falls<EM> x</EM> gerade ist;</LI>
<LI> <EM> getbit(x,n)</EM> extrahiert das Bit<EM> n</EM> aus<EM> x</EM>
    und liefert es als 0 oder 1;</LI>
<LI> <EM> shln(x,size,n)</EM> schiebt ein Wort<EM> x</EM> der
    L&auml;nge<EM> size</EM> Bits um<EM> n</EM> Stellen nach
    links;</LI>
<LI> <EM> shrn(x,size,n)</EM> schiebt ein Wort<EM> x</EM> der
    L&auml;nge<EM> size</EM> Bits um<EM> n</EM> Stellen nach
    rechts;</LI>
<LI> <EM> rotln(x,size,n)</EM> rotiert die untersten<EM> size</EM> Bits
    eines Integers<EM> x</EM> um<EM> n</EM> Stellen nach links;</LI>
<LI> <EM> rotrn(x,size,n)</EM> rotiert die untersten<EM> size</EM> Bits
    eines Integers<EM> x</EM> um<EM> n</EM> Stellen nach rechts;</LI>
</UL>
<P>

<H2><A NAME="sect_F_2_">F.2. CTYPE.INC</A></H2>
<P>
Dieser Include ist das Pendant zu dem bei C vorhandenen Header<TT>
ctype.h</TT>, der Makros zur Klassifizierung von Zeichen anbietet.
Alle Funktionen liefern entweder TRUE oder FALSE:
<P>
<UL>
<LI> <EM> isdigit(ch)</EM> ist TRUE, falls<EM> ch</EM> eine Ziffer (0..9)
    ist;</LI>
<LI> <EM> isxdigit(ch)</EM> ist TRUE, falls<EM> ch</EM> eine g&uuml;ltige
    Hexadezimal-Ziffer (0..9, A..F, a..f) ist;</LI>
<LI> <EM> isascii(ch)</EM> ist TRUE, falls<EM> ch</EM> sich im Bereich
    normaler ASCII-Zeichen ohne gesetztes Bit 7 bewegt;</LI>
<LI> <EM> isupper(ch)</EM> ist TRUE, falls<EM> ch</EM> ein
    Gro&szlig;buchstabe ist (Sonderzeichen ausgenommen);</LI>
<LI> <EM> islower(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Kleinbuchstabe
    ist (Sonderzeichen ausgenommen);</LI>
<LI> <EM> isalpha(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Buchstabe ist
    (Sonderzeichen ausgenommen);</LI>
<LI> <EM> isalnum(ch)</EM> ist TRUE, falls<EM> ch</EM> ein Buchstabe oder
    eine Ziffer ist);</LI>
<LI> <EM> isspace(ch)</EM> ist TRUE, falls<EM> ch</EM> ein 'Leerzeichen'
    (Space, Formfeed, Zeilenvorschub, Wagenr&uuml;cklauf, Tabulator)
    ist);</LI>
<LI> <EM> isprint(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    Zeichen ist (also kein Steuerzeichen bis Code 31);</LI>
<LI> <EM> iscntrl(ch)</EM> ist das Gegenteil zu<EM> isprint()</EM>;</LI>
<LI> <EM> isgraph(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    und<I> sichtbares</I> Zeichen ist;</LI>
<LI> <EM> ispunct(ch)</EM> ist TRUE, falls<EM> ch</EM> ein druckbares
    Sonderzeichen ist (d.h. weder Space, Buchstabe noch Ziffer);</LI>
</UL>
<P>

<H1><A NAME="sect_G_">G. Danksagungen</A></H1>
<P>
<BLOCKQUOTE>
    <I> ''If I have seen farther than other men,<BR>
    it is because I stood on the shoulders of giants.''<BR>
              --Sir Isaac Newton</I>
</BLOCKQUOTE>
<BLOCKQUOTE>
    <I> ''If I haven't seen farther than other men,<BR>
    it is because I stood in the footsteps of giants.''<BR>
              --unknown</I>
</BLOCKQUOTE>
<P>
Wenn man sich entschlie&szlig;t, ein solches Kapitel neu zu
schreiben, nachdem es eigentlich schon zwei Jahre veraltet ist,
l&auml;uft man automatisch Gefahr, da&szlig; dabei der eine oder
andere gute Geist, der etwas zum bisherigen Gelingen dieses Projektes
beigetragen hat, vergessen wird. Der allererste Dank geb&uuml;hrt
daher allen Personen, die ich in der folgenden Aufz&auml;hlung
unfreiwillig unterschlagen habe!
<P>
AS als Universalassembler, wie er jetzt besteht, ist auf Anregung von
Bernhard (C.) Zschocke entstanden, der einen
,,studentenfreundlichen'', d.h. kostenlosen 8051-Assembler f&uuml;r
sein Mikroprozessorpraktikum brauchte und mich dazu bewegt hat, einen
bereits bestehenden 68000-Assembler zu erweitern. Von dortan nahm die
Sache ihren Lauf... Das Mikroprozessorpraktikum an der RWTH Aachen
hat auch immer die eifrigsten Nutzer der neuesten AS-Features (und
damit Bug-Sucher) gestellt und damit einiges zur jetzigen
Qualit&auml;t von AS beigetragen.
<P>
Das Internet und FTP haben sich als gro&szlig;e Hilfe bei der Meldung
von Bugs und der Verbreitung von AS erwiesen. Ein Dank geht daher an
die FTP-Administratoren (Bernd Casimir in Stuttgart, Norbert Breidohr
in Aachen und J&uuml;rgen Mei&szlig;burger in J&uuml;lich).
Insbesondere letzterer hat sich sehr engagiert, um eine praxisnahe
L&ouml;sung im ZAM zu finden.
<P>
Ach ja, wo wir schon im ZAM sind: Wolfgang E. Nagel hat zwar nichts
direkt mit AS zu tun, immerhin ist er aber mein Chef und wirft
st&auml;ndig vier Augen auf das, was ich tue. Bei AS scheint
zumindest ein lachendes dabei zu sein...
<P>
Ohne Datenb&uuml;cher und Unterlagen zu Prozessoren ist ein Programm
wie AS nicht zu machen. Ich habe von einer enormen Anzahl von Leuten
Informationen bekommen, die von einem kleinen Tip bis zu ganzen
Datenb&uuml;chern reichen. Hier eine Aufz&auml;hlung (wie oben
gesagt, ohne Garantie auf Vollst&auml;ndigkeit!):
<P>
Ernst Ahlers, Charles Altmann, Marco Awater, Len Bayles, Andreas
Bolsch, Rolf Buchholz, Bernd Casimir, Gunther Ewald, Stephan
Hruschka, Peter Kliegelh&ouml;fer, Ulf Meinke, Matthias Paul, Norbert
Rosch, Steffen Schmid, Leonhard Schneider, Ernst Schwab, Michael
Schwingen, Oliver Sellke, Christian Stelter, Patrik Str&ouml;mdahl,
Oliver Thamm, Thorsten Thiele, Andreas Wassatsch, John Weinrich.
<P>
...und ein geh&auml;ssiger Dank an Rolf-Dieter-Klein und Tobias
Thiel, die mit ihren ASM68K demonstrierten, wie man es<B> nicht</B>
machen sollte und mich damit indirekt dazu angeregt haben, etwas
besseres zu schreiben!
<P>
So ganz allein habe ich AS nicht verzapft. AS enth&auml;lt die
OverXMS-Routinen von Wilbert van Leijen, um die Overlay-Module ins
Extended Memory verlagern zu k&ouml;nnen. Eine wirklich feine Sache,
einfach und problemlos anzuwenden!
<P>
Die TMS320C2x/5x-Codegeneratoren sowie die Datei<TT>
STDDEF2x.INC</TT> stammen von Thomas Sailer, ETH Z&uuml;rich.
Erstaunlich, an einem Wochenende hat er es geschafft, durch meinen
Code durchzusteigen und den neuen Generator zu implementieren.
Entweder waren das reichliche Nachtschichten oder ich werde langsam
alt...
<P>

<H1><A NAME="sect_H_">H. &Auml;nderungen seit Version 1.3</A></H1>
<P>
<UL>
<LI> Version 1.31:
<UL>
<LI>     zus&auml;tzlicher MCS-51-Prozessortyp 80515. Die Nummer wird
        wiederum nur vom Assembler verwaltet. Die Datei STDDEF51.INC
        wurde um die dazugeh&ouml;rigen SFRs erweitert.<B>
        ACHTUNG!</B> Einige 80515-SFRs haben sich
        adre&szlig;m&auml;&szlig;ig verschoben!</LI>
<LI>     zus&auml;tzlich Prozessor Z80 unterst&uuml;tzt;</LI>
<LI>     schnellerer 680x0-Codegenerator.</LI>
</UL>
 </LI>
<LI> Version 1.32:
<UL>
<LI>     Schreibweise von Zeropageadressen f&uuml;r 65xx nicht mehr als
        Adr.z, sondern wie beim 68xx als &lt;Adr;</LI>
<LI>     unterst&uuml;tzt die Prozessoren 6800, 6805, 6301 und 6811;</LI>
<LI>     der 8051-Teil versteht jetzt auch<TT> DJNZ</TT>,<TT> PUSH</TT>
        und<TT> POP</TT> (sorry);</LI>
<LI>     im Listing werden neben den Symbolen jetzt auch die definierten
        Makros aufgelistet;</LI>
<LI>     Befehle<TT> IFDEF</TT>/<TT>IFNDEF</TT> f&uuml;r bedingte
        Assemblierung, mit denen sich die Existenz eines Symboles
        abfragen l&auml;&szlig;t;</LI>
<LI>     Befehle<TT> PHASE</TT>/<TT>DEPHASE</TT> zur Unterst&uuml;tzung
        von Code, der zur Laufzeit auf eine andere Adresse verschoben
        werden soll;</LI>
<LI>     Befehle<TT> WARNING</TT>/<TT>ERROR</TT>/<TT>FATAL</TT>, um
        anwenderspezifische Fehlermeldungen ausgeben zu
        k&ouml;nnen;</LI>
<LI>     Die Datei STDDEF51.INC enth&auml;lt zus&auml;tzlich das
        Makro<TT> USING</TT> zur einfacheren Handhabung der
        Registerb&auml;nke der MCS-51er;</LI>
<LI>     Kommandozeilenoption<TT> u</TT>, um Segmentbelegung
        anzuzeigen.</LI>
</UL>
 </LI>
<LI> Version 1.33:
<UL>
<LI>     unterst&uuml;tzt den 6809;</LI>
<LI>     zus&auml;tzlich Stringvariablen;</LI>
<LI>     Die Befehle<TT> TITLE</TT>,<TT> PRTINIT</TT>,<TT>
        PRTEXIT</TT>,<TT> ERROR</TT>,<TT> WARNING</TT> und<TT>
        FATAL</TT> erwarten jetzt einen Stringausdruck als Parameter,
        Konstanten m&uuml;ssen demzufolge nicht mehr in Hochkommas,
        sondern in G&auml;nsef&uuml;&szlig;chen eingeschlossen
        werden. Analoges gilt f&uuml;r<TT> DB</TT>,<TT> DC.B</TT>
        und<TT> BYT</TT>;</LI>
<LI>     Befehl<TT> ALIGN</TT> zur Ausrichtung des Programmz&auml;hlers
        bei Intel- Prozessoren;</LI>
<LI>     Befehl<TT> LISTING</TT>, um die Erzeugung eines Listings ein-
        und ausschalten zu k&ouml;nnen;</LI>
<LI>     Befehl<TT> CHARSET</TT> zur Definition eigener
        Zeichens&auml;tze.</LI>
</UL>
 </LI>
<LI> Version 1.34:
<UL>
<LI>     Wenn im ersten Pass Fehler auftreten, wird gar kein zweiter Pass
        mehr durchgef&uuml;hrt;</LI>
<LI>     neues vordefiniertes Symbol<TT> VERSION</TT>, welches die
        Version von AS enth&auml;lt;</LI>
<LI>     Befehl<TT> MESSAGE</TT>, um Durchsagen und Meldungen
        programmgesteuert zu erzeugen;</LI>
<LI>     Formelparser &uuml;ber Stringkonstanten zug&auml;nglich;</LI>
<LI>     Bei Fehler in Makroexpansionen wird zus&auml;tzlich die laufende
        Zeile im Makro angezeigt;</LI>
<LI>     Funktion<TT> UPSTRING</TT>, um einen String in
        Gro&szlig;buchstaben zu wandeln.</LI>
</UL>
 </LI>
<LI> Version 1.35:
<UL>
<LI>     Funktion<TT> TOUPPER</TT>, um ein einzelnes Zeichen in
        Gro&szlig;buchstaben zu wandeln;</LI>
<LI>     Befehl<TT> FUNCTION</TT>, um eigene Funktionen definieren zu
        k&ouml;nnen;</LI>
<LI>     Kommandozeilenoption<TT> D</TT>, um Symbole von au&szlig;en
        definieren zu k&ouml;nnen;</LI>
<LI>     Fragt die Environment-Variable<TT> ASCMD</TT> f&uuml;r
        h&auml;ufig gebrauchte Optionen ab;</LI>
<LI>     bei gesetzter<TT> u</TT>-Option wird das Programm
        zus&auml;tzlich auf doppelt belegte Speicherbereiche
        abgepr&uuml;ft;</LI>
<LI>     Kommandozeilenoption<TT> C</TT>, um eine Querverweisliste zu
        erzeugen.</LI>
</UL>
 </LI>
<LI> Version 1.36:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Familien PIC 16C5x und
        PIC17C4x;</LI>
<LI>     im Listing wird zus&auml;tzlich die Verschachtelungsebene bei
        Include-Dateien angezeigt;</LI>
<LI>     in der Querverweisliste wird zus&auml;tzlich die Stelle
        angezeigt, an der ein Symbol definiert wurde;</LI>
<LI>     Kommandozeilenoption<TT> A</TT>, um eine kompaktere Ablage der
        Symboltabelle zu erzwingen.</LI>
</UL>
 </LI>
<LI> Version 1.37:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Prozessoren 8086, 80186,
        V30, V35, 8087 und Z180;</LI>
<LI>     Befehle<TT> SAVE</TT> und<TT> RESTORE</TT> zur besseren
        Umschaltung von Flags;</LI>
<LI>     Operatoren zur logischen Verschiebung und Bitspiegelung;</LI>
<LI>     Kommandozeilenoptionen k&ouml;nnen mit einem Pluszeichen negiert
        werden;</LI>
<LI>     Filter<TT> AS2MSG</TT> zur bequemen Arbeit mit AS unter
        Turbo-Pascal 7.0;</LI>
<LI>     <TT>ELSEIF</TT> darf ein Argument zur Bildung von<TT>
        IF-THEN-ELSE</TT>-Leitern haben;</LI>
<LI>     Zur bequemeren bedingten Assemblierung zus&auml;tzlich ein<TT>
        CASE</TT>-Konstrukt;</LI>
<LI>     Selbstdefinierte Funktionen d&uuml;rfen mehr als ein Argument
        haben;</LI>
<LI>     P2HEX kann nun auch Hexfiles f&uuml;r 65er-Prozessoren
        erzeugen;</LI>
<LI>     BIND, P2HEX und P2BIN haben jetzt die gleichen
        Variationsm&ouml;glichkeiten in der Kommandozeile wie
        AS;</LI>
<LI>     Schalter<TT> i</TT> bei P2HEX, um 3 Varianten f&uuml;r den
        Ende-Record einzustellen;</LI>
<LI>     Neue Funktionen<TT> ABS</TT> und<TT> SGN</TT>;</LI>
<LI>     Neue Pseudovariablen<TT> MOMFILE</TT> und<TT> MOMLINE</TT>;</LI>
<LI>     Ausgabem&ouml;glichkeit erweiterter Fehlermeldungen;</LI>
<LI>     Befehle<TT> IFUSED</TT> und<TT> IFNUSED</TT>, um abzufragen, ob
        ein Symbol bisher benutzt wurde;</LI>
<LI>     Die Environment-Variablen<TT> ASCMD</TT>,<TT> BINDCMD</TT> usw.
        k&ouml;nnen auch einen Dateinamen enthalten, in dem f&uuml;r
        die Optionen mehr Platz ist;</LI>
<LI>     P2HEX erzeugt nun die von Microchip vorgegebenen Hex-Formate
        (p4);</LI>
<LI>     mit der Seitenl&auml;ngenangabe 0 k&ouml;nnen automatische
        Seitenvorsch&uuml;be im Listing vollst&auml;ndig
        unterdr&uuml;ckt werden (p4);</LI>
<LI>     neue Kommandozeilenoption<TT> P</TT>, um die Ausgabe des
        Makroprozessors in eine Datei zu schreiben (p4);</LI>
<LI>     in der Kommandozeile definierte Symbole d&uuml;rfen nun auch mit
        einem frei w&auml;hlbaren Wert belegt werden (p5).</LI>
</UL>
 </LI>
<LI> Version 1.38:
<UL>
<LI>     Umstellung auf Mehrpass-Betrieb. Damit kann AS auch bei
        Vorw&auml;rtsreferenzen immer den optimalen Code
        erzeugen;</LI>
<LI>     Der 8051-Teil kennt nun auch die Befehle<TT> JMP</TT> und<TT>
        CALL</TT>;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Toshiba TLCS-900-Reihe
        (p1);</LI>
<LI>     Befehl<TT> ASSUME</TT>, um dem Assembler die Belegung der
        Segmentregister des 8086 mitzuteilen (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST6-Reihe von SGS-Thomson
        (p2);</LI>
<LI>     ..sowie die 3201x-Signalprozessoren von Texas Instruments
        (p2);</LI>
<LI>     Option<TT> F</TT> bei P2HEX, um die automatische Formatwahl
        &uuml;bersteuern zu k&ouml;nnen (p2);</LI>
<LI>     P2BIN kann nun auch durch Angabe von Dollarzeichen Anfang und
        Ende des Adre&szlig;fensters selbstst&auml;ndig festlegen
        (p2);</LI>
<LI>     Der 8048-Codegenerator kennt nun auch die 8041/42-
        Befehlserweiterungen(p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Zilog
        Z8-Mikrokontroller(p3).</LI>
</UL>
 </LI>
<LI> Version 1.39:
<UL>
<LI>     Definitionsm&ouml;glichkeit von Sektionen und lokalen
        Labels;</LI>
<LI>     Kommandozeilenschalter<TT> h</TT>, um Hexadezimalzahlenausgabe
        mit Kleinbuchstaben zu erzwingen;</LI>
<LI>     Variable<TT> MOMPASS</TT>, um die Nummer des augenblicklichen
        Durchganges abfragen zu k&ouml;nnen;</LI>
<LI>     Kommandozeilenschalter<TT> t</TT>, um einzelne Teile des
        Assemblerlistings ausblenden zu k&ouml;nnen;</LI>
<LI>     kennt zus&auml;tzlich die L-Variante der TLCS-900-Reihe von
        Toshiba und die MELPS-7700-Reihe von Mitsubishi (p1);</LI>
<LI>     P2HEX akzeptiert nun auch Dollarzeichen f&uuml;r Start-und
        Endadresse (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS90-Familie von Toshiba
        (p2);</LI>
<LI>     P2HEX kann Daten zus&auml;tzlich im Tektronix- und 16-Bit
        Intel-Hex-Format ausgeben (p2);</LI>
<LI>     bei Adre&szlig;&uuml;berschreitungen gibt P2HEX Warnungen aus
        (p2);</LI>
<LI>     Include-Datei STDDEF96.INC mit Adre&szlig;definitionen f&uuml;r
        die TLCS-900-Reihe (p3);</LI>
<LI>     Befehl<TT> READ</TT>, um Werte w&auml;hrend der Assemblierung
        interaktiv einlesen zu k&ouml;nnen (p3);</LI>
<LI>     Fehlermeldungen werden nicht mehr einfach auf die
        Standardausgabe, sondern auf den von DOS daf&uuml;r
        vorgesehenen Kanal (STDERR) geschrieben (p3);</LI>
<LI>     Der beim 6811-Teil fehlende<TT> STOP</TT>-Befehl ist nun da
        (scusi,p3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die &micro;PD78(C)1x-Familie
        von NEC (p3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den PIC16C84 von Microchip
        (p3);</LI>
<LI>     Kommandozeilenschalter<TT> E</TT>, um die Fehlermeldungen in
        eine Datei umleiten zu k&ouml;nnen (p3);</LI>
<LI>     Die Unklarheiten im 78(C)1x-Teil sind beseitigt (p4);</LI>
<LI>     neben dem MELPS-7700 ist nun auch das ,,Vorbild'' 65816
        vorhanden (p4);</LI>
<LI>     Die ST6-Pseudoanweisung<TT> ROMWIN</TT> wurde entfernt und mit
        in den<TT> ASSUME</TT>-Befehl eingegliedert (p4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 6804 von SGS-Thomson
        (p4);</LI>
<LI>     durch die<TT> NOEXPORT</TT>-Option in der Makrodefinition kann
        nun f&uuml;r jedes Makro einzeln festgelegt werden, ob es in
        der MAC-Datei erscheinen soll oder nicht (p4);</LI>
<LI>     Die Bedeutung von<TT> MACEXP</TT> f&uuml;r Expansionen von
        Makros hat sich wegen der zus&auml;tzlichen<TT>
        NOEXPAND</TT>-Option in der Makrodefinition leicht
        ge&auml;ndert (p4);</LI>
<LI>     Durch die<TT> GLOBAL</TT>-Option in der Makrodefinition
        k&ouml;nnen nun zus&auml;tzlich Makros definiert werden, die
        durch ihren Sektionsnamen eindeutig gekennzeichnet sind
        (p4).</LI>
</UL>
 </LI>
<LI> Version 1.40:
<UL>
<LI>     unterst&uuml;tzt zus&auml;tzlich den DSP56000 von Motorola;</LI>
<LI>     P2BIN kann nun auch das untere bzw. obere Wort aus
        32-Bit-W&ouml;rtern abtrennen;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS-870- und
        TLCS-47-Familie von Toshiba(p1);</LI>
<LI>     mit einem vorangestelltem ! kann man durch Makros ,,verdeckte''
        Maschinenbefehle wieder erreichen(p1);</LI>
<LI>     mit der<TT> GLOBAL</TT>-Anweisung lassen sich Symbolnamen nun
        auch qualifiziert exportieren(p1);</LI>
<LI>     mit der<TT> r</TT>-Option kann man sich nun eine Liste der
        Stellen erzeugen lassen, die zus&auml;tzliche Durchl&auml;ufe
        erzwangen(p1);</LI>
<LI>     bei der<TT> E</TT>-Option kann nun die Dateiangabe weggelassen
        werden, so da&szlig; ein passender Default gew&auml;hlt
        wird(p1);</LI>
<LI>     mit der<TT> t</TT>-Option kann nun die Zeilennumerierung im
        Listing abgeschaltet werden(p1);</LI>
<LI>     Escapesequenzen sind nun auch in in ASCII geschriebenen
        Integerkonstanten zul&auml;ssig(p1);</LI>
<LI>     Mit dem Pseudobefehl<TT> PADDING</TT> kann das Einf&uuml;gen von
        F&uuml;llbytes im 680x0-Modus ein- und ausgeschaltet werden
        (p2);</LI>
<LI>     <TT>ALIGN</TT> ist nun f&uuml;r alle Zielplattformen erlaubt
        (p2);</LI>
<LI>     kennt zus&auml;tzlich die PIC16C64-SFRs (p2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 8096 von Intel (p2);</LI>
<LI>     Bei<TT> DC</TT> kann zus&auml;tzlich ein Wiederholungsfaktor
        angegeben werden (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C2x-Familie von Texas
        Instruments (Implementierung von Thomas Sailer, ETH
        Z&uuml;rich, r3); P2HEX ist auch entsprechend erweitert;</LI>
<LI>     statt<TT> EQU</TT> darf nun auch einfach ein Gleichheitszeichen
        benutzt werden (r3);</LI>
<LI>     zur Definition von Aufz&auml;hlungen zus&auml;tzlich ein<TT>
        ENUM</TT>-Befehl (r3);</LI>
<LI>     <TT>END</TT> hat jetzt auch eine Wirkung (r3);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> n</TT>, um zu
        Fehlermeldungen zus&auml;tzlich die internen Fehlernummern zu
        erhalten (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TLCS-9000er von Toshiba
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS370xxx-Reihe von Texas
        Instuments, wobei als neuer Pseudobefehl<TT> DBIT</TT>
        hinzukam (r5);</LI>
<LI>     kennt zus&auml;tzlich die DS80C320-SFRs (r5);</LI>
<LI>     der Makroprozessor kann nun auch Includes aus Makros heraus
        einbinden, wozu das Format von Fehlermeldungen aber leicht
        ge&auml;ndert werden mu&szlig;te. Falls Sie AS2MSG verwenden,
        ersetzen Sie es unbedingt durch die neue Version! (r5)</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 80C166 von Siemens
        (r5);</LI>
<LI>     zus&auml;tzlich eine<TT> VAL</TT>-Funktion, um
        Stringausdr&uuml;cke auswerten zu k&ouml;nnen (r5);</LI>
<LI>     Mithilfe von in geschweiften Klammern eingeschlossenen
        Stringvariablen lassen sich nun selber Symbole definieren
        (r5);</LI>
<LI>     kennt zus&auml;tzlich die Eigenheiten des 80C167 von Siemens
        (r6);</LI>
<LI>     jetzt gibt es f&uuml;r die MELPS740-Reihe auch die
        special-page-Adressierung (r6);</LI>
<LI>     mit eckigen Klammern kann man explizit Symbole aus einer
        bestimmten Sektion ansprechen. Die Hilfskonstruktion mit dem
        Klammeraffen gibt es nicht mehr (r6)!</LI>
<LI>     kennt zus&auml;tzlich die MELPS-4500-Reihe von Mitsubishi
        (r7);</LI>
<LI>     kennt zus&auml;tzlich die H8/300 und H8/300H-Prozessoren von
        Hitachi (r7);</LI>
<LI>     die mit<TT> LISTING</TT> und<TT> MACEXP</TT> gemachten
        Einstellungen lassen sich nun auch wieder aus gleichnamigen
        Symbolen auslesen (r7);</LI>
<LI>     kennt zus&auml;tzlich den TMS320C3x von Texas Instruments
        (r8);</LI>
<LI>     kennt zus&auml;tzlich den SH7000 von Hitachi (r8);</LI>
<LI>     der Z80-Teil wurde um die Unterst&uuml;tzung des Z380 erweitert
        (r9);</LI>
<LI>     der 68K-Teil wurde um die feinen Unterschiede der
        683xx-Mikrokontroller erweitert (r9);</LI>
<LI>     ein Label mu&szlig; nun nicht mehr in der ersten Spalte
        beginnen, wenn man es mit einem Doppelpunkt versieht
        (r9);</LI>
<LI>     kennt zus&auml;tzlich die 75K0-Reihe von NEC (r9);</LI>
<LI>     mit dem neuen Kommandozeilenschalter o kann der Name der
        Code-Datei neu festgelegt werden (r9);</LI>
<LI>     der ~~-Operator ist in der Rangfolge auf einen sinnvolleren
        Platz gerutscht (r9);</LI>
<LI>     <TT>ASSUME</TT> ber&uuml;cksichtigt f&uuml;r den 6809 jetzt auch
        das DPR-Register und seine Auswirkungen (pardon, r9);</LI>
<LI>     Der 6809-Teil kennt nun auch die versteckten Erweiterungen des
        6309 (r9);</LI>
<LI>     Bin&auml;rkonstanten k&ouml;nnen jetzt auch in C-artiger
        Notation geschrieben werden (r9).</LI>
</UL>
 </LI>
<LI> Version 1.41:
<UL>
<LI>     &uuml;ber das Symbol<TT> MOMSEGMENT</TT> kann der momentan
        gesetzte Adre&szlig;raum abgefragt werden;</LI>
<LI>     anstelle von<TT> SET</TT> bzw.<TT> EVAL</TT> kann jetzt auch
        einfach<TT> :=</TT> geschrieben werden;</LI>
<LI>     mit der neuen Kommandozeilenoption<TT> q</TT> kann ein
        ,,stiller'' Assemblerlauf erzwungen werden;</LI>
<LI>     das Schl&uuml;sselwort<TT> PARENT</TT> zum Ansprechen der
        Vatersektion wurde um<TT> PARENT0...PARENT9</TT>
        erweitert;</LI>
<LI>     der PowerPC-Teil wurde um die Mikrokontroller-Versionen MPC505
        und PPC403 erweitert;</LI>
<LI>     mit<TT> SET</TT> oder<TT> EQU</TT> definierte Symbole
        k&ouml;nnen nun einem bestimmten Adre&szlig;raum zugeordnet
        werden;</LI>
<LI>     mit<TT> SET</TT> oder<TT> EQU</TT> definierte Symbole
        k&ouml;nnen nun einem bestimmten Adre&szlig;raum zugeordnet
        werden;</LI>
<LI>     durch das Setzen der Environment-Variablen<TT> USEANSI</TT> kann
        die Verwendung von ANSI-Bildschirmsteuersequenzen an-und
        ausgeschaltet werden (r1);</LI>
<LI>     der SH7000-Teil kennt jetzt auch die SH7600-Befehlserweiterungen
        (und sollte jetzt korrekte Displacements berechnen...)
        (r1).</LI>
<LI>     im 65XX-Teil wird jetzt zwischen 65C02 und 65SC02 unterschieden
        (r1);</LI>
<LI>     neben der Variablen<TT> MOMCPU</TT> gibt es jetzt auch den
        String<TT> MOMCPUNAME</TT>, der den Prozessornamen im
        Volltext enth&auml;lt (r1).</LI>
<LI>     P2HEX kennt jetzt auch die 32-Bit-Variante des
        Intel-Hex-Formates (r1);</LI>
<LI>     kennt jetzt auch die Einschr&auml;nkungen des 87C750 (r2);</LI>
<LI>     die Nummern f&uuml;r fatale Fehlermeldungen wurden auf den
        Bereich ab 10000 verschoben, um Platz f&uuml;r normale
        Fehlermeldungen zu schaffen (r2);</LI>
<LI>     unbenutzte Symbole werden in der Symboltabelle jetzt mit einem
        Stern gekennzeichnet (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 29K-Familie von AMD
        (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die M16-Familie von Mitsubishi
        (r2);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die H8/500-Familie von Hitachi
        (r3);</LI>
<LI>     die Anzahl von Datenbytes, die P2HEX pro Zeile ausgibt, ist
        jetzt variierbar (r3);</LI>
<LI>     der Pass, ab dem durch die<TT> -r</TT>-Option erzeugte Warnungen
        ausgegeben werden, ist einstellbar (r3);</LI>
<LI>     der Makroprozessor kennt jetzt ein<TT> WHILE</TT>-Statement, mit
        dem ein Code-St&uuml;ck eine variable Anzahl wiederholt
        werden kann (r3);</LI>
<LI>     der<TT> PAGE</TT>-Befehl erlaubt es nun auch, die Breite des
        Ausgabemediums f&uuml;rs Listing anzugeben (r3);</LI>
<LI>     Um neue Pseudo-Prozessortypen einf&uuml;hren zu k&ouml;nnen,
        lassen sich jetzt CPU-Aliasse definieren (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die MCS/251-Familie von Intel
        (r3);</LI>
<LI>     bei eingeschalteter Querverweisliste wird bei doppelt
        definierten Symbolen die Stelle der ersten Definition
        angezeigt (r3);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C5x-Familie von Texas
        Instruments (Implementierung von Thomas Sailer, ETH
        Z&uuml;rich, r3);</LI>
<LI>     die OS/2-Version sollte jetzt auch mit langen Dateinamen
        klarkommen. Wenn man nicht jeden Mist selber kontrolliert...
        (r3)</LI>
<LI>     &uuml;ber den Befehl<TT> BIGENDIAN</TT> kann im MCS-51/251-Modus
        jetzt gew&auml;hlt werden, ob die Ablage von Konstanten im
        Big- oder Little-Endian-Format erfolgen soll (r3);</LI>
<LI>     es wird beim 680x0 jetzt zwischen dem vollen und
        eingeschr&auml;nkten MMU-Befehlssatz unterschieden; eine
        manuelle Umschaltung ist mit dem<TT> FULLPMMU</TT>-Befehl
        m&ouml;glich (r3);</LI>
<LI>     &uuml;ber die neue Kommandozeilenoption<TT> I</TT> kann eine
        Liste aller eingezogenen Include-Files mit ihrer
        Verschachtelung ausgegeben werden (r3);</LI>
<LI>     Beim<TT> END</TT>-Statement kann jetzt zus&auml;tzlich ein
        Einsprungpunkt f&uuml;r das Programm angegeben werden
        (r3).</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC16-Familie von Motorola
        (r3);</LI>
<LI>     P2HEX und P2BIN erlauben es jetzt, den Inhalt einer Code-Datei
        adre&szlig;m&auml;&szlig;ig zu verschieben (r4);</LI>
<LI>     einem<TT> SHARED</TT>-Befehl anh&auml;ngende Kommentare werden
        jetzt in die Share-Datei mit &uuml;bertragen (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC12-Familie von Motorola
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die XA-Familie von Philips
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 68HC08-Familie von Motorola
        (r4);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die AVR-Familie von Atmel
        (r4);</LI>
<LI>     aus Kompatibilit&auml;t zum AS11 von Motorola existieren
        zus&auml;tzlich die Befehle<TT> FCB</TT>,<TT> FDB</TT>,<TT>
        FCC</TT> und<TT> RMB</TT> (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den M16C von Mitsubishi
        (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den COP8 von National
        Semiconductor (r5);</LI>
<LI>     zwei neue Befehle zur bedingten Assemblierung:<TT> IFB</TT>
        und<TT> IFNB</TT> (r5);</LI>
<LI>     Mit dem<TT> EXITM</TT>-Befehl ist es nun m&ouml;glich, eine
        Makroexpansion vorzeitig abzubrechen (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den MSP430 von Texas
        Instruments (r5);</LI>
<LI>     <TT>LISTING</TT> kennt zus&auml;tzlich die Varianten<TT>
        NOSKIPPED</TT> und<TT> PURECODE</TT>, um nicht assemblierten
        Code aus dem Listing auszublenden (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 78K0-Familie von NEC
        (r5);</LI>
<LI>     BIGENDIAN ist jetzt auch im PowerPC-Modus verf&uuml;gbar
        (r5);</LI>
<LI>     zus&auml;tzlich ein<TT> BINCLUDE</TT>-Befehl, um Bin&auml;rdaten
        einbinden zu k&ouml;nnen (r5);</LI>
<LI>     zus&auml;tzliche TOLOWER- und LOWSTRING-Funktionen, um
        Gro&szlig;- in Kleinbuchstaben umzuwandeln (r5);</LI>
<LI>     es ist jetzt m&ouml;glich, auch in anderen Segmenten als CODE
        Daten abzulegen. Das Dateiformat wurde entsprechend erweitert
        (r5);</LI>
<LI>     der<TT> DS</TT>-Befehl, mit dem man Speicherbereiche reservieren
        kann, ist jetzt auch im Intel-Modus zul&auml;ssig (r5);</LI>
<LI>     Mit der Kommandozeilenoption<TT> U</TT> ist es jetzt
        m&ouml;glich, AS in einen case-sensitiven Modus umzuschalten,
        in dem Namen von Symbolen, selbstdefinierten Funktionen,
        Makros, Makroparametern sowie Sektionen nach Gro&szlig;- und
        Kleinschreibung unterschieden werden (r5);</LI>
<LI>     <TT>SFRB</TT> ber&uuml;cksichtigt jetzt auch die Bildungsregeln
        f&uuml;r Bitadressen im RAM-Bereich; werden nicht
        bitadressierbare Speicherstellen angesprochen, erfolgt eine
        Warnung (r5);</LI>
<LI>     zus&auml;tzliche Pseudobefehle<TT> PUSHV</TT> und<TT> POPV</TT>,
        um Symbolwerte tempor&auml;r zu sichern (r5);</LI>
<LI>     zus&auml;tzliche Funktionen<TT> BITCNT, FIRSTBIT, LASTBIT</TT>
        und<TT> BITPOS</TT> zur Bitverarbeitung (r5);</LI>
<LI>     bei den CPU32-Prozessoren ist jetzt auch der 68360
        ber&uuml;cksichtigt (r5);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST9-Familie von SGS-Thomson
        (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den SC/MP von National
        Semiconductor (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS70Cxx-Familie von Texas
        Instruments (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS9900-Familie von Texas
        Instruments (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Befehlssatzerweiterungen
        des 80296 (r6);</LI>
<LI>     die unterst&uuml;tzten Z8-Derivate wurden erweitert (r6);</LI>
<LI>     ber&uuml;cksichtigt zus&auml;tzlich die Maskenfehler des 80C504
        von Siemens (r6);</LI>
<LI>     zus&auml;tzliche Registerdefinitionsdatei f&uuml;r die
        C50x-Prozessoren von Siemens (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ST7-Familie von SGS-Thomson
        (r6);</LI>
<LI>     die Intel-Pseudobefehle zur Datenablage sind jetzt auch f&uuml;r
        65816 bzw. MELPS-7700 zul&auml;ssig (r6);</LI>
<LI>     f&uuml;r 65816/MELPS-7700 kann die Adre&szlig;l&auml;nge jetzt
        durch Pr&auml;fixe explizit festgelegt werden (r6);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 8X30x-Familie von Signetics
        (r6);</LI>
<LI>     <TT>PADDING</TT> ist nur noch f&uuml;r die 680x0-Familie
        defaultm&auml;&szlig;ig eingeschaltet (r7);</LI>
<LI>     &uuml;ber das neu eingef&uuml;hrte, vordefinierte Symbol<TT>
        ARCHITECTURE</TT> kann ausgelesen werden, f&uuml;r welche
        Plattform AS &uuml;bersetzt wurde (r7);</LI>
<LI>     Zus&auml;tzliche Anweisungen<TT> STRUCT</TT> und<TT>
        ENDSTRUCT</TT> zur Definition von Datenstrukturen (r7);</LI>
<LI>     Hex- und Objekt-Dateien f&uuml;r die AVR-Tools k&ouml;nnen jetzt
        direkt erzeugt werden (r7);</LI>
<LI>     <TT>MOVEC</TT> kennt jetzt auch die 68040-Steuerregister
        (r7);</LI>
<LI>     zus&auml;tzliche<TT> STRLEN</TT>-Funktion, um die L&auml;nge
        eines Strings zu ermitteln (r7);</LI>
<LI>     M&ouml;glichkeit zur Definition von Registersymbolen (r7,
        momentan nur Atmel AVR);</LI>
<LI>     kennt zus&auml;tzlich die undokumentierten 6502-Befehle
        (r7);</LI>
<LI>     P2HEX und P2BIN k&ouml;nnen jetzt optional die Eingabedateien
        automatisch l&ouml;schen (r7);</LI>
<LI>     P2BIN kann der Ergebnisdatei optional zus&auml;tzlich die
        Startadresse voranstellen (r7);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ColdFire-Familie von
        Motorola als Variation des 680x0-Kerns (r7);</LI>
<LI>     <TT>BYT/FCB, ADR/FDB</TT> und<TT> FCC</TT> erlauben jetzt auch
        den von<TT> DC</TT> her bekannten Wiederholungsfaktor
        (r7);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den M*Core von Motorola
        (r7);</LI>
<LI>     der SH7000-Teil kennt jetzt auch die SH7700-Befehlserweiterungen
        (r7);</LI>
<LI>     der 680x0-Teil kennt jetzt auch die zus&auml;tzlichen Befehle
        des 68040 (r7);</LI>
<LI>     der 56K-Teil kennt jetzt auch die Befehlserweiterungen bis zum
        56300 (r7).</LI>
<LI>     Mit der neuen<TT> CODEPAGE</TT>-Anweisung k&ouml;nnen jetzt auch
        mehrere Zeichentabellen gleichzeitig verwaltet werden
        (r8);</LI>
<LI>     Die Argumentvarianten f&uuml;r<TT> CHARSET</TT> wurden erweitert
        (r8);</LI>
<LI>     Neue String-Funktionen<TT> SUBSTR</TT> und<TT> STRSTR</TT>
        (r8);</LI>
<LI>     zus&auml;tzliches<TT> IRPC</TT>-Statement im Makroprozessor
        (r8);</LI>
<LI>     zus&auml;tzlicher<TT> RADIX</TT>-Befehl, um das
        Default-Zahlensystem f&uuml;r Integer-Konstanten festzulegen
        (r8);</LI>
<LI>     statt<TT> ELSEIF</TT> darf auch einfach<TT> ELSE</TT>
        geschrieben werden (r8);</LI>
<LI>     statt = darf als Gleichheitsoperator auch == geschrieben werden
        (r8);</LI>
<LI>     <TT>BRANCHEXT</TT> erlaubt es beim Philips XA jetzt, die
        Sprungweite von kurzen Spr&uuml;ngen automatisch zu erweitern
        (r8);</LI>
<LI>     Debug-Ausgaben sind jetzt auch im NoICE-Format m&ouml;glich
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die i960-Familie von Intel
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die
        &micro;PD7720/7725-Signalprozssoren von NEC (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den
        &micro;PD77230-Signalprozssor von NEC (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die SYM53C8xx-SCSI-Prozessoren
        von Symbios Logic (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 4004 von Intel (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die SC14xxx-Serie von National
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die Befehlserweiterungen des
        PPC403GC (r8);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> cpu</TT>, um den
        Zielprozessor-Default zu setzen (r8);</LI>
<LI>     Key-Files k&ouml;nnen jetzt auch von der Kommandozeile aus
        referenziert werden (r8);</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> shareout</TT>, um die
        Ausgabedatei f&uuml;r SHARED-Definitionen zu setzen
        (r8);</LI>
<LI>     neuer Pseudobefehl<TT> WRAPMODE</TT>, um AVR-Prozessoren mit
        verk&uuml;rztem Programmz&auml;hler zu unterst&uuml;tzen
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die C20x-Befehlsuntermenge im
        C5x-Teil (r8);</LI>
<LI>     hexadezimale Adre&auml;ngaben der Hilfsprogamme k&ouml;nnen
        jetzt auch in C-Notation gemacht werden (r8);</LI>
<LI>     Das Zahlensystem f&uuml;r Integerergebnisse in \{...}-
        Ausdr&uuml;cken ist jetzt per<TT> OUTRADIX</TT> setzbar
        (r8);</LI>
<LI>     Die Registersyntax f&uuml;r 4004-Registerpaare wurde korrigiert
        (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die F<SUP>2</SUP>MC8L-Familie
        von Fujitsu (r8);</LI>
<LI>     f&uuml;r P2HEX kann jetzt die Minimall&auml;nge f&uuml;r
        S-Record-Adressen angegeben werden (r8);</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die ACE-Familie von Fairchild
        (r8);</LI>
<LI>     <TT> REG</TT> ist jetzt auch f&uuml;r PowerPCs erlaubt
        (r8);</LI>
<LI>     zus&auml;tzlicher Schalter in P2HEX, um alle Adressen zu
        verschieben (r8);</LI>
<LI>     Mit dem Schalter<TT> x</TT> kann man jetzt zus&auml;tzlich in
        einer zweiten Stufe bie betroffene Quellzeile ausgeben
        (r8).</LI>
</UL>
 </LI>
<LI> Version 1.42:
<UL>
<LI>     Die Default-Zahlensyntax f&uuml;r Atmel AVR ist jetzt
        C-Syntax;</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> olist</TT>, um die
        Listing-Ausgabedatei zu setzen;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die F<SUP>2</SUP>MC16L-Familie
        von Fujitsu;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> PACKING</TT> f&uuml;r die
        AVR-Familie;</LI>
<LI>     zus&auml;tzliche implizite Makroparameter<TT> ALLARGS</TT>
        und<TT> ARGCOUNT</TT>;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> SHIFT</TT> zum Abarbeiten variabler
        Argumentlisten von Makros;</LI>
<LI>     unterst&uuml;tzt tempor&auml;re Symbole;</LI>
<LI>     zus&auml;tzlicher Befehl<TT> MAXNEST</TT> zum Einstellen der
        maximalen Verschachtelungstiefe von Makroexpansionen;</LI>
<LI>     zus&auml;tzliche Kommandozeilenoption<TT> noicemask</TT>, um die
        Menge der in einem NoICE-Debuginfofile gelisteten Segmente zu
        steuern;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 180x-Familie von
        Intersil;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich das address windowing des
        68HC11K4;</LI>
<LI>     P2HEX kann jetzt die Adre&szlig;feldl&auml;nge von
        AVR-Hex-Dateien variieren;</LI>
<LI>     mit der neuen Kommandozeilenoption<TT> -gnuerrors</TT>
        k&ouml;nnen Fehlermeldungen in einem GNU-C-artigen Format
        ausgegeben werden;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die TMS320C54x-Familie von
        Texas Instruments;</LI>
<LI>     Neue Makro-Option<TT> INTLABEL</TT>;</LI>
<LI>     die neuen Instruktionen und Register der MEGA-AVRs 8/16 wurden
        hinzugef&uuml;gt;</LI>
<LI>     <TT> ENDIF/ENDCASE</TT> zeigen im Listing die Zeilennummer des
        zugeh&ouml;rigen &ouml;ffnenden Befehls an;</LI>
<LI>     der 8051-Teil unterst&uuml;tzt jetzt auch den erweiterten
        Adre&szlig;raum des Dallas DS80C390;</LI>
<LI>     namenlose tempor&auml;re Symbole hinzugef&uuml;gt;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die undokumentierten
        8085-Befehle;</LI>
<LI>     verbesserte Behandlung von Strukturen;</LI>
<LI>     Funktion EXPRTYPE() hinzugef&uuml;gt;</LI>
<LI>     Zeilenfortsetzungszeichen zulassen;</LI>
<LI>     Unterst&uuml;tzung f&uuml;r KCPSM/PicoBlaze von Andreass
        Wassatsch integriert;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 807x-Familie von National
        Semiconductor;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 4040 von Intel;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den eZ8 von Zilog;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 78K2-Familie von NEC;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die KCPSM3-Variante von
        Xilinx;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den LatticeMico8;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die 12X-Befehlserweiterungen
        und den XGATE-Kern der 68HC12-Familie;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den Signetics 2650;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die COP4-Familie von National
        Semiconductor;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die HCS08-Erweiterungen von
        Freescale;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich die RS08-Familie von
        Freescale;</LI>
<LI>     unterst&uuml;tzt zus&auml;tzlich den 8008 von Intel;</LI>
<LI>     weitere Syntax f&uuml;r Integer-Konstanten;</LI>
<LI>     Funktion<TT> CHARFROMSTR</TT> hinzugef&uuml;gt;</LI>
<LI>     Q f&uuml;r Oktalkonstanten im Intel-Modus hinzugef&uuml;gt;</LI>
<LI>     weitere Variante f&uuml;r tempor&auml;re Symbole
        hinzugef&uuml;gt;</LI>
</UL>
 </LI>
</UL>
<P>

<H1><A NAME="sect_I_">I. Hinweise zum Quellcode von AS</A></H1>
<A NAME="ref_ChapSource"></A>
<P>
Wie in der Einleitung erw&auml;hnt, gebe ich nach R&uuml;cksprache
den Quellcode von AS heraus. Im folgenden sollen einige Hinweise zu
dessen Handhabung gegeben werden.
<P>

<H2><A NAME="sect_I_1_">I.1. Verwendete Sprache</A></H2>
<P>
Urspr&uuml;nglich war AS ein in Turbo-Pascal geschriebenes Programm.
F&uuml;r diese Entscheidung gab es Ende der 80er Jahre eine Reihe von
Gr&uuml;nden: Zum einen war ich damit wesentlich vertrauter als mit
jedem C-Compiler, zum anderen waren alle C-Compiler unter DOS
verglichen mit der IDE von Turbo-Pascal ziemliche Schnecken. Anfang
1997 zeichnete sich jedoch ab, da&szlig; sich das Blatt gewendet
hatte: Zum einen hatte Borland beschlossen, die DOS-Entwickler im
Stich zu lassen (nochmals ausdr&uuml;cklich keinen sch&ouml;nen Dank,
Ihr Pappnasen von Borland!), und Version 7.0 etwas namens 'Delphi'
nachfolgen lie&szlig;en, was zwar wohl wunderbar f&uuml;r
Windows-Programme geeignet ist, die zu 90% aus Oberfl&auml;che und
zuf&auml;llig auch ein bi&szlig;chen Funktion bestehen, f&uuml;r
kommandozeilenorientierte Progamme wie AS aber reichlich unbrauchbar
ist. Zum anderen hatte sich bereits vor diesem Zeitpunkt mein
betriebssystemm&auml;&szlig;iger Schwerpunkt deutlich in Richtung
Unix verschoben, und auf ein Borland-Pascal f&uuml;r Linux h&auml;tte
ich wohl beliebig lange warten k&ouml;nnen (an alle die, die jetzt
sagen, Borland w&uuml;rde ja an soetwas neuerdings basteln: Leute,
das ist<EM> Vapourware</EM>, und glaubt den Firmen nichts, solange
Ihr nicht wirklich in den Laden gehen und es kaufen k&ouml;nnt!). Von
daher war also klar, da&szlig; der Weg in Richtung C gehen
mu&szlig;te.
<P>
Nach der Erfahrung, wohin die Verwendung von Inselsystemen
f&uuml;hrt, habe ich bei der Umsetzung auf C Wert auf eine
m&ouml;glichst gro&szlig;e Portabilit&auml;t gelegt; da AS jedoch
z.B. Bin&auml;rdateien in einem bestimmten Format erzeugen mu&szlig;
und an einigen Stellen betriebssystemspezifische Funktionen nutzt,
gibt es einige Stellen, an denen man anpassen mu&szlig;, wenn man AS
zum ersten Mal auf einer neuen Plattform &uuml;bersetzt.
<P>
AS ist auf einen C-Compiler ausgelegt, der dem ANSI-Standard
entspricht; C++ ist ausdr&uuml;cklich nicht erforderlich. Wenn Sie
nur einen Compiler nach dem veralteten Kernighan&amp;Ritchie-Standard
besitzen, sollten Sie sich nach einem neuen Compiler umsehen; der
ANSI-Standard ist seit 1989 verabschiedet und f&uuml;r jede aktuelle
Plattform sollte ein ANSI-Compiler verf&uuml;gbar sein, zur Not,
indem man mit dem alten Compiler GNU-C baut. Im Quellcode sind zwar
einige Schalter vorhanden, um den Code K&amp;R-n&auml;her zu machen,
aber dies ist ein nicht offiziell unterst&uuml;tztes Feature, das ich
nur intern f&uuml;r ein ziemlich antikes Unix benutze. Alles weitere
zum 'Thema K&amp;R' steht in der Datei<TT> README.KR</TT>.
<P>
Der Sourcenbaum ist durch einige in der Pascal-Version nicht
vorhandene Features (z.B. dynamisch ladbare Nachrichtendateien,
Testsuite, automatische Generierung der Dokumentation aus<EM>
einem</EM> Quellformat) deutlich komplizierter geworden. Ich werde
versuchen, die Sache Schritt f&uuml;r Schritt aufzudr&ouml;seln:
<P>

<H2><A NAME="sect_I_2_">I.2. Abfangen von Systemabh&auml;ngigkeiten</A></H2>
<P>
Wie ich schon andeutete, ist AS (glaube ich jedenfalls...) auf
Plattformunabh&auml;ngigkeit und leichte Portierbarkeit getrimmt.
Dies bedeutet, da&szlig; man die Plattformunabh&auml;ngigkeiten in
m&ouml;glichst wenige Dateien zusammenzieht. Auf diese Dateien werde
ich im folgenden eingehen, und dieser Abschnitt steht ganz vorne,
weil es sicher eines der wichtigsten ist:
<P>
Die Generierung aller Komponenten von AS erfolgt &uuml;ber ein
zentrales<TT> Makefile</TT>. Damit dies funktioniert, mu&szlig; man
ihm ein passendes<TT> Makefile.def</TT> anbieten, das die
plattformabh&auml;ngigen Einstellungen wie z.B. Compilerflags
vorgibt. Im Unterverzeichnis<TT> Makefile.def-samples</TT> finden
sich eine Reihe von Includes, die f&uuml;r g&auml;ngige Plattformen
funktionieren (aber nicht zwangsweise optimal sein m&uuml;ssen...).
Wenn die von Ihnen benutzte Plattform nicht dabei ist, k&ouml;nnen
Sie die Beispieldatei<TT> Makefile.def.tmpl</TT> als Ausgangspunkt
verwenden (und das Ergebnis mir zukommen lassen!).
<P>
Ein weiterer Anlaufpunkt zum Abfangen von Systemabh&auml;ngigkeiten
ist die Datei<TT> sysdefs.h</TT>. Praktisch alle Compiler definieren
eine Reihe von Pr&auml;prozessorsymbolen vor, die den benutzten
Zielprozessor sowie das benutzte Betriebsystem beschreiben. Auf einer
Sun Sparc unter Solaris mit den GNU-Compiler sind dies z.B. die
Symbole __sparc und __SVR4. In<TT> sysdefs.h</TT> werden diese
Symbole genutzt, um f&uuml;r die restlichen, systemunabh&auml;ngigen
Dateien eine einheitliche Ungebung bereitzustellen. Insbesondere
betrifft dies Integer-Datentypen einer bekannten L&auml;nge, es kann
aber auch die Nach- oder Redefinition von C-Funktionen betreffen, die
auf einer bestimmten Plattform nicht oder nicht
standardgem&auml;&szlig; vorhanden sind. Was da so an Sachen
anf&auml;llt, liest man am besten selber nach. Generell sind die
#ifdef-Statements in zwei Ebenen gegliedert: Zuerst wird eine
bestimmte Prozessorplattform ausgew&auml;hlt, dann werden in diesem
Abschnitt die Betriebssysteme auseinandersortiert.
<P>
Wenn Sie AS auf eine neue Plattform portieren, m&uuml;ssen Sie zwei
f&uuml;r diese Plattform typische Symbole finden und<TT>
sysdefs.h</TT> passend erweitern (und wieder bin ich an dem Ergebnis
interessiert...).
<P>

<H2><A NAME="sect_I_3_">I.3. Systemunabh&auml;ngige Dateien</A></H2>
<P>
...stellen den g&ouml;&szlig;ten Teil aller Module dar. Alle
Funktionen im Detail zu beschreiben, w&uuml;rde den Rahmen dieser
Beschreibung sprengen (wer hier mehr wissen will, steigt am besten
selbst in das Studium der Quellen ein, so katastrophal ist mein
Programmierstil nun auch wieder nicht...), deshalb hier nur eine
kurze Auflistung, welche Module vorhanden sind und was f&uuml;r
Funktionen sie beinhalten:
<P>

<H3><A NAME="sect_I_3_1_">I.3.1. Von AS genutzte Module</A></H3>
<P>

<H4>as.c</H4>
<P>
Diese Datei ist die Wurzel von AS: Sie enth&auml;lt die<EM>
main()</EM>-Funktion von AS, die Verarbeitung aller
Kommandozeilenoptionen, die &uuml;bergeordnete Steuerung aller
Durchl&auml;ufe durch die Quelldateien sowie Teile des
Makroprozessors.
<P>

<H4>asmallg.c</H4>
<P>
In diesem Modul werden all die Befehle bearbeitet, die f&uuml;r alle
Prozessoren definiert sind, z.B.<TT> EQU</TT> und<TT> ORG</TT>. Hier
findet sich auch der<TT> CPU</TT>-Befehl, mit dem zwischen den
einzelnen Prozessoren hin- und hergeschaltet wird.
<P>

<H4>asmcode.c</H4>
<P>
In diesem Modul befindet sich die Verwaltung der Code-Ausgabedatei.
Exportiert wird ein Interface, mit dem sich eine Code-Datei
&ouml;ffnen und schlie&szlig;en l&auml;&szlig;t, und das Routinen zum
Einschreiben (und Zur&uuml;cknehmen) von Code anbietet. Eine wichtige
Aufgabe dieses Moduls ist die Pufferung des Schreibvorgangs, die die
Ausgabegeschwindigkeit erh&ouml;ht, indem der erzeugte Code in
gr&ouml;&szlig;eren Bl&ouml;cken geschrieben wird.
<P>

<H4>asmdebug.c</H4>
<P>
Optional kann AS Debug-Informationen f&uuml;r andere Tools wie
Simulatoren oder Debugger erzeugen, die einen R&uuml;ckbezug auf den
Quellcode erlauben, in diesem Modul gesammelt und nach Ende der
Assemblierung in einem von mehreren Formaten ausgegeben werden
k&ouml;nnen.
<P>

<H4>asmdef.c</H4>
<P>
Dieses Modul enth&auml;lt lediglich Deklarationen von &uuml;berall
ben&ouml;tigten Konstanten und gemeinsam benutzten Variablen.
<P>

<H4>asmfnums.c</H4>
<P>
Intern vergibt AS f&uuml;r jede benutzte Quelldatei eine fortlaufende
Nummer, die zur schnellen Referenzierung benutzt wird. Die Vergabe
dieser Nummern und die Umwandlung zwischen Nummer und Dateinamen
passiert hier.
<P>

<H4>asmif.c</H4>
<P>
Hier befinden sich alle Routinen, die die bedingte Assemblierung
steuern. Exportiert wird als wichtigste Variable das Flag<TT>
IfAsm</TT>, welches anzeigt, ob Codeerzeugung momentan ein- oder
ausgeschaltet ist.
<P>

<H4>asminclist.c</H4>
<P>
In diesem Modul ist die Listenstruktur definiert, &uuml;ber die AS
die Verschachtelung von Include-Dateien im Listing ausgeben kann.
<P>

<H4>asmitree.c</H4>
<P>
Wenn man in einer Code-Zeile das benutzende Mnemonic ermitteln will,
ist das einfache Durchvergleichen mit allen vorhandenen Befehlen (wie
es noch in vielen Codegeneratoren aus Einfachheit und Faulheit
passiert) nicht unbedingt die effizienteste Variante. In diesem Modul
sind zwei verbesserte Strukturen (Bin&auml;rbaum und Hash-Tabelle)
definiert, die eine effizientere Suche erm&ouml;glichen und die
einfache lineare Suche nach und nach abl&ouml;sen
sollen...Priorit&auml;t nach Bedarf...
<P>

<H4>asmmac.c</H4>
<P>
In diesem Modul finden sich die Routinen zur Speicherung und Abfrage
von Makros. Der eigentliche Makroprozessor befindet sich (wie bereits
erw&auml;hnt) in<TT> as.c</TT>.
<P>

<H4>asmpars.c</H4>
<P>
Hier geht es ins Eingemachte: In diesem Modul werden die
Symboltabellen (global und lokal) in zwei Bin&auml;rb&auml;umen
verwaltet. Au&szlig;erdem findet sich hier eine ziemlich gro&szlig;e
Prozedur<TT> EvalExpression</TT>, welche einen (Formel-)ausdruck
analysiert und auswertet. Die Prozedur liefert das Ergebnis (Integer,
Gleitkomma oder String) in einem varianten Record zur&uuml;ck. Zur
Auswertung von Ausdr&uuml;cken bei der Codeerzeugung sollten
allerdings eher die Funktionen<TT> EvalIntExpression,
EvalFloatExpression</TT> und<TT> EvalStringExpression</TT> verwendet
werden. &Auml;nderungen zum Einf&uuml;gen neuer Prozessoren sind hier
nicht erforderlich und sollten auch nur mit &auml;u&szlig;erster
&Uuml;berlegung erfolgen, da man hier sozusagen an ,,die Wurzel'' von
AS greift.
<P>

<H4>asmsub.c</H4>
<P>
Hier finden sich gesammelt einige h&auml;ufig gebrauchte
Unterroutinen, welche in erster Linie die Bereiche Fehlerbehandlung
und 'gehobene' Stringverarbeitung abdecken.
<P>

<H4>bpemu.c</H4>
<P>
Wie am Anfang erw&auml;hnt, war AS urspr&uuml;nglich ein in
Borland-Pascal geschriebenes Programm. Bei einigen intrinsischen
Funktionen des Compilers war es einfacher, diese zu emulieren,
anstatt alle betroffenen Stelle im Quellcode zu &auml;ndern. Na ja...
<P>

<H4>chunks.c</H4>
<P>
Dieses Modul definiert einen Datentyp, mit dem eine Liste von
Adre&szlig;bereichen verwaltet werden kann. Diese Funktion wird von
AS f&uuml;r die Belegungslisten ben&ouml;tigt, au&szlig;erdem
benutzten P2BIN und P2HEX diese Listen, um vor &Uuml;berlappungen zu
warnen.
<P>

<H4>cmdarg.c</H4>
<P>
Dieses Modul implementiert den Mechanismus der Kommdozeilenparameter.
Es ben&ouml;tigt eine Spezifikation der erlaubten Parameter, zerlegt
die Kommadozeile und ruft die entsprechenden Callbacks auf. Der
Mechanismus leistet im einzelnen folgendes:
<UL>
<LI> Mitbearbeitung von Optionen in einer Environment-Variablen oder
    entsprechenden Datei;</LI>
<LI> R&uuml;ckgabe einer Menge, welche die noch nicht bearbeiteten
    Kommandozeilenparameter beschreibt;</LI>
<LI> Trenunng von positiven und negativen Schaltern;</LI>
<LI> Eine Hintert&uuml;r, falls die dar&uuml;berliegende
    Entwicklungsumgebung die Kommandozeile nur in Gro&szlig;- oder
    Kleinschreibung &uuml;bergibt.</LI>
</UL>
Dieses Modul wird nicht nur von AS, sondern auch von den
Hilfsprogrammen<TT> BIND, P2HEX und P2BIN</TT> verwendet.
<P>

<H4>codepseudo.c</H4>
<P>
Hier finden sich Pseudobefehle, die von mehreren Codegeneratoren
verwendet werden. Dies ist einmal die Intel-Gruppe mit der<TT>
DB..DT</TT>-Gruppe, zum anderen die Pendants f&uuml;r die 8/16-Bitter
von Motorola oder Rockwell. Wer in diesem Bereich um einen Prozessor
erweitern will, kann mit einem Aufruf den gr&ouml;&szlig;ten Teil der
Pseudobefehle erschlagen.
<P>

<H4>codevars.c</H4>
<P>
Aus Speicherersparnisgr&uuml;nden sind hier einige von diversen
Codegeneratoren benutzen Variablen gesammelt.
<P>

<H4>endian.c</H4>
<P>
Doch noch ein bi&szlig;chen Maschinenabh&auml;ngigkeit, jedoch ein
Teil, um den man sich nicht zu k&uuml;mmern braucht: Ob eine Maschine
Little- oder Big-Endianess benutzt, wird in diesem Modul beim
Programmstart automatisch bestimmt. Weiterhin wird gepr&uuml;ft, ob
die in<TT> sysdefs.h</TT> gemachten Typfestlegungen f&uuml;r
Integervariablen auch wirklich die korrekten L&auml;ngen ergeben.
<P>

<H4>headids.c</H4>
<P>
Gesammelt sind hier alle von AS unterst&uuml;tzten
Zielprozessorfamilien, die daf&uuml;r in Code-Dateien verwendeten
Kennzahlen (siehe Kapitel <A HREF="#ref_SectCodeFormat">5.1</A>)
sowie das von P2HEX defaultm&auml;&szlig;ig zu verwendende
Ausgabeformat. Ziel dieser Tabelle ist es, Das Hinzuf&uuml;gen eines
neuen Prozessors m&ouml;glichst zu zentralisieren, d.h. es sind im
Gegensatz zu fr&uuml;her keine weiteren Modifikationen an den Quellen
der Hilfsprogramme mehr erforderlich.
<P>

<H4>ioerrs.c</H4>
<P>
Hier ist die Umwandlung von Fehlernummern in Klartextmeldungen
abgelegt. Hoffentlich treffe ich nie auf ein System, auf dem die
Nummern nicht als Makros definiert sind, dann kann ich n&auml;mlich
dieses Modul komplett umschreiben...
<P>

<H4>nlmessages.c</H4>
<P>
Die C-Version von AS liest alle Meldungen zur Laufzeit aus Dateien,
nachdem die zu benutzende Sprache ermittelt wurde. Das Format der
Nachrichtendateien ist kein einfaches, sondern ein spezielles,
kompaktes, vorindiziertes Format, das zur &Uuml;bersetzungszeit von
einem Programm namens 'rescomp' (dazu kommen wir noch) erzeugt wird.
Dieses Modul ist das Gegenst&uuml;ck zu rescomp, die den korrekten
Sprachenanteil einer Datei in ein Zeichenfeld einliest und
Zugriffsfunktionen anbietet.
<P>

<H4>nls.c</H4>
<P>
In diesem Modul wird ermittelt, welche nationalen Einstellungen
(Datums- und Zeitformat, L&auml;ndercode) zur Laufzeit vorliegen. Das
ist leider eine hochgradig systemspezifische Sache, und momentan sind
nur drei Methoden definiert: Die von MS-DOS, die von OS/2 und die
typische Unix-Methode &uuml;ber die<EM> locale</EM>-Funktionen.
F&uuml;r alle anderen Systeme ist leider NO_NLS angesagt...
<P>

<H4>stdhandl.c</H4>
<P>
Zum einen ist hier eine spezielle open-Funktion gelandet, die die
Sonderstrings<TT> !0...!2</TT> als Dateinamen kennt und daf&uuml;r
Duplikate der Standard-Dateihandles<EM> stdin, stdout</EM> und<EM>
stderr</EM> erzeugt, zum anderen wird hier festgestellt, ob die
Standardausgabe auf ein Ger&auml;t oder eine Datei umgeleitet wurde.
Das bedingt auf nicht-Unix-Systemen leider auch einige
Speziall&ouml;sungen.
<P>

<H4>stringlists.c</H4>
<P>
Dies ist nur ein kleiner ,,Hack'', der Routinen zur Verwaltung von
linearen Listen mit Strings als Inhalt definiert, welche z.B. im
Makroprozessor von AS gebraucht werden.
<P>

<H4>strutil.c</H4>
<P>
Hier sind einige h&auml;ufig genutzte String-Operationen gelandet.
<P>

<H4>version.c</H4>
<P>
Die momentan g&uuml;ltige Version ist f&uuml;r AS und alle anderen
Hilfsprogramme hier zentral gespeichert.
<P>

<H4>code????.c</H4>
<P>
Dies Module bilden den Hauptteil der AS-Quellen: jedes Modul
beinhaltet den Codegenerator f&uuml;r eine bestimmte
Prozessorfamilie.
<P>

<H3><A NAME="sect_I_3_2_">I.3.2. Zus&auml;tzliche Module f&uuml;r die Hilfsprogramme</A></H3>
<P>

<H4>hex.c</H4>
<P>
Ein kleines Modul zur Umwandlung von Integerzahlen in
Hexadezimaldarstellung. In C nicht mehr unbedingt erforderlich
(au&szlig;er zur Wandlung von<EM> long long</EM>-Variablen, was
leider nicht alle<TT> printf()</TT>'s unterst&uuml;tzen), aber es ist
im Rahmen der Portierung eben auch stehengeblieben.
<P>

<H4>p2bin.c</H4>
<P>
Die Quellen von P2BIN.
<P>

<H4>p2hex.c</H4>
<P>
Die Quellen von P2HEX.
<P>

<H4>pbind.c</H4>
<P>
Die Quellen von BIND.
<P>

<H4>plist.c</H4>
<P>
Die Quellen von PLIST.
<P>

<H4>toolutils.c</H4>
<P>
Hier sind gesammelt die Unterroutinen, die von allen Hilfsprogrammen
ben&ouml;tigt werden, z.B. f&uuml;r das Lesen von Code-Dateien.
<P>

<H2><A NAME="sect_I_4_">I.4. W&auml;hrend der Erzeugung von AS gebrauchte Module</A></H2>
<P>

<H4>a2k.c</H4>
<P>
Dies ist ein Minimalfilter, das ANSI-C-Files in Kernighan-Ritchie
umwandelt. Um es genau zu sagen: es werden nur die
Funktionsk&ouml;pfe umgewandelt, und auch nur dann, wenn sie
ungef&auml;hr so formatiert sind, wie es mein Schreibstil eben ist.
Es komme also keiner auf die Idee, das w&auml;re ein universeller
C-Parser!
<P>

<H4>addcr.c</H4>
<P>
Ein kleiner Filter, der bei der Installation auf DOS- oder
OS/2-Systemen gebraucht wird. Da DOS und OS/2 den Zeilenvorschub mit
CR/LF vornehmen, Unix-Systeme jedoch nur mit LF, werden
s&auml;mtliche mitgelieferten Assembler-Includes bei der Installation
durch diesen Filter geschickt.
<P>

<H4>bincmp.c</H4>
<P>
F&uuml;r DOS und OS/2 &uuml;bernimmt dieses Modul die Funktion die
Funktion des<EM> cmp</EM>-Befehls, d.h. den bin&auml;ren Vergleich
von Dateien w&auml;hrend des Testlaufes. W&auml;hrend dies
prinzipiell auch mit dem mitgelieferten<EM> comp</EM> m&ouml;glich
w&auml;re, hat<EM> bincmp</EM> keine l&auml;stigen interaktiven
Abfragen (bei denen man erst einmal herausfinden mu&szlig;, wie man
sie auf allen Betriebssystemversionen abstellt...)
<P>

<H4>findhyphen.c</H4>
<P>
Dies ist das Untermodul in<EM> tex2doc</EM>, da&szlig; f&uuml;r die
Silbentrennung von Worten sorgt. Der verwendete Algorithmus is
schamlos von TeX abgekupfert.
<P>

<H4>grhyph.c</H4>
<P>
Die Definition der Silbentrennungsregeln f&uuml;r die deutsche
Sprache.
<P>

<H4>rescomp.c</H4>
<P>
Dies ist der 'Resourcencompiler' von AS, d.h. das Werkzeug, das die
lesbaren Dateien mit Stringresourcen in ein schnelles, indiziertes
Format umsetzt.
<P>

<H4>tex2doc.c</H4>
<P>
Ein Werkzeug, da&szlig; die LaTeX-Dokumentation von AS in ein
ASCII-Format umsetzt.
<P>

<H4>tex2html.c</H4>
<P>
Ein Werkzeug, da&szlig; die LaTeX-Dokumentation von AS in ein
HTML-Dokument umsetzt.
<P>

<H4>umlaut.c und unumlaut.c</H4>
<P>
Diese Progr&auml;mmchen besorgen die Wandlung zwischen
Sonderzeichenkodierung im ISO-Format (alle AS-Dateien verwenden im
Auslieferungszustand die ISO8859-1-Kodierung f&uuml;r Sonderzeichen)
und Sonderzeichenkodierung im systemspezifischen Format. Neben einer
Plain-ASCII7-Variante sind dies im Augenblick die
IBM-Zeichens&auml;tze 437 und 850.
<P>

<H4>ushyph.c</H4>
<P>
Die Definition der Silbentrennungsregeln f&uuml;r die englische
Sprache.
<P>

<H2><A NAME="sect_I_5_">I.5. Generierung der Nachrichtendateien</A></H2>
<P>
Wie bereits erw&auml;hnt, verwendet der C-Quellenbaum von AS ein
dynamisches Ladeverfahren f&uuml;r alle (Fehler-)Meldungen.
Gegen&uuml;ber den Pascal-Quellen, in denen alle Meldungen in einem
Include-File geb&uuml;ndelt waren und so in die Programme
hinein&uuml;bersetzt wurden, macht es dieses Verfahren
&uuml;berfl&uuml;ssig, mehrere sprachliche Varianten von AS zur
Verf&uuml;gung zu stellen: es gibt nur noch eine Version, die beim
Programmstart die zu benutzende Variante ermittelt und aus den
Nachrichtendateien die entsprechende Komponente l&auml;dt. Kurz zur
Erinnerung: Unter DOS und OS/2 wird dazu die gew&auml;hlte<TT>
COUNTRY</TT>-Einstellung zu Rate gezogen, unter Unix werden die
Environment-Variablen<TT> LC_MESSAGES, LC_ALL</TT> und<TT> LANG</TT>
befragt.
<P>

<H3><A NAME="sect_I_5_1_">I.5.1. Format der Quelldateien</A></H3>
<P>
Eine Quelldatei f&uuml;r den Message-Compiler<EM> rescomp</EM> hat
&uuml;blicherweise die Endung<TT> .res</TT>. Der Message-Compiler
erzeugt aus dieser Datei ein oder zwei Dateien:
<UL>
<LI> eine bin&auml;re Datei, die zur Laufzeit von AS bzw. den
    Hilfsprogrammen gelesen wird;</LI>
<LI> optional eine weitere C-Header-Datei, die allen vorhandenen
    Nachrichten eine Indexnummer zuweist. &Uuml;ber diese
    Indexnummern und eine Indextabelle in der bin&auml;ren Datei kann
    zur Laufzeit schnell auf einzelne Meldungen zugegriffen
    werden.</LI>
</UL>
<P>
Die Quelldatei f&uuml;r den Message-Compiler ist eine reine
ASCII-Datei, also mit jedem beliebigen Editor bearbeitbar, und
besteht aus einer Reihe von Steueranweisungen mit Parametern.
Leerzeilen sowie Zeilen, die mit einem Semikolon beginnen, werden
ignoriert. Das Inkludieren anderer Dateien ist &uuml;ber das<TT>
Include</TT>-Statement m&ouml;glich:
<PRE>

Include &lt;Datei&gt;

</PRE>
<P>
Am Anfang jeder Quelldatei m&uuml;ssen zwei Statements stehen, die
die im folgenden definierten Sprachen beschreiben. Das wichtigere der
beiden Statements ist<TT> Langs</TT>, z.B.:
<PRE>

Langs DE(049) EN(001,061)

</PRE>
beschreibt, da&szlig; zwei Sprachen im folgenden definiert werden.
Der erste Nachrichtensatz soll benutzt werden, wenn unter Unix die
Sprache per Environment-Variablen auf<TT> DE</TT> gestellt wurde bzw.
unter DOS bzw. OS/2 der Landescode 049 eingestellt wurde. Der zweite
Satz kommt dementsprechend bei den Einstellungen<TT> EN</TT> bzw. 061
oder 001 zum Einsatz. W&auml;hrend bei den 'Telefonnummern' mehrere
Codes auf einen Nachrichtensatz verweisen k&ouml;nnen, ist die
Zuordnung zu den Unix-Landescodes eineindeutig. Dies ist in der
Praxis aber kein Beinbruch, weil die<TT> LANG</TT>-Variablen unter
Unix Unterversionen einer Sprache als Anh&auml;ngsel beschreiben,
z.B. so:
<PRE>

de.de
de.ch
en.us

</PRE>
AS vergleicht nur den Anfang der Strings und kommt so trotzdem zur
richtigen Entscheidung. Das<TT> Default</TT>-Statement gibt vor,
welcher Sprachensatz verwendet werden soll, wenn entweder
&uuml;berhaupt keine Sprache gesetzt wurde oder eine Kennung
verwendet wird, die nicht in der Liste von<TT> Langs</TT> vorhanden
ist. Typischerweise ist dies Englisch:
<PRE>

Default EN

</PRE>
Nach diesen beiden Definitionen folgt eine beliebige Menge von<TT>
Message</TT>-Statements, d.h. Definitionen von Meldungen:
<PRE>

Message ErrName
 ": Fehler "
 ": error "

</PRE>
Wurden<EM> n</EM> Sprachen im<TT> Langs</TT>-Statement
angek&uuml;ndigt, so nimmt der Message-Compiler<B> genau</B> die
folgenden<EM> n</EM> Zeilen als die zu speichernden Strings. Es ist
also nicht m&ouml;glich, bei einzelnen Nachrichten bestimmte Sprachen
fortzulassen, und eine auf die Strings folgende Leerzeile ist
keinesfalls als Endemarkierung f&uuml;r die Liste
mi&szlig;zuverstehen; eingef&uuml;gte Leerzeilen dienen einzig und
allein der besseren Lesbarkeit. Was allerdings erlaubt ist, ist,
einzelne Meldungen &uuml;ber mehrere Zeilen in der Quelldatei zu
verteilen; alle Zeilen bis auf die letzte m&uuml;ssen dann mit einem
Backslash als Fortsetzungszeichen enden:
<PRE>

Message TestMessage2
 "Dies ist eine" \  
 "zweizeilige Nachricht"
 "This is a" \
 "two-line message"

</PRE>
Wie bereits erw&auml;hnt, handelt es sich bei den Quelldateien um
reine ASCII-Dateien; Sonderzeichen k&ouml;nnen in den Meldungstexten
zwar eingetragen werden (und der Compiler wird sie auch so
durchreichen), der gravierende Nachteil ist aber, da&szlig; eine
solche Datei nicht mehr voll portabel ist: Wird sie auf ein anderes
System gebracht, das z.B. eine andere Kodierung f&uuml;r Umlaute
verwendet, bekommt der Anwender zur Laufzeit nur merkw&uuml;rdige
Zeichen zu sehen...Sonderzeichern sollten daher immer mit Hilfe von
speziellen Sequenzen geschrieben werden, die von HTML bzw. SGML
entlehnt wurden (siehe Tabelle <A HREF="#ref_TabSpecChars">I.1</A>).
Zeilenvorsch&uuml;be k&ouml;nnen in eine Zeile wie von C her gewohnt
mit \n eingebracht werden.

<CENTER>
<P><CENTER><TABLE SUMMARY="No Summary" BORDER=1 CELLPADDING=5>
<TR ALIGN=LEFT>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>Sequenz...</TH>
<TH VALIGN=TOP NOWRAP ALIGN=LEFT>ergibt...</TH>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT> &amp;auml; &amp;ouml; &amp;uuml;<BR>
 &amp;Auml; &amp;Ouml; &amp;Uuml;<BR>
 &amp;szlig;<BR>
 &amp;agrave; &amp;egrave; &amp;igrave; &amp;ograve; &amp;ugrave;<BR>
 &amp;Agrave; &amp;Egrave; &amp;Igrave; &amp;Ograve; &amp;Ugrave;<BR>
 &amp;aacute; &amp;eacute; &amp;iacute; &amp;oacute; &amp;uacute;<BR>
 &amp;Aacute; &amp;Eacute; &amp;Iacute; &amp;Oacute; &amp;Uacute;<BR>
 &amp;acirc; &amp;ecirc; &amp;icirc; &amp;ocirc; &amp;ucirc;<BR>
 &amp;Acirc; &amp;Ecirc; &amp;Icirc; &amp;Ocirc; &amp;Ucirc;<BR>
 &amp;ccedil; &amp;Ccedil;<BR>
 &amp;ntilde; &amp;Ntilde;<BR>
 &amp;aring; &amp;Aring;<BR>
 &amp;aelig; &amp;Aelig;<BR>
 &amp;iquest; &amp;iexcl;</TD>
<TD VALIGN=TOP NOWRAP ALIGN=LEFT>&auml; &ouml; &uuml; (Umlaute)<BR>
&Auml; &Ouml; &Uuml;<BR>
&szlig; (scharfes s)<BR>
&aacute; &eacute; &iacute; &oacute; &uacute; (Accent<BR>
&Aacute; &Eacute; &Iacute; &Oacute; &Uacute; grave)<BR>
&agrave; &egrave; &igrave; &ograve; &ugrave; (Accent<BR>
&Agrave; &Egrave; &Igrave; &Ograve; &Ugrave; agiu)<BR>
&acirc; &ecirc; &icirc; &ocirc; &ucirc; (Accent<BR>
&Acirc; &Ecirc; &Icirc; &Ocirc; &Ucirc; circonflex)<BR>
&ccedil; &Ccedil;(Cedilla)<BR>
&ntilde; &Ntilde;<BR>
&aring; &Aring;<BR>
&aelig; &AElig;<BR>
umgedrehtes ! oder ?</TD>
</TR>
</TABLE></CENTER>
</CENTER>
<P><CENTER>Tabelle I.1: Sonderzeichenschreibweise des<EM> rescomp</EM><A
             NAME="ref_TabSpecChars"></A>
</CENTER><P>

<P>

<H2><A NAME="sect_I_6_">I.6. Dokumentationserzeugung</A></H2>
<P>
In einer Quellcodedistribution von AS ist diese Dokumentation nur als
LaTeX-Dokument enthalten. Andere Formate werden aus dieser mit Hilfe
von mitgelieferten Werkzeugen automatisch erzeugt. Zum einen
reduziert dies den Umfang einer Quellcodedistribution, zum anderen
m&uuml;ssen &Auml;nderungen nicht an allen Formatversionen eines
Dokumentes parallel vorgenommen werden, mit all den Gefahren von
Inkonsistenzen.
<P>
Als Quellformat wurde LaTeX verwendet, weil...weil...weil es eben
schon immer vorhanden war. Zudem ist TeX fast beliebig portierbar und
pa&szlig;t damit recht gut zum Anspruch von AS. Eine
Standard-Distribution erlaubt damit eine 'ordentliche' Ausgabe auf so
ziemlich jedem Drucker; f&uuml;r eine Konvertierung in die
fr&uuml;her immer vorhandene ASCII-Version liegt der Konverter<EM>
tex2doc</EM> bei; zus&auml;tzlich einen Konverter<EM> tex2html</EM>,
so da&szlig; man die Anleitung direkt ins Internet stellen kann.
<P>
Die Erzeugung der Dokumentation wird mit einem schlichten
<PRE>

make docs

</PRE>
angesto&szlig;en; daraufhin werden die beiden erw&auml;hnten
Hilfstools erzeugt, auf die TeX-Dokumentation angewandt und
schlu&szlig;endlich wird noch LaTeX selber aufgerufen. Dies
nat&uuml;rlich f&uuml;r alle Sprachen nacheinander...
<P>

<H2><A NAME="sect_I_7_">I.7. Testsuite</A></H2>
<P>
Da AS mit bin&auml;ren Daten von genau vorgegebener Struktur umgeht,
ist er naturgem&auml;&szlig; etwas empfindlich f&uuml;r System- und
Compilerabh&auml;ngigkeiten. Um wenigstens eine gewisse Sicherheit zu
geben, da&szlig; alles korrekt durchgelaufen ist, liegt dem Assembler
im Unterverzeichnis<TT> tests</TT> eine Menge von
Test-Assemblerquellen bei, mit denen man den frisch gebauten
Assembler testen kann. Diese Testprogramme sind in erster Linie
darauf getrimmt, Fehler in der Umsetzung des Maschinenbefehlssatzes
zu finden, die besonders gern bei variierenden Wortl&auml;ngen
auftreten. Maschinenunabh&auml;ngige Features wie der Makroprozessor
oder bedingte Assemblierung werden eher beil&auml;ufig getestet, weil
ich davon ausgehe, da&szlig; sie &uuml;berall funktionieren, wenn sie
bei mir funktionieren...
<P>
Der Testlauf wird mit einem einfachen<EM> make test</EM>
angesto&szlig;en. Jedes Testprogramm wird assembliert, in eine
Bin&auml;rdatei gewandelt und mit einem Referenz-Image verglichen.
Ein Test gilt als bestanden, wenn Referenz und die neu erzeugte Datei
Bit f&uuml;r Bit identisch sind. Am Ende wird summarisch die
Assemblierungszeit f&uuml;r jeden Test ausgegeben (wer will, kann mit
diesen Ergebnissen die Datei<TT> BENCHES</TT> erg&auml;nzen),
zusammen mit dem Erfolg oder Mi&szlig;erfolg. Jedem Fehler ist auf
den Grund zu gehen, selbst wenn er bei einem Zielprozessor auftritt,
den Sie nie nutzen werden! Es ist immer m&ouml;glich, da&szlig; dies
auf einen Fehler hinweist, der auch bei anderen Zielprozessoren
auftritt, nur zuf&auml;llig nicht in den Testf&auml;llen.
<P>

<H2><A NAME="sect_I_8_">I.8. Einh&auml;ngen eines neuen Zielprozessors</A></H2>
<P>
Der mit Abstand h&auml;ufigste Grund, im Quellcode von AS etwas zu
ver&auml;ndern, d&uuml;rfte wohl die Erweiterung um einen neuen
Zielprozessor sein. Neben der Erg&auml;nzung der Makefiles um das
neue Modul ist lediglich eine Modifikation der Quellen an wenigen
Stellen erforderlich, den Rest erledigt das neue Modul, indem es sich
in der Liste der Codegeneratoren registriert. Im folgenden will ich
kochbuchartig die zum Einh&auml;ngen erforderlichen Schritte
beschreiben:
<P>

<H4>Festlegung des Prozessornamens</H4>
<P>
Der f&uuml;r den Prozessor zu w&auml;hlende Name mu&szlig; zwei
Kriterien erf&uuml;llen:
<OL>
<LI>Der Name darf noch nicht von einem anderen Prozessor belegt sein.
    Beim Aufruf von AS ohne Parameter erh&auml;lt man eine Liste der
    bereits vorhandenen Namen.</LI>
<LI>Soll der Prozessorname vollst&auml;ndig in der Variablen<TT>
    MOMCPU</TT> auftauchen, so darf er au&szlig;er am Anfang keine
    Buchstaben au&szlig;erhalb des Bereiches von A..F enthalten. In
    der Variablen<TT> MOMCPUNAME</TT> liegt aber zur Assemblierzeit
    immer der volle Name vor. Sonderzeichen sind generell nicht
    erlaubt, Kleinbuchstaben werden vom CPU-Befehl bei der Eingabe in
    Gro&szlig;buchtaben umgewandelt und sind daher auch nicht im
    Prozessornamen sinnvoll.</LI>
</OL>
<P>
Der erste Schritt der Registrierung ist die Eintragung des Prozessors
oder der Prozessorfamilie in der Datei<TT> headids.c</TT>. Wie
bereits erw&auml;hnt, wird diese Datei von den Hilfsprogrammen
mitbenutzt und spezifiziert die einer Prozessorfamilie zugeordnete
Kenn-ID in Codedateien sowie das zu verwendende Hex-Format. Bei der
Wahl der Kenn-ID w&uuml;rde ich mir etwas Absprache w&uuml;nschen...
<P>

<H4>Definition des Codegeneratormoduls</H4>
<P>
Das Modul, das f&uuml;r den neuen Prozessor zust&auml;ndig sein soll,
sollte einer gewissen Einheitlichkeit wegen den Namen<TT>
code....</TT> tragen, wobei<TT> .....</TT> etwas mit dem
Prozessornamen zu tun haben sollte. Den Kopf mit den Includes
&uuml;bernimmt man am besten direkt aus einem bereits vorhandenen
Codegenerator.
<P>
Mit Ausnahme einer Initialisierungsfunktion, die zu Anfang der<TT>
main()</TT>-Funktion im Modul<TT> as.c</TT> aufgerufen werden
mu&szlig;, braucht das neue Modul keinerlei Funktionen oder Variablen
zu exportieren, da die ganze Kommunikation zur Laufzeit &uuml;ber
indirekte Spr&uuml;nge abgewickelt wird. Die dazu erforderlichen
Registrierungen m&uuml;ssen in der Initialisierungsfunktion des
Moduls vorgenommen werden, indem f&uuml;r jeden von der Unit zu
behandelnden Prozessortyp ein Aufruf der Funktion<TT> AddCPU</TT>
erfolgt:
<PRE>

   CPUxxxx = AddCPU("XXXX", SwitchTo_xxxx);

</PRE>
<TT>'XXXX'</TT> ist dabei der f&uuml;r den Prozessor festgelegte
Name, der sp&auml;ter im Assemblerprogramm verwendet werden
mu&szlig;, um AS auf diesen Zielprozessor umzuschalten.<TT>
SwitchTo_xxxx</TT> (im folgenden kurz als ,,Umschalter'' bezeichnet)
ist eine parameterlose Prozedur, die von AS aufgerufen wird, sobald
auf diesen Prozessor umgeschaltet werden soll. Als Ergebnis
liefert<TT> AddCPU</TT> eine Zahlenwert, der als interne ,,Kennung''
f&uuml;r diesen Prozessor fungiert. In der globalen Variablen<TT>
MomCPU</TT> wird st&auml;ndig die Kennung des momentan gesetzten
Zielprozessors mitgef&uuml;hrt. Der von<TT> AddCPU</TT> gelieferte
Wert sollte in einer privaten Variable des Typs<TT> CPUVar</TT>
(hier<TT> CPUxxxx</TT> genannt) abgelegt werden. Falls ein
Codegeneratormodul verschiedene Prozessoren (z.B. einer Familie)
verwaltet, kann es so durch Vergleich von<TT> MomCPU</TT> gegen diese
Werte feststellen, welche Befehlsuntermenge momentan zugelassen ist.
<P>
Dem Umschalter obliegt es, AS auf den neuen Zielprozessor
,,umzupolen''. Dazu m&uuml;ssen im Umschalter einige globale
Variablen besetzt werden:
<UL>
<LI> <TT>ValidSegs</TT> : Nicht alle Prozessoren definieren alle von AS
    unterst&uuml;tzten Adre&szlig;r&auml;ume. Mit dieser Menge legt
    man fest, welche Untermenge f&uuml;r den jeweiligen Prozessor
    von<TT> SEGMENT</TT>-Befehl zugelassen wird. Im mindesten
    mu&szlig; das Code-Segment freigeschaltet werden. Die Gesamtmenge
    aller vorhandenen Segmenttypen kann in der Datei<TT>
    fileformat.h</TT> nachgelesen werden
    (<TT>Seg</TT>.....-Konstanten).</LI>
<LI> <TT>SegInits</TT> : Dieses Feld speichert die initialen (ohne<TT>
    ORG</TT>-Befehl) Startadressen in den einzelnen Segmenten. Nur in
    Ausnahmef&auml;llen (physikalisch &uuml;berlappende, aber logisch
    getrennte Adre&szlig;r&auml;ume) sind hier andere Werte als 0
    sinnvoll.</LI>
<LI> <TT>Grans</TT> : Hiermit kann f&uuml;r jedes Segment die
    Gr&ouml;&szlig;e des kleinsten adressierbaren Elements in Bytes
    festgelegt werden, d.h. die Gr&ouml;&szlig;e des Elements,
    f&uuml;r das eine Adresse um eins erh&ouml;ht wird. Bei den
    allermeisten Prozessoren (auch 16 oder 32 Bit) ist dies ein Byte,
    nur z.B. Signalprozessoren und die PICs fallen aus dem
    Rahmen.</LI>
<LI> <TT>ListGrans</TT> : Hiermit kann wieder f&uuml;r alle Segmente
    getrennt festgelegt werden, in was f&uuml;r Gruppen die Bytes im
    Assemblerlisting dargestellt werden sollen. Beim 68000 sind z.B.
    Befehle immer ein mehrfaches von 2 Bytes lang, weshalb die
    entsprechende Variable auf 2 gesetzt ist.</LI>
<LI> <TT>SegLimits</TT> : Dieses Feld legt die h&ouml;chste Adresse
    f&uuml;r jedes Segment fest, z.B. 65535 f&uuml;r einen
    16-Bit-Adre&szlig;raum. Dieses Feld braucht nicht ausgef&uuml;llt
    zu werden, wenn der Codegenerator die<TT> ChkPC</TT>-Methode
    selber &uuml;bernimmt.</LI>
<LI> <TT>ConstMode</TT> : Diese Variable kann die Werte<TT>
    ConstModeIntel</TT>,<TT> ConstModeMoto</TT> oder<TT>
    ConstModeC</TT> haben und bestimmt, in welcher Form Zahlensysteme
    bei Integerkonstanten spezifiziert werden sollen (sofern das
    Programm nicht vom Relaxed-Modus Gebrauch macht).</LI>
<LI> <TT>PCSymbol</TT> : Diese Variable enth&auml;lt den String, mit dem
    aus dem Assembler-Programm heraus der momentane Stand des
    Programmz&auml;hlers abgefragt werden kann. F&uuml;r
    Intel-Prozessoren ist dies z.B. ein Dollarzeichen.</LI>
<LI> <TT>TurnWords</TT> : Falls der Prozessor ein Big-Endian-Prozessor
    sein sollte und eines der Elemente von<TT> ListGrans</TT>
    ungleich eins ist, sollte dieses Flag auf True gesetzt werden, um
    korrekte Code-Dateien zu erhalten.</LI>
<LI> <TT>SetIsOccupied</TT> : Einige Prozessoren verwenden<TT> SET</TT>
    als Maschinenbefehl. Ist diese Variable gesetzt, so gibt AS<TT>
    SET</TT> -Befehle an den Codegenerator weiter und verwendet
    stattdessen<TT> EVAL</TT>.</LI>
<LI> <TT>HeaderID</TT> : Dieses Byte enth&auml;lt die Kennung, mit der in
    der Codedatei die Prozessorfamilie gekennzeichnet wird (siehe
    Abschnitt <A HREF="#ref_SectCodeFormat">5.1</A>). Um
    Zweideutigkeiten zu vermeiden, bitte ich, den Wert mit mir
    abzusprechen. Bis auf weiteres sollten keine Werte
    au&szlig;erhalb des Bereiches $01..$7f benutzt werden, diese sind
    f&uuml;r Sonderzwecke (wie z.B. eine zuk&uuml;nftige Erweiterung
    um einen Linker) reserviert. Auch wenn dieser Wert in den meisten
    &auml;lteren Codegeneratoren hart gesetzt wird, ist es die heute
    bevorzugte Methode, den Wert aus<TT> headids.h</TT> per<TT>
    FindFamilyByName</TT> zu holen.</LI>
<LI> <TT>NOPCode</TT> : In bestimmten Situationen kann es sein, da&szlig;
    AS unbenutzte Bereiche im Code mit NOPs auff&uuml;llen mu&szlig;.
    Diese Variable beinhaltet den dazu erforderlichen Code.</LI>
<LI> <TT>DivideChars</TT> : Dieser String enth&auml;lt all jene Zeichen,
    die als Trennzeichen f&uuml;r die Parameter eines
    Assemblerbefehls zugelassen sind. Nur f&uuml;r extreme
    Ausrei&szlig;er (wie den DSP56) sollte sich in diesem String
    etwas anderes finden als ein Komma.</LI>
<LI> <TT>HasAttrs</TT> : Einige Prozessoren wie die 68k-Reihe teilen
    einen Maschinenbefehl durch einen Punkt noch weiter in Mnemonic
    und Attribut auf. Ist dies beim neuen Prozessor auch der Fall, so
    ist dieses Flag auf True zu setzen. AS liefert dann die
    Einzelteile in den Variablen<TT> OpPart</TT> und<TT>
    AttrPart</TT>. Setzt man es dagegen auf False, so bleibt der
    Befehl in<TT> OpPart</TT> zusammen, und<TT> AttrPart</TT> ist
    immer leer. Sofern der Prozessor keine Attribute verwendet,
    sollte man<TT> HasAttrs</TT> auf jeden Fall auf False setzen, da
    man sich sonst die M&ouml;glichkeit nimmt, Makros mit einem Punkt
    im Namen (z.B. zur Emulation anderer Assembler) zu
    definieren.</LI>
<LI> <TT>AttrChars</TT> : Falls<TT> HasAttrs</TT> gesetzt wurde,
    m&uuml;ssen in diesem String alle Zeichen eingetragen werden, die
    das Attribut vom Befehl trennen k&ouml;nnen. Meist ist dies nur
    der Punkt.</LI>
</UL>
Gehen Sie nicht davon aus, da&szlig; eine dieser Variablen einen
vordefinierten Wert hat, sondern besetzen Sie<B> ALLE</B> Felder
neu!!
<P>
Neben diesen Variablen m&uuml;ssen noch einige Funktionszeiger
besetzt wird, mit denen der Codegenerator sich in AS einbindet:
<UL>
<LI> <TT>MakeCode</TT> : Diese Routine wird nach der Zerlegung einer
    Zeile in Mnemonic und Parameter aufgerufen. Das Mnemonic liegt in
    der Variablen<TT> OpPart</TT>, die Parameter in dem Feld<TT>
    ArgStr</TT>. Die Zahl der Parameter kann aus der Variablen<TT>
    ArgCnt</TT> ausgelesen werden. Das bin&auml;re Ergebnis mu&szlig;
    in dem Byte-Feld<TT> BAsmCode</TT> abgelegt werden, dessen
    L&auml;nge in der Variablen<TT> CodeLen</TT>. Falls der Prozessor
    wortorientiert wie der 68000 oder viele Signalprozessoren ist,
    kann Feld auch wortweise als<TT> WAsmCode</TT> adressiert werden.
    F&uuml;r ganz extreme F&auml;lle gibt es auch noch<TT>
    DAsmCode</TT>... Die Codel&auml;nge wird ebenfalls in solchen
    Einheiten angegeben.</LI>
<LI> <TT>SwitchFrom</TT>: Diese parameterlose Prozedur erlaubt dem
    Codegeneratormodul, noch ,,Aufr&auml;umarbeiten''
    durchzuf&uuml;hren, wenn auf einen anderen Zielprozessor
    umgeschaltet wird. So kann man an dieser Stelle z.B. Speicher
    freigeben, der im Umschalter belegt wurde und nur ben&ouml;tigt
    wird, w&auml;hrend dieses Codegeneratormodul aktiv ist. Im
    einfachsten Fall zeigt diese Prozedurvariable auf eine leere
    Prozedur. Ein Beispiel f&uuml;r die Anwendung dieser Prozedur
    finden Sie im Modul<TT> CODE370</TT>, das seine Codetabellen
    dynamisch erzeugt und wieder freigibt.</LI>
<LI> <TT>IsDef</TT> : Bestimmte Prozessoren kennen neben<TT> EQU</TT>
    noch weitere Pseudobefehle, bei denen ein in der ersten Spalte
    stehender Symbolname kein Label darstellt, z.B.<TT> BIT</TT> beim
    8051. Diese Funktion mu&szlig; TRUE zur&uuml;ckliefern, falls ein
    solcher, zus&auml;tzlicher Befehl vorliegt. Im einfachsten Fall
    braucht nur FALSE zur&uuml;ckgeliefert zu werden.</LI>
</UL>
<P>
Optional kann ein Codegenerator auch noch folgende weitere
Funktionszeiger besetzen:
<UL>
<LI> <TT>ChkPC</TT> : Obwohl AS die Programmz&auml;hler intern
    durchg&auml;ngig mit 32 oder 64 Bit verwaltet, benutzen die
    meisten Prozessoren nur einen kleineren Adre&szlig;raum. Diese
    Funktion liefert AS Informationen, ob der momentane
    Programmz&auml;hler den erlaubten Bereich &uuml;berschritten hat.
    Bei Prozessoren mit mehreren Adre&szlig;r&auml;umen kann diese
    Routine nat&uuml;rlich deutlich komplizierter ausfallen. Ein
    Beispiel daf&uuml;r findet sich z.B. im Modul<TT>
    code16c8x.c</TT>. Falls alles in Ordnung ist, mu&szlig; die
    Funktion TRUE zur&uuml;ckliefern, ansonsten FALSE. Diese Funktion
    mu&szlig; ein Codegenerator nur implementieren, wenn er das
    Feld<TT> SegLimits</TT> nicht belegt. Das kann z.B. notwendig
    werden, wenn der g&uuml;ltige Adre&szlig;bereich eines Segments
    nicht zusammenh&auml;ngend ist.</LI>
<LI> <TT>InternSymbol</TT> : Manche Prozessoren, z.B. solche mit einer
    Registerbank im internen RAM, defineren diese 'Register' als
    Symbole vor, und es w&uuml;rde wenig Sinn machen, diese in einer
    separaten Include-Datei mit 256 oder m&ouml;glicherweise noch
    mehr<TT> EQU</TT>s zu definieren. Mit dieser Funktion erh&auml;lt
    man Zugang zum Formel- Parser von AS: Sie erh&auml;lt den
    Ausdruck als ASCII-String, und wenn sie eines der 'eingebauten
    Symbole' erkennt, besetzt sie die &uuml;bergebene Struktur des
    Typs<EM> TempResult</EM> entsprechend. Falls die
    &Uuml;berpr&uuml;fung nicht erfolgreich war, mu&szlig; deren
    Element<TT> Typ</TT> auf<TT> TempNone</TT> gesetzt werden. Die
    Routine sollte im Falle eines Mi&szlig;erfolges<EM> keine</EM>
    Fehlermeldungen ausgeben, weil dies immer noch anderweitig
    g&uuml;ltige Symbole sein k&ouml;nnen. Seien Sie extrem
    vorsichtig mit dieser Routine, da sie einen Eingriff in den
    Parser darstellt!</LI>
</UL>
<P>
Wer will, kann sich &uuml;brigens auch mit einem Copyright-Eintrag
verewigen, indem er in der Initialisierung des Moduls (bei den<TT>
AddCPU</TT>-Befehlen) einen Aufruf der Prozedur<TT> AddCopyright</TT>
einf&uuml;gt, in der folgenden Art:
<PRE>

    AddCopyright("Intel 80986-Codegenerator (C) 2010 Hubert Simpel");

</PRE>
Der &uuml;bergebene String wird dann nach dem Programmstart
zus&auml;tzlich zu der Standardmeldung ausgegeben.
<P>
Bei Bedarf kann sich das Modul im Initialisierungsteil noch in die
Kette aller Funktionen eintragen, die vor Beginn eines Durchlaufes
durch den Quelltext ausgef&uuml;hrt werden. Dies ist z.B. immer dann
der Fall, wenn die Code-Erzeugung im Modul abh&auml;ngig vom Stand
bestimmter, durch Pseudobefehle beeinflu&szlig;barer Flags ist. Ein
h&auml;ufig auftretender Fall ist z.B., da&szlig; ein Prozessor im
User- oder Supervisor-Modus arbeiten kann, wobei im User-Modus
bestimmte Befehle gesperrt sind. Im Assembler-Quelltext k&ouml;nnte
dieses Flag, das angibt, in welchem Modus der folgende Code
ausgef&uuml;hrt wird, durch einen Pseudobefehl umgeschaltet werden.
Es ist aber dann immer noch eine Initialisierung erforderlich, die
sicherstellt, da&szlig; in allen Durchl&auml;ufen ein identischer
Ausgangszustand vorliegt. Der &uuml;ber den Funktionszeiger<TT>
InitPassProc</TT> angebotene Haken bietet die M&ouml;glichkeit,
derartige Initialisierungen vorzunehmen. Das verwendete Prinzip
&auml;hnelt dabei dem Einh&auml;ngen in einen Interruptvektor: In der
Initialisierung der Unit wird der alte Wert von<TT> InitPassProc</TT>
gesichert. Danach kann<TT> InitPassProc</TT> auf die
hinzuzuf&uuml;gende Funktion (parameterlos, kein R&uuml;ckgabewert)
umgebogen werden. Die neue Routine ruft dann zuerst die alte
Initialisierungsroutine auf und f&uuml;hrt danach ihre eigenen
Operationen durch.
<P>
Analog zu<TT> InitPassProc</TT> funktioniert die &uuml;ber<TT>
CleanUpProc</TT> aufgebaute Funktionskette, die es den
Codegeneratoren erlaubt, nach dem Abschlu&szlig; der Assemblierung
noch Aufr&auml;umarbeiten (z.B. das Freigeben von Literaltabellen
o.&auml;.) durchzuf&uuml;hren. Dies ist sinnvoll, wenn mehrere
Dateien mit einem Aufruf assembliert werden, sonst h&auml;tte man
noch ,,M&uuml;ll'' aus einem vorigen Lauf in den Tabellen. Momentan
nutzt kein Modul diese M&ouml;glichkeit.
<P>

<H4>Schreiben des Codegenerators selber</H4>
<P>
Nach diesen Pr&auml;liminarien ist nun endlich eigene
Kreativit&auml;t gefragt: Wie Sie es schaffen, aus dem Mnemonic und
den Argumenten die Code-Bytes zu erzeugen, ist weitgehend Ihnen
&uuml;berlassen. Zur Verf&uuml;gung stehen daf&uuml;r nat&uuml;rlich
&uuml;ber den Formelparser die Symboltabellen sowie die Routinen
aus<TT> asmsub.c</TT> und<TT> asmpars.c</TT>. Ich kann hier nur
einige generelle Hinweise geben:
<UL>
<LI> Versuchen Sie, die Prozessorbefehle in Gruppen aufzusplitten, die
    gleiche Operanden erwarten und sich nur in einigen Kennbits
    unterscheiden. Alle argumentlosen Befehle kann man z.B. so in
    einer Tabelle abhandeln.</LI>
<LI> Die meisten Prozessoren haben ein festes Repertoire von
    Adressierungsarten. Verlagern Sie das Parsing eines
    Adre&szlig;ausdrucks in eine getrennte Unterroutine.</LI>
<LI> Die Routine<TT> WrError</TT> definiert eine Vielzahl von
    m&ouml;glichen Fehlermeldungen und ist bei Bedarf leicht
    erweiterbar. Nutzen Sie das! Bei allen Fehler nur lapidar einen
    ,,Syntaxfehler'' zu melden, n&uuml;tzt niemandem!</LI>
</UL>
Mit Sicherheit wird auch das Studium der vorhandenen Module
weiterhelfen.
<P>

<H4>&Auml;nderungen f&uuml;r die Dienstprogramme</H4>
<P>
Eine winzige &Auml;nderung ist auch noch an den Quellen der
Dienstprogramme n&ouml;tig, und zwar in der Routine<TT>
Granularity()</TT> in<TT> toolutils.c</TT>: Falls eines der
Adre&szlig;r&auml;ume dieses Prozessors eine andere Granularit&auml;t
als 1 hat, mu&szlig; dort die Abfrage passend erg&auml;nzt werden,
sonst verz&auml;hlen sich PLIST, P2BIN und P2HEX...
<P>

<H2><A NAME="sect_I_9_">I.9. Lokalisierung auf eine neue Sprache</A></H2>
<P>
Sie haben Interesse an diesem Thema? Wunderbar! Das ist eine Sache,
die von Programmierern gerne au&szlig;en vor gelassen wird,
insbesondere, wenn sie aus dem Land der unbegrenzten
M&ouml;glichkeiten kommen...
<P>
Die Lokalisierung auf eine neue Sprache gliedert sich in zwei Teile:
Die Anpassung der Programmmeldungen sowie die &Uuml;bersetzung der
Anleitung. Letzteres ist sicherlich eine Aufgabe herkulischen
Ausma&szlig;es, aber die Anpassung der Programmeldungen solle in ein
bis zwei Nachmittagen &uuml;ber die B&uuml;hne zu bekommen sein, wenn
man sowohl die neue als auch eine der bisher vorhandenen Sprachen gut
kennt. Leider ist die &Uuml;bersetzung auch nichts, was man
St&uuml;ck f&uuml;r St&uuml;ck machen kann, denn der
Ressourcencompiler kann im Moment nicht mit einer variablen Zahl von
Sprachen in den verschiedenen Meldungen umgehen, es hei&szlig;t also
'alles oder nichts'.
<P>
Als erstes erg&auml;nzt man in<TT> header.res</TT> die neue Sprache.
Die f&uuml;r die Sprache passende zweibuchstabige Abk&uuml;rzung holt
man sich vom n&auml;chsten Unix-System (wenn man nicht ohnehin darauf
arbeitet...), die internationale Vorwahl aus dem n&auml;chsten
DOS-Handbuch.
<P>
Im zweiten Schritt geht man jetzt durch alle anderen<TT>
.res</TT>-Dateien und erg&auml;nzt die<TT> Message</TT>-Statements.
Nocheinmal sei darauf hingewiesen, Sonderzeichen in der HTML-artigen
Schreibweise und nicht direkt einzusetzen!
<P>
Wenn dies geschafft ist, kann man mit einem<EM> make</EM> alle
betroffenen Teile neu bauen und erh&auml;lt danach einen Assembler,
der eine Sprache mehr schickt. Bitte nicht vergessen, die Ergebnisse
an mich weiterzuleiten, damit mit der n&auml;chsten Release alle
etwas davon haben :-)
<P>
<P>
<P>
<H1><A NAME="sect_bib">Literaturverzeichnis</A></H1>
<DL COMPACT>
<DT><A NAME="cite_Williams">[ 1] </A><DD>Steve Williams:<BR>
     <EM> 68030 Assembly Language Reference.</EM><BR>
     Addison-Wesley, Reading, Massachusetts, 1989
<DT><A NAME="cite_AMD29K">[ 2] </A><DD>Advanced Micro Devices:<BR>
     <EM> AM29240, AM29245, and AM29243 RISC
     Microcontrollers.</EM><BR>
     1993
<DT><A NAME="cite_AtAVR">[ 3] </A><DD>Atmel Corp.:<BR>
     <EM> AVR Enhanced RISC Microcontroller Data Book.</EM><BR>
     May 1996
<DT><A NAME="cite_AVRObj">[ 4] </A><DD>Atmel Corp.:<BR>
     <EM> 8-Bit AVR Assembler and Simulator Object File Formats
     (Preliminary).</EM><BR>
     (Teil der AVR-Tools-Dokumentation)
<DT><A NAME="cite_CMD816">[ 5] </A><DD>CMD Microcircuits:<BR>
     <EM> G65SC802 / G65SC816 CMOS 8/16-Bit Microprocessor Family
     Data Sheet.</EM>
<DT><A NAME="cite_COP4">[ 6] </A><DD>National Semiconductor:<BR>
     <EM> COP410L/COP411L/COP310L/COP311L Single-Chip N-Channel
     Microcontrollers.</EM> RRD-B30M105, March 1992
<DT><A NAME="cite_COPS">[ 7] </A><DD>National Semiconductor:<BR>
     <EM> COPS Family User's Guide.</EM>
<DT><A NAME="cite_CPM68K">[ 8] </A><DD>Digital Research :<BR>
     <EM> CP/M 68K Operating System User's Guide.</EM><BR>
     1983
<DT><A NAME="cite_Cyrix">[ 9] </A><DD>Cyrix Corp. :<BR>
     <EM> FasMath 83D87 User's Manual.</EM><BR>
     1990
<DT><A NAME="cite_Dallas320">[10] </A><DD>Dallas Semiconductor:<BR>
     <EM> DS80C320 High-Speed Micro User's Guide.</EM><BR>
     Version 1.30, 1/94
<DT><A NAME="cite_Fair1101">[11] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACE1101 Data Sheet.</EM><BR>
     Preliminary, May 1999
<DT><A NAME="cite_Fair1202">[12] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACE1202 Data Sheet.</EM><BR>
     Preliminary, May 1999
<DT><A NAME="cite_Fair8004">[13] </A><DD>Fairchild Semiconductor:<BR>
     <EM> ACEx Guide to Developer Tools.</EM> AN-8004, Version 1.3
     September 1998
<DT><A NAME="cite_Free12X">[14] </A><DD>Freescale Semiconductor:<BR>
     <EM> S12XCPUV1 Reference Manual.</EM> S12XCPUV1, v01.01, 03/2005
<DT><A NAME="cite_FreeRS08">[15] </A><DD>Freescale Semiconductor:<BR>
     <EM> RS08 Core Reference Manual.</EM> RS08RM, Rev. 1.0, 04/2006
<DT><A NAME="cite_FreeXGATE">[16] </A><DD>Freescale
     Semiconductor:<BR>
     <EM> MC9S12XDP512 Data Sheet.</EM> MC9S12XDP512, Rev. 2.11,
     5/2005
<DT><A NAME="cite_FujitsuCD">[17] </A><DD>Fujitsu Limited:<BR>
     <EM> June 1998 Semiconductor Data Book.</EM><BR>
     CD00-00981-1E
<DT><A NAME="cite_Fujitsu16">[18] </A><DD>Fujitsu Semiconductor:<BR>
     <EM> F&sup2;MC16LX 16-Bit Microcontroller MB90500 Series
     Programming Manual.</EM><BR>
     CM44-00201-1E, 1998
<DT><A NAME="cite_Hit180">[19] </A><DD>Hitachi Ltd. :<BR>
     <EM> 8-/16-Bit Microprocessor Data Book.</EM><BR>
     1986
<DT><A NAME="cite_Hit63">[20] </A><DD>Trevor J.Terrel &amp; Robert J.
     Simpson :<BR>
     <EM> Understanding HD6301X/03X CMOS Microprocessor
     Systems.</EM><BR>
     erschienen bei Hitachi
<DT><A NAME="cite_HitH8_3">[21] </A><DD>Hitachi Microcomputer:<BR>
     <EM> H8/300H Series Programming Manual.</EM><BR>
     (21-032, keine Jahresangabe)
<DT><A NAME="cite_SH7000">[22] </A><DD>Hitachi Semiconductor Design
     &amp; Development Center:<BR>
     <EM> SH Microcomputer Hardware Manual (Preliminary).</EM>
<DT><A NAME="cite_SH7700">[23] </A><DD>Hitachi Semiconductor and IC
     Div.:<BR>
     <EM> SH7700 Series Programming Manual.</EM><BR>
     1st Edition, September 1995
<DT><A NAME="cite_HitH8_5">[24] </A><DD>Hitachi Semiconductor and IC
     Div.:<BR>
     <EM> H8/500 Series Programming Manual.</EM><BR>
     (21-20, 1st Edition Feb. 1989)
<DT><A NAME="cite_HitH8_532">[25] </A><DD>Hitachi Ltd.:<BR>
     <EM> H8/532 Hardware Manual.</EM><BR>
     (21-30, keine Jahresangabe)
<DT><A NAME="cite_HitH8_534">[26] </A><DD>Hitachi Ltd.:<BR>
     <EM> H8/534, H8/536 Hardware Manual.</EM><BR>
     (21-19A, keine Jahresangabe)
<DT><A NAME="cite_PPC403">[27] </A><DD>IBM Corp.:<BR>
     <EM> PPC403GA Embedded Controller User's Manual.</EM><BR>
     First Edition, September 1994
<DT><A NAME="cite_IntEmb">[28] </A><DD>Intel Corp. :<EM> Embedded
     Controller Handbook.</EM><BR>
     1987
<DT><A NAME="cite_IntMic">[29] </A><DD>Intel Corp. :<BR>
     <EM> Microprocessor and Peripheral Handbook.</EM><BR>
     Volume I Microprocessor, 1988
<DT><A NAME="cite_Int960">[30] </A><DD>Intel Corp. :<BR>
     <EM> 80960SA/SB Reference Manual.</EM><BR>
     1991
<DT><A NAME="cite_Int196">[31] </A><DD>Intel Corp.:<BR>
     <EM> 8XC196NT Microcontroller User's Manual.</EM><BR>
     June 1995
<DT><A NAME="cite_Int251">[32] </A><DD>Intel Corp.:<BR>
     <EM> 8XC251SB High Performance CHMOS Single-Chip
     Microcontroller.</EM><BR>
     Sept. 1995, Order Number 272616-003
<DT><A NAME="cite_Int296">[33] </A><DD>Intel Corp.:<BR>
     <EM> 80296SA Microcontroller User's Manual.</EM><BR>
     Sept. 1996
<DT><A NAME="cite_Int4040">[34] </A><DD>Intel Corp.:<BR>
     <EM> 4040: Single-Chip 4-Bit P-Channel Microprocessor.</EM><BR>
     (keine Jahresangabe)
<DT><A NAME="cite_Inters02">[35] </A><DD>Intersil:<BR>
     <EM> CDP1802A, CDP1802AC, CDP1802BC CMOS 8-Bit
     Microprocessors.</EM><BR>
     March 1997
<DT><A NAME="cite_Inters05">[36] </A><DD>Intersil:<BR>
     <EM> CDP1805AC, CDP1806AC CMOS 8-Bit Microprocessor with On-Chip
     RAM and Counter/Timer.</EM><BR>
     March 1997
<DT><A NAME="cite_Kaku">[37] </A><DD>Hirotsugu Kakugawa:<BR>
     <EM> A memo on the secret features of 6309.</EM><BR>
     (erh&auml;ltlich &uuml;ber WWW:<BR>
     http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)
<DT><A NAME="cite_LatMico8">[38] </A><DD>Lattice Semiconductor
     Corporation:<BR>
     LatticeMico8 Microcontroller Users Guide.<BR>
     Reference Design RD1026, February 2008
<DT><A NAME="cite_MicroChip">[39] </A><DD>Microchip Technology
     Inc.:<BR>
     <EM> Microchip Data Book.</EM><BR>
     1993 Edition
<DT><A NAME="cite_Mit41">[40] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 8-Bit Microcomputers</EM><BR>
     Vol.2, 1987
<DT><A NAME="cite_Mit16">[41] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 16-Bit Microcomputers.</EM><BR>
     Enlarged edition, 1991
<DT><A NAME="cite_Mit8">[42] </A><DD>Mitsubishi Electric:<BR>
     <EM> Single-Chip 8 Bit Microcomputers.</EM><BR>
     Vol.2, 1992
<DT><A NAME="cite_Mit4500">[43] </A><DD>Mitsubishi Electric:<BR>
     <EM> M34550Mx-XXXFP Users's Manual.</EM><BR>
     Jan. 1994
<DT><A NAME="cite_MitM16">[44] </A><DD>Mitsubishi Electric:<BR>
     <EM> M16 Family Software Manual.</EM><BR>
     First Edition, Sept. 1994
<DT><A NAME="cite_MitM16C">[45] </A><DD>Mitsubishi Electric:<BR>
     <EM> M16C Software Manual.</EM><BR>
     First Edition, Rev. C, 1996
<DT><A NAME="cite_Mit30600">[46] </A><DD>Mitsubishi Electric:<BR>
     <EM> M30600-XXXFP Data Sheet.</EM><BR>
     First Edition, April 1996
<DT><A NAME="cite_GreenM16">[47] </A><DD>Dokumentation zum
     M16/M32-Entwicklungspaket von Green Hills Software
<DT><A NAME="cite_MotMic">[48] </A><DD>Motorola Inc. :<BR>
     <EM> Microprocessor, Microcontroller and Peripheral
     Data.</EM><BR>
     Vol. I+II, 1988
<DT><A NAME="cite_Mot81">[49] </A><DD>Motorola Inc. :<BR>
     <EM> MC68881/882 Floating Point Coprocessor User's
     Manual.</EM><BR>
     Prentice-Hall, Englewood Cliffs, Second Edition 1989
<DT><A NAME="cite_Mot51">[50] </A><DD>Motorola Inc. :<BR>
     <EM> MC68851 Paged Memory Management Unit User's
     Manual.</EM><BR>
     Prentice-Hall, Englewood Cliffs, Second Edition 1989
<DT><A NAME="cite_Mot32">[51] </A><DD>Motorola Inc.:<BR>
     <EM> CPU32 Reference Manual.</EM><BR>
     Rev. 1, 1990
<DT><A NAME="cite_Mot56">[52] </A><DD>Motorola Inc.:<BR>
     <EM> DSP56000/DSP56001 Digital Signal Processor User's
     Manual.</EM><BR>
     Rev. 2, 1990
<DT><A NAME="cite_Mot340">[53] </A><DD>Motorola Inc.:<BR>
     <EM> MC68340 Technical Summary.</EM><BR>
     Rev. 2, 1991
<DT><A NAME="cite_Mot16">[54] </A><DD>Motorola Inc.:<BR>
     <EM> CPU16 Reference Manual.</EM><BR>
     Rev. 1, 1991
<DT><A NAME="cite_Mot68K">[55] </A><DD>Motorola Inc.:<BR>
     <EM> Motorola M68000 Family Programmer's Reference
     Manual.</EM><BR>
     1992
<DT><A NAME="cite_Mot332">[56] </A><DD>Motorola Inc.:<BR>
     <EM> MC68332 Technical Summary.</EM><BR>
     Rev. 2, 1993
<DT><A NAME="cite_Mot601">[57] </A><DD>Motorola Inc.:<BR>
     <EM> PowerPC 601 RISC Microprocessor User's Manual.</EM><BR>
     1993
<DT><A NAME="cite_Mot505">[58] </A><DD>Motorola Inc.:<BR>
     <EM> PowerPC(tm) MPC505 RISC Microcontroller Technical
     Summary.</EM><BR>
     1994
<DT><A NAME="cite_Mot12">[59] </A><DD>Motorola Inc.:<BR>
     <EM> CPU12 Reference Manual.</EM><BR>
     1st. edition, 1996
<DT><A NAME="cite_Mot08">[60] </A><DD>Motorola Inc.:<BR>
     <EM> CPU08 Reference Manual.</EM><BR>
     Rev. 1 (keine Jahresangabe im PDF-File)
<DT><A NAME="cite_Mot360">[61] </A><DD>Motorola Inc.:<BR>
     <EM> MC68360 User's Manual.</EM>
<DT><A NAME="cite_MotCold">[62] </A><DD>Motorola Inc.:<BR>
     <EM> MCF 5200 ColdFire Family Programmer's Reference
     Manual.</EM><BR>
     1995
<DT><A NAME="cite_MotMCore">[63] </A><DD>Motorola Inc.:<BR>
     <EM> M*Core Programmer's Reference Manual.</EM><BR>
     1997
<DT><A NAME="cite_Mot56300">[64] </A><DD>Motorola Inc.:<BR>
     <EM> DSP56300 24-Bit Digital Signal Processor Family
     Manual.</EM><BR>
     Rev. 0 (keine Jahresangabe im PDF-File)
<DT><A NAME="cite_MotK4">[65] </A><DD>Motorola Inc.:<BR>
     <EM> MC68HC11K4 Technical Data.</EM> 1992
<DT><A NAME="cite_SCMP">[66] </A><DD>National Semiconductor:<BR>
     <EM> SC/MP Programmier- und Assembler-Handbuch.</EM><BR>
     Publication Number 4200094A, Aug. 1976
<DT><A NAME="cite_AsmCop">[67] </A><DD>National Semiconductor:<BR>
     <EM> COP800 Assembler/Linker/Librarian User's Manual.</EM><BR>
     Customer Order Number COP8-ASMLNK-MAN, NSC Publication Number
     424421632-001B, August 1993
<DT><A NAME="cite_Cop87L84">[68] </A><DD>National Semiconductor:<BR>
     <EM> COP87L84BC microCMOS One-Time-Programmable (OTP)
     Microcontroller.</EM><BR>
     Preliminary, March 1996
<DT><A NAME="cite_Nat14xxx">[69] </A><DD>National Semiconductor:<BR>
     <EM> SC14xxx DIP commands Reference guide.</EM><BR>
     Application Note AN-D-031, Version 0.4, 28.12.1998
<DT><A NAME="cite_Nat8070">[70] </A><DD>National Semiconductor:<BR>
     <EM> INS8070-Series Microprocessor Family.</EM> October 1980
<DT><A NAME="cite_NECV">[71] </A><DD>NEC Corp.:<BR>
     <EM> &micro;pD70108 / &micro;pD70116 / &micro;pD70208 /
     &micro;pD70216 / &micro;pD72091 Data Book.</EM><BR>
     (keine Jahresangabe)
<DT><A NAME="cite_NEC78">[72] </A><DD>NEC Electronics Europe
     GmbH:<BR>
     <EM> User's Manual &micro;COM-87 AD Family.</EM><BR>
     (keine Jahresangabe)
<DT><A NAME="cite_NEC75">[73] </A><DD>NEC Corp.:<BR>
     <EM> &micro;COM-75x Family 4-bit CMOS Microcomputer User's
     Manual.</EM><BR>
     Vol. I+II (keine Jahresangabe)
<DT><A NAME="cite_NECSig">[74] </A><DD>NEC Corp.:<BR>
     <EM> Digital Signal Processor Product Description.</EM><BR>
     PDDSP.....067V20 (keine Jahresangabe)
<DT><A NAME="cite_NEC78K0">[75] </A><DD>NEC Corp.:<BR>
     <EM> &micro;PD78070A, 78070AY 8-Bit Single-Chip Microcontroller
     User's Manual.</EM><BR>
     Document No. U10200EJ1V0UM00 (1st edition), August 1995
<DT><A NAME="cite_NEC7814">[76] </A><DD>NEC Corp.:<BR>
     <EM> Data Sheet &micro;PD78014.</EM>
<DT><A NAME="cite_NEC78K2">[77] </A><DD>NEC Corp.:<BR>
     <EM> 78K/II Series 8-Bit Single-Chip Microcontroller User's
     Manual - Instructions.</EM><BR>
     Document No. U10228EJ6V0UM00 (6th edition), December 1995
<DT><A NAME="cite_PhilXA">[78] </A><DD>Philips Semiconductor:<BR>
     <EM> 16-bit 80C51XA Microcontrollers (eXtended
     Architecture).</EM><BR>
     Data Handbook IC25, 1996
<DT><A NAME="cite_SGS04">[79] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> 8 Bit MCU Families EF6801/04/05 Databook.</EM><BR>
     1st edition, 1989
<DT><A NAME="cite_SGS62">[80] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST6210/ST6215/ST6220/ST6225 Databook.</EM><BR>
     1st edition, 1991
<DT><A NAME="cite_ST7Man">[81] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST7 Family Programming Manual.</EM><BR>
     June 1995
<DT><A NAME="cite_SGS9">[82] </A><DD>SGS-Thomson
     Microelectronics:<BR>
     <EM> ST9 Programming Manual.</EM><BR>
     3rd edition, 1993
<DT><A NAME="cite_Siem166">[83] </A><DD>Siemens AG:<BR>
     <EM> SAB80C166/83C166 User's Manual.</EM><BR>
     Edition 6.90
<DT><A NAME="cite_Siem167">[84] </A><DD>Siemens AG:<BR>
     <EM> SAB C167 Preliminary User's Manual.</EM><BR>
     Revision 1.0, July 1992
<DT><A NAME="cite_Siem502">[85] </A><DD>Siemens AG:<BR>
     <EM> SAB-C502 8-Bit Single-Chip Microcontroller User's
     Manual.</EM><BR>
     Edition 8.94
<DT><A NAME="cite_Siem501">[86] </A><DD>Siemens AG:<BR>
     <EM> SAB-C501 8-Bit Single-Chip Microcontroller User's
     Manual.</EM><BR>
     Edition 2.96
<DT><A NAME="cite_Siem504">[87] </A><DD>Siemens AG:<BR>
     <EM> C504 8-Bit CMOS Microcontroller User's Manual.</EM><BR>
     Edition 5.96
<DT><A NAME="cite_Syb68K">[88] </A><DD>C.Vieillefond:<BR>
     <EM> Programmierung des 68000.</EM><BR>
     Sybex-Verlag D&uuml;sseldorf, 1985
<DT><A NAME="cite_Sym8xx">[89] </A><DD>Symbios Logic Inc:<BR>
     <EM> Symbios Logic PCI-SCSI-I/O Processors Programming
     Guide.</EM><BR>
     Version 2.0, 1995/96
<DT><A NAME="cite_Ti990">[90] </A><DD>Texas Instruments:<BR>
     <EM> Model 990 Computer/TMS9900 Microprocessor Assembly Language
     Programmer's Guide.</EM><BR>
     1977, Manual No. 943441-9701
<DT><A NAME="cite_Ti9900">[91] </A><DD>Texas Instruments:<BR>
     <EM> TMS9995 16-Bit Microcomputer Preliminary Data
     Manual.</EM><BR>
     1981
<DT><A NAME="cite_TiC10">[92] </A><DD>Texas Instruments:<BR>
     <EM> First-Generation TMS320 User's Guide.</EM><BR>
     1988, ISBN 2-86886-024-9
<DT><A NAME="cite_Ti7000">[93] </A><DD>Texas Instruments:<BR>
     <EM> TMS7000 family Data Manual.</EM><BR>
     1991, DB103
<DT><A NAME="cite_TiC30">[94] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C3x User's Guide.</EM><BR>
     Revision E, 1991
<DT><A NAME="cite_TiC20">[95] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C2x User's Guide.</EM><BR>
     Revision C, Jan. 1993
<DT><A NAME="cite_Ti370">[96] </A><DD>Texas Instruments:<BR>
     <EM> TMS370 Family Data Manual.</EM><BR>
     1994, SPNS014B
<DT><A NAME="cite_Ti430FamSoft">[97] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Family Software User's Guide.</EM><BR>
     1994, SLAUE11
<DT><A NAME="cite_Ti430Met">[98] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Metering Application.</EM><BR>
     1996, SLAAE10A
<DT><A NAME="cite_Ti430FamArch">[99] </A><DD>Texas Instruments:<BR>
     <EM> MSP430 Family Architecture User's Guide.</EM><BR>
     1995, SLAUE10A
<DT><A NAME="cite_TiC60">[100] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C62xx CPU and Instruction Set Reference
     Manual.</EM><BR>
     Jan. 1997, SPRU189A
<DT><A NAME="cite_TiC20x">[101] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C20x User's Guide.</EM><BR>
     April 1999, SPRU127C
<DT><A NAME="cite_Tispru131g">[102] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C54x DSP Reference Set; Volume 1: CPU and
     Peripherals.</EM><BR>
     March 2001, SPRU172C
<DT><A NAME="cite_Tispru172c">[103] </A><DD>Texas Instruments:<BR>
     <EM> TMS320C54x DSP; Volume 2: Mnemonic Instruction
     Set.</EM><BR>
     March 2001, SPRU172C
<DT><A NAME="cite_Tosh90">[104] </A><DD>Toshiba Corp.:<BR>
     <EM> 8-Bit Microcontroller TLCS-90 Development System
     Manual.</EM><BR>
     1990
<DT><A NAME="cite_Tosh870">[105] </A><DD>Toshiba Corp.:<BR>
     <EM> 8-Bit Microcontroller TLCS-870 Series Data Book.</EM><BR>
     1992
<DT><A NAME="cite_Tosh900">[106] </A><DD>Toshiba Corp.:<BR>
     <EM> 16-Bit Microcontroller TLCS-900 Series Users
     Manual.</EM><BR>
     1992
<DT><A NAME="cite_Tosh900L">[107] </A><DD>Toshiba Corp.:<BR>
     <EM> 16-Bit Microcontroller TLCS-900 Series Data Book:<BR>
     TMP93CM40F/TMP93CM41F.</EM><BR>
     1993
<DT><A NAME="cite_Tosh47">[108] </A><DD>Toshiba Corp.:<BR>
     <EM> 4-Bit Microcontroller TLCS-47E/47/470/470A Development
     System Manual.</EM><BR>
     1993
<DT><A NAME="cite_Tosh9000">[109] </A><DD>Toshiba Corp.:<BR>
     <EM> TLCS-9000/16 Instruction Set Manual Version 2.2.</EM><BR>
     10. Feb 1994
<DT><A NAME="cite_Val8X">[110] </A><DD>Valvo GmbH:<BR>
     <EM> Bipolare Mikroprozessoren und bipolare
     LSI-Schaltungen.</EM><BR>
     Datenbuch, 1985, ISBN 3-87095-186-9
<DT><A NAME="cite_Xil213">[111] </A><DD>Ken Chapman (Xilinx
     Inc.):<BR>
     <EM> PicoBlaze 8-Bit Microcontroller for Virtex-E and
     Spartan-II/IIE Devices.</EM><BR>
     Application Note XAPP213, Version 2.1, February 2003
<DT><A NAME="cite_Xil129">[112] </A><DD>Xilinx Inc.:<BR>
     <EM> PicoBlaze 8-bit Embedded Microcontroller User Guide for
     Spartan-3, Virtex-II, and Virtex-II Pro FPGAs.</EM><BR>
     UG129 (v1.1) June 10, 2004
<DT><A NAME="cite_Zilog">[113] </A><DD>Datenbl&auml;tter der Firma
     Zilog zur Z80-Familie
<DT><A NAME="cite_ZilZ8">[114] </A><DD>Zilog Inc.:<BR>
     <EM> Z8 Microcontrollers Databook.</EM><BR>
     1992
<DT><A NAME="cite_ZilZ8_2">[115] </A><DD>Zilog Inc.:<BR>
     <EM> Discrete Z8 Microcontrollers Databook.</EM><BR>
     (keine Jahresangabe)
<DT><A NAME="cite_ZilZ380">[116] </A><DD>Zilog Inc.:<BR>
     <EM> Z380 CPU Central Processing Unit User's Manual.</EM><BR>
     (keine Jahresangabe)
<DT><A NAME="cite_ZileZ8">[117] </A><DD>Zilog Inc.:<BR>
     <EM> eZ8 CPU User Manual.</EM><BR>
     UM01285-0503
</DL>
<P>
<P>
<BLOCKQUOTE>
    <I> ''Ich schlage vor, dem Parlament ein Gesetz vorzulegen,<BR>
    das einem Autor, der ein Buch ohne Index publiziert,<BR>
    das Copyright entzieht und ihn au&szlig;erdem f&uuml;r sein
    Vergehen<BR>
    mit einer Geldstrafe belegt.''<BR>
              --Lord John Campbell</I>
</BLOCKQUOTE>
<P>
<H1><A NAME="sect_index">Index</A></H1>
<TABLE SUMMARY="Index" BORDER=0 CELLPADDING=5>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ADDR <A HREF="#index_ADDR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ADDRW <A HREF="#index_ADDRW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ADR <A HREF="#index_ADR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ALIGN <A HREF="#index_ALIGN_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ASCII <A HREF="#index_ASCII_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ASCIZ <A HREF="#index_ASCIZ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ASSUME <A HREF="#index_ASSUME_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BFLOAT <A HREF="#index_BFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BIGENDIAN <A HREF="#index_BIGENDIAN_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BINCLUDE <A HREF="#index_BINCLUDE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>BIT <A HREF="#index_BIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BLOCK <A HREF="#index_BLOCK_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BRANCHEXT <A HREF="#index_BRANCHEXT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BSS <A HREF="#index_BSS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>BYT <A HREF="#index_BYT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>BYTE <A HREF="#index_BYTE_1">1</A> <A HREF="#index_BYTE_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>CASE <A HREF="#index_CASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CHARSET <A HREF="#index_CHARSET_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CODEPAGE <A HREF="#index_CODEPAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>CONSTANT <A HREF="#index_CONSTANT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>CPU <A HREF="#index_CPU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DATA <A HREF="#index_DATA_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DB <A HREF="#index_DB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DBIT <A HREF="#index_DBIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DC <A HREF="#index_DC_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DC8 <A HREF="#index_DC8_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DD <A HREF="#index_DD_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFB <A HREF="#index_DEFB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEFW <A HREF="#index_DEFW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DEPHASE <A HREF="#index_DEPHASE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DFS <A HREF="#index_DFS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DOTTEDSTRUCTS <A HREF="#index_DOTTEDSTRUCTS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DOUBLE <A HREF="#index_DOUBLE_1">1</A> <A HREF="#index_DOUBLE_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>DQ <A HREF="#index_DQ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DS <A HREF="#index_DS_1">1</A> <A HREF="#index_DS_2">2</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DS16 <A HREF="#index_DS16_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DS8 <A HREF="#index_DS8_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DSB <A HREF="#index_DSB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DSW <A HREF="#index_DSW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DT <A HREF="#index_DT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>DUP <A HREF="#index_DUP_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DW <A HREF="#index_DW_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>DW16 <A HREF="#index_DW16_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EFLOAT <A HREF="#index_EFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ELSE <A HREF="#index_ELSE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ELSECASE <A HREF="#index_ELSECASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ELSEIF <A HREF="#index_ELSEIF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EMULATED <A HREF="#index_EMULATED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>END <A HREF="#index_END_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDCASE <A HREF="#index_ENDCASE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>ENDIF <A HREF="#index_ENDIF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDM <A HREF="#index_ENDM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDS <A HREF="#index_ENDS_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENDSTRUCT <A HREF="#index_ENDSTRUCT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ENUM <A HREF="#index_ENUM_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>EQU <A HREF="#index_EQU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ERROR <A HREF="#index_ERROR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXITM <A HREF="#index_EXITM_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXTENDED <A HREF="#index_EXTENDED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>EXTMODE <A HREF="#index_EXTMODE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>FATAL <A HREF="#index_FATAL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FB <A HREF="#index_FB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FCB <A HREF="#index_FCB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FCC <A HREF="#index_FCC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FDB <A HREF="#index_FDB_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>FLOAT <A HREF="#index_FLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FPU <A HREF="#index_FPU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FULLPMMU <A HREF="#index_FULLPMMU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FUNCTION <A HREF="#index_FUNCTION_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>FW <A HREF="#index_FW_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IF <A HREF="#index_IF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFB <A HREF="#index_IFB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFDEF <A HREF="#index_IFDEF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFEXIST <A HREF="#index_IFEXIST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNB <A HREF="#index_IFNB_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IFNDEF <A HREF="#index_IFNDEF_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNEXIST <A HREF="#index_IFNEXIST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFNUSED <A HREF="#index_IFNUSED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IFUSED <A HREF="#index_IFUSED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>INCLUDE <A HREF="#index_INCLUDE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>IRP <A HREF="#index_IRP_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>IRPC <A HREF="#index_IRPC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LABEL <A HREF="#index_LABEL_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LISTING <A HREF="#index_LISTING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LIV <A HREF="#index_LIV_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>LONG <A HREF="#index_LONG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LQxx <A HREF="#index_LQxx_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LTORG <A HREF="#index_LTORG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>LWORDMODE <A HREF="#index_LWORDMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MACEXP <A HREF="#index_MACEXP_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>MACRO <A HREF="#index_MACRO_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MAXMODE <A HREF="#index_MAXMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MAXNEST <A HREF="#index_MAXNEST_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>MESSAGE <A HREF="#index_MESSAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>NAMEREG <A HREF="#index_NAMEREG_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>NEWPAGE <A HREF="#index_NEWPAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ORG <A HREF="#index_ORG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>OUTRADIX <A HREF="#index_OUTRADIX_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PACKING <A HREF="#index_PACKING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PADDING <A HREF="#index_PADDING_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>PAGE <A HREF="#index_PAGE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PHASE <A HREF="#index_PHASE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PMMU <A HREF="#index_PMMU_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>POPV <A HREF="#index_POPV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PORT <A HREF="#index_PORT_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>PRTEXIT <A HREF="#index_PRTEXIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PRTINIT <A HREF="#index_PRTINIT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>PUSHV <A HREF="#index_PUSHV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>Qxx <A HREF="#index_Qxx_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RADIX <A HREF="#index_RADIX_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>READ <A HREF="#index_READ_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>REG <A HREF="#index_REG_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RELAXED <A HREF="#index_RELAXED_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>REPT <A HREF="#index_REPT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RES <A HREF="#index_RES_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>RESTORE <A HREF="#index_RESTORE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RIV <A HREF="#index_RIV_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RMB <A HREF="#index_RMB_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>RSTRING <A HREF="#index_RSTRING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>Registersymbole <A HREF="#index_Registersymbole_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SAVE <A HREF="#index_SAVE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SEGMENT <A HREF="#index_SEGMENT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SET <A HREF="#index_SET_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SFR <A HREF="#index_SFR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SFRB <A HREF="#index_SFRB_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>SHARED <A HREF="#index_SHARED_1">1</A> <A HREF="#index_SHARED_2">2</A> <A HREF="#index_SHARED_3">3</A></TD>
<TD VALIGN=TOP NOWRAP>SHIFT <A HREF="#index_SHIFT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SINGLE <A HREF="#index_SINGLE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SPACE <A HREF="#index_SPACE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SRCMODE <A HREF="#index_SRCMODE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>STRING <A HREF="#index_STRING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>STRUC <A HREF="#index_STRUC_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>STRUCT <A HREF="#index_STRUCT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SUPMODE <A HREF="#index_SUPMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>SWITCH <A HREF="#index_SWITCH_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>TFLOAT <A HREF="#index_TFLOAT_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>TITLE <A HREF="#index_TITLE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>UNION <A HREF="#index_UNION_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>WARNING <A HREF="#index_WARNING_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>WHILE <A HREF="#index_WHILE_1">1</A></TD>
</TR>
<TR ALIGN=LEFT>
<TD VALIGN=TOP NOWRAP>WORD <A HREF="#index_WORD_1">1</A> <A HREF="#index_WORD_2">2</A></TD>
<TD VALIGN=TOP NOWRAP>WRAPMODE <A HREF="#index_WRAPMODE_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>XSFR <A HREF="#index_XSFR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>YSFR <A HREF="#index_YSFR_1">1</A></TD>
<TD VALIGN=TOP NOWRAP>ZERO <A HREF="#index_ZERO_1">1</A></TD>
</TR>
</TABLE>
<P>
</BODY>
</HTML>
